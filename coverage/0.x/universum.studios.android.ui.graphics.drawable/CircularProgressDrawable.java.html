<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CircularProgressDrawable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.graphics.drawable</a> &gt; <span class="el_source">CircularProgressDrawable.java</span></div><h1>CircularProgressDrawable.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.graphics.drawable;

import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.support.annotation.IntDef;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.Px;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * A {@link ProgressDrawable} implementation which draws a progress or an indeterminate graphics as
 * circular (oval) shape. Size of the oval can be specified by {@link #setRadius(int)} and its thickness
 * can be specified by {@link #setThickness(float)}. &lt;b&gt;Note&lt;/b&gt;, that as any drawable implementation
 * also this drawable will draw its graphics into bounds set by {@link #setBounds(int, int, int, int)},
 * the radius set to this drawable is only for informational purpose for a {@link android.view.View}
 * which hosts this drawable to determine how much space is needed to draw graphics of this drawable.
 * The required size can be obtained by {@link #getIntrinsicWidth()} and {@link #getIntrinsicHeight()}.
 * &lt;p&gt;
 * The oval's color can be specified by {@link #setColor(int)} or {@link #setColors(int[])} where
 * the specified set of colors will be used only in case of &lt;b&gt;indeterminate&lt;/b&gt; mode. See description
 * for {@link #MODE_INDETERMINATE} below for more info. This progress drawable can also draw its
 * background of which color can be specified by {@link #setBackgroundColor(int)}. The background is
 * drawn as a full progress oval with the specified thickness.
 * &lt;p&gt;
 * Whether to draw the progress or indeterminate graphics can be specified by setting a mode by
 * {@link #setMode(int)}. The supported modes for this progress drawable class are described below.
 *
 * &lt;h3&gt;Modes&lt;/h3&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * {@link #MODE_DETERMINATE}
 * &lt;p&gt;
 * A determinate mode should be used when an instance of CircularProgressDrawable should draw value
 * of progress specified by {@link #setProgress(int)}. The specified progress will be transformed
 * into degrees value and than drawn as oval. A start angle of the progress oval can be specified by
 * {@link #setStartAngle(float)}, the default one is at &lt;b&gt;270&lt;/b&gt; degrees, so at 12 a clock. When
 * a max progress is set to the CircularProgressDrawable the full progress oval =&gt; circle is drawn.
 * &lt;p&gt;
 * This mode supports auto-rotation feature of the progress oval and this feature is by default
 * &lt;b&gt;enabled&lt;/b&gt;, so whenever {@link #setProgress(int)} is called, the progress oval will be rotated
 * clockwise by degrees delta (NEW_ANGLE - OLD_ANGLE). This rotation logic will ensures hat a tail
 * and a head of the progress oval will be meeting (before they collapse) at the start angle.
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt;, that calls like {@link #start()}, {@link #stop()} are for this mode ignored.
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@link #MODE_INDETERMINATE}
 * &lt;p&gt;
 * An indeterminate mode should be used when an instance of CircularProgressDrawable should draw the
 * indeterminate graphics. The indeterminate graphics drawing is implemented as infinite amount
 * of consecutive loops, where each of these loops is consisted of progressive expanding followed by
 * progressive collapsing of the oval. This is, for purpose of the CircularProgressDrawable, called
 * as described in class overview of {@link ProgressDrawable} &lt;b&gt;indeterminate animation session&lt;/b&gt;.
 * During this animation session is the oval also progressively rotated.
 * &lt;p&gt;
 * The animation session can be started by {@link #start()} and stopped by {@link #stop()} or
 * {@link #stopImmediate()}. The difference between those two stop methods is that if requested to not
 * stop immediately via {@code stop()}, the drawing of the indeterminate graphics will be stopped after
 * the oval is fully collapsed otherwise will be stopped immediately regardless how much is the oval
 * expanded/collapsed so it will look like it just &quot;vanished&quot;.
 * &lt;p&gt;
 * This mode supports multi-coloring feature which can be enabled by {@link #setMultiColored(boolean)}.
 * If this feature is enabled, the set of colors specified by {@link #setColors(int[])} will be used
 * to change color of the oval whenever the indeterminate oval is fully collapsed. If the end of the
 * colors array is reached, the next color will be picked again from the beginning of the array and
 * so on.
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt;, that calls like {@link #setProgress(int)}, {@link #setRotation(float)} are for this
 * mode ignored.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Arrow&lt;/h3&gt;
 * An arrow feature can be enabled by {@link #setArrowEnabled(boolean)} for both {@link #MODE_DETERMINATE}
 * and {@link #MODE_INDETERMINATE} modes. If enabled, the arrow is drawn at the head of the
 * progress/indeterminate oval. This feature can be useful for refresh drawable. Enabling of this
 * feature also changes (expands) size of the CircularProgressDrawable, so the radius specified by
 * {@link #setRadius(int)} will be preserved. Size of the arrow unfortunately cannot be specified,
 * but its size will be computed according to the current thickness of the oval to ensure that the
 * arrow's appearance will fit to the whole progress drawable's appearance properly. The arrow can
 * be also scaled up/down by {@link #setArrowScale(float)} which can be used to progressively show/hide
 * the arrow.
 *
 * &lt;h3&gt;Rotating&lt;/h3&gt;
 * The progress oval can be also rotated (supported only for {@link #MODE_DETERMINATE}) by {@link #setRotation(float)}.
 * This method is used for the &lt;b&gt;auto-rotation&lt;/b&gt; feature described for determinate mode above.
 *
 * @author Martin Albedinsky
 */
public class CircularProgressDrawable extends ProgressDrawable {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;CircularProgressDrawable&quot;;

	/**
	 * Defines an annotation for determining set of allowed modes for CircularProgressDrawable.
	 */
	@Retention(RetentionPolicy.SOURCE)
	@IntDef({MODE_INDETERMINATE, MODE_DETERMINATE})
	public @interface ProgressMode {
	}

	/**
	 * Flag to request &lt;b&gt;DETERMINATE&lt;/b&gt; mode for CircularProgressDrawable which allows to set
	 * a progress value by {@link #setProgress(int)}. See {@link CircularProgressDrawable class}
	 * overview for more info.
	 */
	public static final int MODE_DETERMINATE = DETERMINATE;

	/**
	 * Flag to request &lt;b&gt;INDETERMINATE&lt;/b&gt; mode for CircularProgressDrawable which enables indeterminate
	 * animation. See {@link CircularProgressDrawable class} overview for more info.
	 */
	public static final int MODE_INDETERMINATE = INDETERMINATE;

	/**
	 * Max angle used in computations for progress/indeterminate oval of this drawable.
	 */
	private static final float MAX_ANGLE = 360;

	/**
	 * Default initial start angle for the indeterminate oval.
	 */
	private static final float INITIAL_START_ANGLE = 270;

	/**
	 * Max sweep angle for the indeterminate oval graphics.
	 */
	private static final float INDETERMINATE_MAX_SWEEP_ANGLE = 280;

	/**
	 * Size of buffer used to slow rotation of the indeterminate oval while it is fully collapsed or
	 * fully expanded.
	 */
	private static final float INDETERMINATE_SLOW_MOTION_ANGLE_BUFFER_SIZE = 45;

	/**
	 * Amount of angles used to update start angle of the indeterminate oval while indeterminate
	 * animation session is running.
	 */
	private static final float INDETERMINATE_START_ANGLE_UPDATE = 3.5f;

	/**
	 * Amount of angles used to update sweep angle of the indeterminate oval to expand it, while
	 * indeterminate animation session is running.
	 */
	private static final float INDETERMINATE_EXPANDING_ANGLE_UPDATE = 8.0f;

	/**
	 * Amount of angles used to update sweep angle of the indeterminate oval to collapse it, while
	 * indeterminate animation session is running.
	 */
	private static final float INDETERMINATE_COLLAPSING_ANGLE_UPDATE = 6.0f;

	/**
	 * Flag for indeterminate state of this drawable used while indeterminate animation session is
	 * running. This flag is used only to indicate initial state.
	 */
	private static final int INDETERMINATE_STATE_IDLE = 0x00;

	/**
	 * Flag for indeterminate state of this drawable used while indeterminate animation session is
	 * running to indicate that the indeterminate oval is being expanded.
	 */
	private static final int INDETERMINATE_STATE_EXPANDING = 0x01;

	/**
	 * Flag for indeterminate state of this drawable used while indeterminate animation session is
	 * running to indicate that the indeterminate oval is being rotated in slow motion after it was
	 * fully expanded.
	 */
	private static final int INDETERMINATE_STATE_EXPANDING_SLOW_MOTION = 0x02;

	/**
	 * Flag for indeterminate state of this drawable used while indeterminate animation session is
	 * running to indicate that the indeterminate oval is being collapsed.
	 */
	private static final int INDETERMINATE_STATE_COLLAPSING = 0x03;

	/**
	 * Flag for indeterminate state of this drawable used while indeterminate animation session is
	 * running to indicate that the indeterminate oval is being rotated in slow motion after it was
	 * fully collapsed.
	 */
	private static final int INDETERMINATE_STATE_COLLAPSING_SLOW_MOTION = 0x04;

	/**
	 * Flag indicating whether the arrow feature for this drawable is enabled or not.
	 */
	private static final int PFLAG_ARROW_ENABLED = 0x00008000;

	/**
	 * Flag indicating whether the arrow is visible or not.
	 */
	private static final int PFLAG_ARROW_VISIBLE = 0x00010000;

	/**
	 * Flag indicating whether the automatic rotation on progress change is enabled or not.
	 */
	private static final int PFLAG_ROTATE_ON_PROGRESS_CHANGE = 0x00020000;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Oval used when drawing current progress or indeterminate graphics of this drawable.
	 */
<span class="nc" id="L252">	private final RectF OVAL = new RectF();</span>

	/**
	 * Full size of drawing area for this drawable determined by its current bounds.
	 */
	private int mSize;

	/**
	 * Initial start angle for progress/indeterminate oval set by {@link #setStartAngle(float)}.
	 * This angle is used whenever current state of this drawable is reset.
	 */
<span class="nc" id="L263">	private float mUserStartAngle = INITIAL_START_ANGLE;</span>

	/**
	 * Constant state of this drawable.
	 */
	private CircularState mProgressState;

	/**
	 * Current start angle of progress/indeterminate oval.
	 * &lt;p&gt;
	 * This angle is changed whenever {@link #onUpdate()} occurs for this drawable while in the
	 * &lt;b&gt;INDETERMINATE&lt;/b&gt; mode.
	 */
<span class="nc" id="L276">	private float mStartAngle = mUserStartAngle;</span>

	/**
	 * Current sweep angle of progress/indeterminate oval.
	 * &lt;p&gt;
	 * This angle is changed whenever {@link #onUpdate()} occurs for this drawable while in the
	 * &lt;b&gt;INDETERMINATE&lt;/b&gt; mode depends on the current {@link #mIndeterminateState} or whenever
	 * {@link #onProgressChange(int)} occurs for this drawable while in the &lt;b&gt;DETERMINATE&lt;/b&gt; mode.
	 */
	private float mSweepAngle;

	/**
	 * Object holding current data for the arrow.
	 */
	private ArrowInfo mArrowInfo;

	/**
	 * Indeterminate state used to manage updating behaviour of the indeterminate oval block.
	 */
<span class="nc" id="L295">	private int mIndeterminateState = INDETERMINATE_STATE_IDLE;</span>

	/**
	 * Buffer used to &quot;froze&quot; updating of the indeterminate oval block while it is fully collapsed
	 * or fully expanded.
	 */
	private float mIndeterminateFrozenAngleBuffer;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of CircularProgressDrawable with default color and {@link #MODE_INDETERMINATE}
	 * as default mode.
	 * &lt;p&gt;
	 * Default color: &lt;b&gt;#03a9f4&lt;/b&gt;
	 */
	public CircularProgressDrawable() {
<span class="nc" id="L314">		this(DEFAULT_COLOR);</span>
<span class="nc" id="L315">	}</span>

	/**
	 * Creates a new instance of CircularProgressDrawable with the specified color and {@link #MODE_INDETERMINATE}
	 * as default mode.
	 *
	 * @param color The color used to draw progress or indeterminate graphics of the new drawable.
	 */
	public CircularProgressDrawable(int color) {
<span class="nc" id="L324">		super(color);</span>
<span class="nc" id="L325">		this.init();</span>
<span class="nc" id="L326">	}</span>

	/**
	 * Creates a new instance of CircularProgressDrawable with the specified set of &lt;var&gt;colors&lt;/var&gt;
	 * and {@link #MODE_INDETERMINATE} as default mode.
	 *
	 * @param colors The set of colors used to draw indeterminate graphics of the new drawable when
	 *               in &lt;b&gt;INDETERMINATE&lt;/b&gt; mode.
	 */
	public CircularProgressDrawable(@NonNull int[] colors) {
<span class="nc" id="L336">		super(colors);</span>
<span class="nc" id="L337">		this.init();</span>
<span class="nc" id="L338">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 */
	@Override
	public void applyTheme(@NonNull Resources.Theme theme) {
<span class="nc" id="L348">		super.applyTheme(theme);</span>
		// Unfortunately this method cannot be properly implemented for drawable not directly within
		// android.drawable package.
		/*if (mProgressState == null || mProgressState.themeAttrs == null) {
			return;
		}*/
<span class="nc" id="L354">	}</span>

	/**
	 * Sets the radius for the progress/indeterminate oval of this progress drawable. If the arrow
	 * feature is enabled by {@link #setArrowEnabled(boolean)}, the size of this drawable will be
	 * defined by the radius and also by size of the arrow. If arrow is not enabled size of this
	 * drawable will be {@code radius * 2} for both width and height of which values can be obtained
	 * by {@link #getIntrinsicWidth()} and {@link #getIntrinsicHeight()}.
	 * &lt;p&gt;
	 * Default radius is: &lt;b&gt;-1&lt;/b&gt;
	 *
	 * @param radius The desired radius.
	 * @see #getRadius()
	 */
	public void setRadius(@Px int radius) {
<span class="nc" id="L369">		mProgressState.radius = radius;</span>
<span class="nc" id="L370">	}</span>

	/**
	 * Returns the radius of the progress/indeterminate oval of this progress drawable.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that as described in {@link #setRadius(int)}, the radius does not necessarily
	 * specify size of this drawable.
	 *
	 * @return This drawable's progress/indeterminate oval's radius.
	 * @see #setRadius(int)
	 */
	@Px
	public int getRadius() {
<span class="nc" id="L383">		return mProgressState.radius;</span>
	}

	/**
	 * Returns {@code (radius * 2)} if the arrow feature is not enabled, {@code (radius * 2 + arrowOverflow)}
	 * if it is enabled.
	 */
	@Override
	public int getIntrinsicWidth() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">		return mProgressState.radius * 2 + ((mPrivateFlags &amp; PFLAG_ARROW_VISIBLE) != 0 ? (int) (mArrowInfo.wide * 3 / 8) : 0);</span>
	}

	/**
	 * Returns {@code (radius * 2)} if the arrow feature is not enabled, {@code (radius * 2 + arrowOverflow)}
	 * if it is enabled.
	 */
	@Override
	public int getIntrinsicHeight() {
<span class="nc bnc" id="L401" title="All 2 branches missed.">		return mProgressState.radius * 2 + ((mPrivateFlags &amp; PFLAG_ARROW_VISIBLE) != 0 ? (int) (mArrowInfo.wide * 3 / 8) : 0);</span>
	}

	/**
	 * Sets the initial start angle for the progress/indeterminate oval.
	 * &lt;p&gt;
	 * If in &lt;b&gt;INDETERMINATE&lt;/b&gt; mode the specified start angle will be applied after the running
	 * indeterminate animation sessions is finished. If in &lt;b&gt;DETERMINATE&lt;/b&gt; mode the specified
	 * angle will be immediately applied so it should be set before the progress updates starts.
	 * &lt;p&gt;
	 * The default start angle is: &lt;b&gt;270&lt;/b&gt;
	 *
	 * @param startAngle The desired angle from the range {@code [0, 360]}.
	 * @see #getStartAngle()
	 */
	public void setStartAngle(float startAngle) {
<span class="nc bnc" id="L417" title="All 4 branches missed.">		if (startAngle &gt;= 0 &amp;&amp; startAngle &lt;= MAX_ANGLE) {</span>
<span class="nc" id="L418">			this.mUserStartAngle = startAngle;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">			if (mMode == MODE_DETERMINATE) {</span>
<span class="nc" id="L420">				this.mStartAngle = startAngle;</span>
			}
		}
<span class="nc" id="L423">	}</span>

	/**
	 * Returns the initial start angle for the progress/indeterminate oval of this progress drawable.
	 *
	 * @return Initial start angle from the range {@code [0, 360]}.
	 * @see #setStartAngle(float)
	 */
	public float getStartAngle() {
<span class="nc" id="L432">		return mUserStartAngle;</span>
	}

	/**
	 */
	@Override
	public void setMode(@ProgressMode int mode) {
<span class="nc" id="L439">		super.setMode(mode);</span>
<span class="nc" id="L440">	}</span>

	/**
	 */
	@Override
	@ProgressMode
	@SuppressWarnings(&quot;ResourceType&quot;)
	public int getMode() {
<span class="nc" id="L448">		return super.getMode();</span>
	}

	/**
	 * Sets the rotation for the progress oval of this progress drawable. The specified rotation will
	 * be applied only if the current mode is &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 * &lt;p&gt;
	 * This method will update both the start and sweep angle of the progress oval. If the arrow feature
	 * is enabled, the arrow position will be also updated.
	 *
	 * @param rotation The desired rotation from the range {@code [0, 360]}.
	 * @see #getRotation()
	 */
	public void setRotation(float rotation) {
<span class="nc bnc" id="L462" title="All 8 branches missed.">		if (mMode == MODE_DETERMINATE &amp;&amp; mProgressState.rotation != rotation &amp;&amp; rotation &gt;= 0 &amp;&amp; rotation &lt;= MAX_ANGLE) {</span>
<span class="nc" id="L463">			final float delta = rotation - mProgressState.rotation;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			if (delta != 0) {</span>
<span class="nc" id="L465">				this.mProgressState.rotation = rotation;</span>
<span class="nc" id="L466">				this.mStartAngle = correctAngle(mStartAngle + delta);</span>
<span class="nc" id="L467">				this.updateArrowPosition();</span>
<span class="nc" id="L468">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L471">	}</span>

	/**
	 * Returns the rotation of the progress oval.
	 *
	 * @return Current progress oval's rotation from the range {@code [0, 360]} or {@code 0} if the
	 * current mode is not &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 * @see #setRotation(float)
	 */
	public float getRotation() {
<span class="nc bnc" id="L481" title="All 2 branches missed.">		return mMode == MODE_DETERMINATE ? mProgressState.rotation : 0;</span>
	}

	/**
	 * Sets a flag indicating whether to draw the arrow of this progress drawable or not.
	 *
	 * @param visible {@code True} to draw the arrow, {@code false} to not draw the arrow.
	 * @see #isArrowVisible()
	 */
	public void setArrowVisible(boolean visible) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ARROW_VISIBLE) != visible) {</span>
<span class="nc" id="L492">			this.updatePrivateFlags(PFLAG_ARROW_VISIBLE, visible);</span>
<span class="nc bnc" id="L493" title="All 4 branches missed.">			if (visible &amp;&amp; (mPrivateFlags &amp; PFLAG_ARROW_ENABLED) == 0) {</span>
<span class="nc" id="L494">				setArrowEnabled(true);</span>
			}
<span class="nc" id="L496">			invalidateSelf();</span>
		}
<span class="nc" id="L498">	}</span>

	/**
	 * Returns a flag indicating whether the arrow of this progress drawable is visible, so it is
	 * drawn, or not.
	 *
	 * @return {@code True} if the arrow is drawn, {@code false} otherwise.
	 * @see #setArrowVisible(boolean)
	 */
	public boolean isArrowVisible() {
<span class="nc bnc" id="L508" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_ARROW_VISIBLE) != 0;</span>
	}

	/**
	 * Sets a flag indicating whether the arrow feature for this progress drawable should be enabled
	 * or not.
	 * &lt;p&gt;
	 * If the arrow feature is enabled, the arrow is drawn at the head of the current progress/indeterminate
	 * oval. The arrow feature is not tied to the current mode. &lt;b&gt;Note&lt;/b&gt;, that if the arrow is
	 * enabled, size (width and height) of this progress drawable will expand by size of the arrow.
	 * &lt;p&gt;
	 * The arrow feature is &lt;b&gt;disabled&lt;/b&gt; by default.
	 *
	 * @param hasArrow {@code True} to enable arrow feature, {@code false} otherwise.
	 * @see #isArrowEnabled()
	 */
	public void setArrowEnabled(boolean hasArrow) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ARROW_ENABLED) != hasArrow) {</span>
<span class="nc" id="L526">			this.updatePrivateFlags(PFLAG_ARROW_ENABLED, hasArrow);</span>
<span class="nc" id="L527">			this.updateOval();</span>
		}
<span class="nc" id="L529">	}</span>

	/**
	 * Returns a flag indicating whether the arrow feature is enabled for this progress drawable or
	 * not.
	 *
	 * @return {@code True} if the arrow feature is enabled, {@code false} otherwise.
	 * @see #setArrowEnabled(boolean)
	 */
	public boolean isArrowEnabled() {
<span class="nc bnc" id="L539" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_ARROW_ENABLED) != 0;</span>
	}

	/**
	 * Sets the scale for the arrow of this progress drawable.
	 * &lt;p&gt;
	 * This can be useful when the arrow need to be progressively shown or hidden.
	 *
	 * @param scale The desired scale from the range {@code [0, 1]}.
	 * @see #getArrowScale()
	 */
	public void setArrowScale(float scale) {
<span class="nc" id="L551">		this.ensureArrowInfo();</span>
<span class="nc bnc" id="L552" title="All 6 branches missed.">		if (mArrowInfo.scale != scale &amp;&amp; scale &gt;= 0 &amp;&amp; scale &lt;= 1) {</span>
<span class="nc" id="L553">			mArrowInfo.scale = scale;</span>
<span class="nc" id="L554">			invalidateSelf();</span>
		}
<span class="nc" id="L556">	}</span>

	/**
	 * Returns the current scale of the arrow.
	 *
	 * @return Arrow's current scale.
	 * @see #setArrowScale(float)
	 */
	public float getArrowScale() {
<span class="nc" id="L565">		this.ensureArrowInfo();</span>
<span class="nc" id="L566">		return mArrowInfo.scale;</span>
	}

	/**
	 * Ensures that the info for arrow is initialized.
	 */
	private void ensureArrowInfo() {
<span class="nc bnc" id="L573" title="All 2 branches missed.">		if (mArrowInfo == null) this.mArrowInfo = new ArrowInfo();</span>
<span class="nc" id="L574">	}</span>

	/**
	 * Sets a flag indicating whether to auto-rotate the progress oval after a change in progress
	 * occurs or not.
	 * &lt;p&gt;
	 * This feature is supported only for &lt;b&gt;DETERMINATE&lt;/b&gt; mode and if enabled the progress oval
	 * will be rotated in such a way that when it is at its max value defined by {@link #setMax(int)},
	 * both the tail and the head of the progress oval will meet at the 12 a clock.
	 * &lt;p&gt;
	 * This feature is &lt;b&gt;enabled&lt;/b&gt; by default.
	 *
	 * @param enabled {@code True} to enable this feature, {@code false} to disable it.
	 * @see #isRotateOnProgressChangeEnabled()
	 */
	public void setRotateOnProgressChangeEnabled(boolean enabled) {
<span class="nc bnc" id="L590" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ROTATE_ON_PROGRESS_CHANGE) != enabled) {</span>
<span class="nc" id="L591">			updatePrivateFlags(PFLAG_ROTATE_ON_PROGRESS_CHANGE, enabled);</span>
<span class="nc" id="L592">			invalidateSelf();</span>
		}
<span class="nc" id="L594">	}</span>

	/**
	 * Returns a flag indicating whether to auto-rotate the progress oval whenever a change in progress
	 * occurs in &lt;b&gt;DETERMINATE&lt;/b&gt; mode.
	 *
	 * @return {@code True} if auto-rotation is enabled, {@code false} otherwise.
	 * @see #setRotateOnProgressChangeEnabled(boolean)
	 */
	public boolean isRotateOnProgressChangeEnabled() {
<span class="nc bnc" id="L604" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_ROTATE_ON_PROGRESS_CHANGE) != 0;</span>
	}

	/**
	 */
	@Override
	protected void onDrawBackground(@NonNull Canvas canvas, @NonNull Paint paint, @Nullable ColorFilter colorFilter) {
<span class="nc" id="L611">		paint.setStyle(Paint.Style.STROKE);</span>
<span class="nc" id="L612">		canvas.drawArc(OVAL, 0, MAX_ANGLE, false, paint);</span>
<span class="nc" id="L613">	}</span>

	/**
	 */
	@Override
	protected void onDraw(@NonNull Canvas canvas, @NonNull Paint paint, @Nullable ColorFilter colorFilter) {
<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (colorFilter == null) {</span>
<span class="nc bnc" id="L620" title="All 3 branches missed.">			switch (mMode) {</span>
				case MODE_DETERMINATE:
<span class="nc bnc" id="L622" title="All 2 branches missed.">					if (mProgressTintFilter != null) {</span>
<span class="nc" id="L623">						paint.setColorFilter(mProgressTintFilter);</span>
					}
					break;
				case MODE_INDETERMINATE:
<span class="nc bnc" id="L627" title="All 2 branches missed.">					if (mIndeterminateTintFilter != null) {</span>
<span class="nc" id="L628">						paint.setColorFilter(mIndeterminateTintFilter);</span>
					}
					break;
			}
		}

<span class="nc bnc" id="L634" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_IN_EDIT_MODE)) {</span>
<span class="nc bnc" id="L635" title="All 3 branches missed.">			switch (mMode) {</span>
				case MODE_DETERMINATE:
<span class="nc" id="L637">					this.mStartAngle = INITIAL_START_ANGLE;</span>
<span class="nc" id="L638">					this.mSweepAngle = 100;</span>
<span class="nc" id="L639">					this.updateArrowPosition();</span>
<span class="nc" id="L640">					break;</span>
				case MODE_INDETERMINATE:
<span class="nc" id="L642">					this.mStartAngle = 210;</span>
<span class="nc" id="L643">					this.mSweepAngle = INDETERMINATE_MAX_SWEEP_ANGLE;</span>
<span class="nc" id="L644">					this.updateArrowPosition();</span>
					break;
			}
		}

<span class="nc" id="L649">		updatePaintToRounded(paint, hasPrivateFlag(PFLAG_ROUNDED));</span>
<span class="nc" id="L650">		paint.setStyle(Paint.Style.STROKE);</span>
<span class="nc" id="L651">		canvas.drawArc(OVAL, mStartAngle, mSweepAngle, false, paint);</span>

		// Draw arrow at the head of the progress if it is visible.
<span class="nc bnc" id="L654" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ARROW_VISIBLE)) {</span>
<span class="nc" id="L655">			updatePaintToRounded(paint, false);</span>
<span class="nc" id="L656">			paint.setStyle(Paint.Style.FILL);</span>
<span class="nc" id="L657">			final int sc = canvas.save();</span>
<span class="nc" id="L658">			canvas.clipPath(mArrowInfo.path);</span>
<span class="nc" id="L659">			canvas.scale(</span>
					mArrowInfo.scale,
					mArrowInfo.scale,
					mArrowInfo.backCenterPoint.x,
					mArrowInfo.backCenterPoint.y
			);
<span class="nc" id="L665">			canvas.drawPath(mArrowInfo.path, paint);</span>
<span class="nc" id="L666">			canvas.restoreToCount(sc);</span>
		}
<span class="nc" id="L668">	}</span>

	/**
	 */
	@Override
	protected void onStart() {
<span class="nc" id="L674">		this.mIndeterminateState = INDETERMINATE_STATE_EXPANDING;</span>
<span class="nc" id="L675">		updateColor();</span>
<span class="nc" id="L676">		scheduleSelf(UPDATE, 0);</span>
<span class="nc" id="L677">		notifyStarted();</span>
<span class="nc" id="L678">	}</span>

	/**
	 */
	@Override
	protected void onStop() {
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (mSweepAngle &gt; 0) updatePrivateFlags(PFLAG_FINISHING_INDETERMINATE, true);</span>
<span class="nc" id="L685">		else onStopImmediate();</span>
<span class="nc" id="L686">	}</span>

	/**
	 */
	@Override
	protected void onStopImmediate() {
<span class="nc" id="L692">		this.clearIndeterminate();</span>
<span class="nc" id="L693">	}</span>

	/**
	 * Clears the current indeterminate data. This will also stops all updates for running indeterminate
	 * animation session and will call {@link #notifyStopped()} to notify that animation has been
	 * stopped.
	 */
	private void clearIndeterminate() {
<span class="nc" id="L701">		unscheduleSelf(UPDATE);</span>
<span class="nc" id="L702">		updatePrivateFlags(PFLAG_FINISHING_INDETERMINATE, false);</span>
<span class="nc" id="L703">		this.mIndeterminateState = INDETERMINATE_STATE_IDLE;</span>
<span class="nc" id="L704">		this.mStartAngle = mUserStartAngle;</span>
<span class="nc" id="L705">		this.mSweepAngle = 0;</span>
<span class="nc" id="L706">		resetCurrentColor();</span>
<span class="nc" id="L707">		notifyStopped();</span>
<span class="nc" id="L708">	}</span>

	/**
	 */
	@Override
	protected boolean onModeChange(int mode) {
<span class="nc bnc" id="L714" title="All 3 branches missed.">		switch (mode) {</span>
			case MODE_DETERMINATE:
<span class="nc" id="L716">				changeColor(mProgressState.color);</span>
<span class="nc" id="L717">				break;</span>
			case MODE_INDETERMINATE:
<span class="nc" id="L719">				resetCurrentColor();</span>
				break;
		}
<span class="nc" id="L722">		return super.onModeChange(mode);</span>
	}

	/**
	 */
	@Override
	protected boolean onProgressChange(int progress) {
<span class="nc" id="L729">		return onUpdate();</span>
	}

	/**
	 */
	@Override
	protected boolean onThicknessChange(float thickness) {
<span class="nc" id="L736">		PAINT.setStrokeWidth(thickness);</span>
<span class="nc" id="L737">		this.updateOval();</span>
<span class="nc" id="L738">		return true;</span>
	}

	/**
	 */
	@Override
	protected boolean onRoundedChange(boolean rounded) {
<span class="nc" id="L745">		return true;</span>
	}

	/**
	 */
	@Override
	protected boolean onExplodedChange(boolean exploded) {
<span class="nc bnc" id="L752" title="All 2 branches missed.">		if (exploded) updateOval();</span>
<span class="nc" id="L753">		return true;</span>
	}

	/**
	 */
	@Override
	protected void onBoundsChange(Rect bounds) {
<span class="nc" id="L760">		super.onBoundsChange(bounds);</span>
<span class="nc" id="L761">		this.mSize = bounds.width();</span>
<span class="nc" id="L762">		this.updateOval();</span>
<span class="nc" id="L763">	}</span>

	/**
	 */
	@Override
	boolean onUpdate() {
<span class="nc" id="L769">		boolean schedule = false;</span>
<span class="nc" id="L770">		final float indeterminateSpeed = mProgressState.indeterminateSpeed;</span>
<span class="nc bnc" id="L771" title="All 3 branches missed.">		switch (mMode) {</span>
			case MODE_DETERMINATE:
<span class="nc" id="L773">				final float sweepAngle = mSweepAngle;</span>
<span class="nc" id="L774">				this.mSweepAngle = mProgress / mMax * MAX_ANGLE;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">				if (hasPrivateFlag(PFLAG_ROTATE_ON_PROGRESS_CHANGE)) {</span>
<span class="nc" id="L776">					this.mStartAngle += mSweepAngle - sweepAngle;</span>
				}
<span class="nc" id="L778">				invalidateSelf();</span>
<span class="nc" id="L779">				break;</span>
			case MODE_INDETERMINATE:
<span class="nc" id="L781">				schedule = true;</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">				if (hasPrivateFlag(PFLAG_FINISHING_INDETERMINATE)) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">					if (mSweepAngle &lt;= 0) {</span>
<span class="nc" id="L784">						this.clearIndeterminate();</span>
					} else {
<span class="nc" id="L786">						final float collapseBy = INDETERMINATE_COLLAPSING_ANGLE_UPDATE * indeterminateSpeed;</span>
<span class="nc" id="L787">						this.mStartAngle += collapseBy;</span>
<span class="nc" id="L788">						this.mSweepAngle -= collapseBy / 2;</span>
					}
<span class="nc" id="L790">					break;</span>
				}

				// Update start angle always with constant value.
<span class="nc" id="L794">				this.mStartAngle = this.correctAngle(mStartAngle + INDETERMINATE_START_ANGLE_UPDATE * indeterminateSpeed);</span>
<span class="nc" id="L795">				this.mIndeterminateFrozenAngleBuffer += INDETERMINATE_START_ANGLE_UPDATE * indeterminateSpeed;</span>

<span class="nc bnc" id="L797" title="All 5 branches missed.">				switch (mIndeterminateState) {</span>
					case INDETERMINATE_STATE_EXPANDING:
<span class="nc" id="L799">						final float expandingInterpolation = (1 + mIndeterminateInterpolator.getInterpolation(mSweepAngle / INDETERMINATE_MAX_SWEEP_ANGLE));</span>
<span class="nc" id="L800">						this.mSweepAngle += INDETERMINATE_EXPANDING_ANGLE_UPDATE * expandingInterpolation * indeterminateSpeed;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">						if (mSweepAngle &gt;= INDETERMINATE_MAX_SWEEP_ANGLE) {</span>
<span class="nc" id="L802">							this.mIndeterminateFrozenAngleBuffer = 0;</span>
<span class="nc" id="L803">							this.mIndeterminateState = INDETERMINATE_STATE_EXPANDING_SLOW_MOTION;</span>
						}
						break;
					case INDETERMINATE_STATE_EXPANDING_SLOW_MOTION:
<span class="nc bnc" id="L807" title="All 2 branches missed.">						if (mIndeterminateFrozenAngleBuffer &gt;= INDETERMINATE_SLOW_MOTION_ANGLE_BUFFER_SIZE) {</span>
<span class="nc" id="L808">							this.mIndeterminateState = INDETERMINATE_STATE_COLLAPSING;</span>
						}
						break;
					case INDETERMINATE_STATE_COLLAPSING:
<span class="nc" id="L812">						final float collapsingInterpolation = (1 + mIndeterminateInterpolator.getInterpolation(mSweepAngle / INDETERMINATE_MAX_SWEEP_ANGLE));</span>
<span class="nc" id="L813">						final float collapseBy = INDETERMINATE_COLLAPSING_ANGLE_UPDATE * collapsingInterpolation * indeterminateSpeed;</span>
<span class="nc" id="L814">						this.mStartAngle += collapseBy;</span>
<span class="nc" id="L815">						this.mSweepAngle -= collapseBy;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">						if (mSweepAngle &lt;= 0) {</span>
<span class="nc" id="L817">							this.mSweepAngle = 1;</span>
<span class="nc" id="L818">							this.mIndeterminateFrozenAngleBuffer = 0;</span>
<span class="nc" id="L819">							this.mIndeterminateState = INDETERMINATE_STATE_COLLAPSING_SLOW_MOTION;</span>
<span class="nc" id="L820">							changeNextColor();</span>
						}
						break;
					case INDETERMINATE_STATE_COLLAPSING_SLOW_MOTION:
<span class="nc bnc" id="L824" title="All 2 branches missed.">						if (mIndeterminateFrozenAngleBuffer &gt;= INDETERMINATE_SLOW_MOTION_ANGLE_BUFFER_SIZE) {</span>
<span class="nc" id="L825">							this.mIndeterminateState = INDETERMINATE_STATE_EXPANDING;</span>
						}
						break;
					case INDETERMINATE_STATE_IDLE:
					default:
<span class="nc" id="L830">						schedule = false;</span>
				}
				break;
		}
<span class="nc bnc" id="L834" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_ARROW_ENABLED) != 0) {</span>
<span class="nc" id="L835">			this.updateArrowPosition();</span>
		}
<span class="nc" id="L837">		return schedule;</span>
	}

	/**
	 */
	@Override
	void updateStateFromTypedArray(TypedArray typedArray) {
<span class="nc" id="L844">		super.updateStateFromTypedArray(typedArray);</span>
		// Cannot be properly implemented.
<span class="nc" id="L846">	}</span>

	/**
	 */
	@Override
	void ensureConstantState(ProgressState state) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">		if (mProgressState == null) {</span>
<span class="nc" id="L853">			changeConstantState(mProgressState = new CircularState());</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">		} else if (state instanceof CircularState) {</span>
<span class="nc" id="L855">			changeConstantState(mProgressState = new CircularState((CircularState) state));</span>
		}
<span class="nc" id="L857">	}</span>

	/**
	 * Updates the progress/indeterminate oval depends on the enabled features for this progress
	 * drawable and the current bounds and thickness of this drawable.
	 */
	private void updateOval() {
<span class="nc" id="L864">		final boolean hasArrow = hasPrivateFlag(PFLAG_ARROW_ENABLED);</span>
<span class="nc" id="L865">		float arrowWide = 0;</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">		if (hasArrow) {</span>
<span class="nc" id="L867">			this.ensureArrowInfo();</span>
<span class="nc" id="L868">			mArrowInfo.wide = mProgressState.useThickness * 4;</span>
<span class="nc" id="L869">			arrowWide = mArrowInfo.wide / 2;</span>
		}

<span class="nc" id="L872">		final float useThickness = mProgressState.useThickness / 2;</span>
<span class="nc" id="L873">		final float thicknessDelta = (mProgressState.rawThickness - mProgressState.useThickness) / 2;</span>
<span class="nc" id="L874">		final float ovalCorrection = useThickness + thicknessDelta + arrowWide;</span>
<span class="nc" id="L875">		OVAL.set(</span>
				mBounds.left + ovalCorrection,
				mBounds.top + ovalCorrection,
				mBounds.left + mSize - ovalCorrection,
				mBounds.top + mSize - ovalCorrection
		);

<span class="nc bnc" id="L882" title="All 2 branches missed.">		if (hasArrow) {</span>
<span class="nc" id="L883">			this.updateArrowPosition();</span>
		}
<span class="nc" id="L885">	}</span>

	/**
	 * Updates the current position of the arrow drawn at the head of the progress/indeterminate oval
	 * according to the current start + sweep angle.
	 */
	private void updateArrowPosition() {
<span class="nc" id="L892">		this.ensureArrowInfo();</span>

		/**
		 * Compute the path points of the arrow's triangle.
		 */
<span class="nc" id="L897">		final float center = OVAL.centerX();</span>
<span class="nc" id="L898">		final float radius = OVAL.width() / 2;</span>
<span class="nc" id="L899">		final float circumference = (float) (Math.PI * 2 * radius);</span>

		// Compute the one PX per ANGLE to move the arrow's head forward so the arrow will be drawn
		// after the head of the current progress.
<span class="nc" id="L903">		final float ppd = circumference / MAX_ANGLE;</span>

		// Compute rotation of the arrow based on the start angle + current sweep angle of the current progress.
		// Take into count also height of the arrow to move it after the head of the current progress.
<span class="nc" id="L907">		final float arrowWide = mArrowInfo.wide;</span>
<span class="nc" id="L908">		final float progressAngle = mStartAngle + mSweepAngle - 1;</span>
<span class="nc" id="L909">		final float heightAngles = (arrowWide / 2 / ppd);</span>

<span class="nc" id="L911">		double rotationRadii = Math.toRadians(correctAngle(progressAngle + heightAngles));</span>
<span class="nc" id="L912">		final PointF headPoint = new PointF(</span>
<span class="nc" id="L913">				Math.round(center + (radius + mProgressState.useThickness / 2) * Math.cos(rotationRadii)),</span>
<span class="nc" id="L914">				Math.round(center + (radius + mProgressState.useThickness / 2) * Math.sin(rotationRadii))</span>
		);
<span class="nc" id="L916">		mArrowInfo.headPoint = headPoint;</span>

<span class="nc" id="L918">		final float arrowHalfWide = arrowWide / 2;</span>
<span class="nc" id="L919">		rotationRadii = Math.toRadians(correctAngle(progressAngle));</span>
<span class="nc" id="L920">		final PointF backRgtPoint = new PointF(</span>
<span class="nc" id="L921">				Math.round(center + (radius - arrowHalfWide) * Math.cos(rotationRadii)),</span>
<span class="nc" id="L922">				Math.round(center + (radius - arrowHalfWide) * Math.sin(rotationRadii))</span>
		);
<span class="nc" id="L924">		mArrowInfo.backCenterPoint = new PointF(</span>
<span class="nc" id="L925">				Math.round(center + radius * Math.cos(rotationRadii)),</span>
<span class="nc" id="L926">				Math.round(center + radius * Math.sin(rotationRadii))</span>
		);
<span class="nc" id="L928">		final PointF backLftPoint = new PointF(</span>
<span class="nc" id="L929">				Math.round(center + (radius + arrowHalfWide) * Math.cos(rotationRadii)),</span>
<span class="nc" id="L930">				Math.round(center + (radius + arrowHalfWide) * Math.sin(rotationRadii))</span>
		);

		/**
		 * Update the path of the arrow.
		 */
<span class="nc" id="L936">		final Path path = mArrowInfo.path;</span>
<span class="nc" id="L937">		path.reset();</span>
<span class="nc" id="L938">		path.moveTo(headPoint.x, headPoint.y);</span>
<span class="nc" id="L939">		path.lineTo(backLftPoint.x, backLftPoint.y);</span>
<span class="nc" id="L940">		path.lineTo(backRgtPoint.x, backRgtPoint.y);</span>
<span class="nc" id="L941">		path.close();</span>
<span class="nc" id="L942">	}</span>

	/**
	 * Corrects the specified angle, so it will be from the range {@code [0, 360]}.
	 *
	 * @param angle The angle to correct.
	 * @return Corrected angle.
	 */
	private float correctAngle(float angle) {
<span class="nc bnc" id="L951" title="All 2 branches missed.">		return angle &lt;= MAX_ANGLE ? angle : angle - MAX_ANGLE;</span>
	}

	/**
	 * Performs base initialization of this drawable.
	 */
	private void init() {
<span class="nc" id="L958">		this.mMode = MODE_INDETERMINATE;</span>
<span class="nc" id="L959">		setRounded(true);</span>
<span class="nc" id="L960">		setRotateOnProgressChangeEnabled(true);</span>
<span class="nc" id="L961">		setThickness(15);</span>
<span class="nc" id="L962">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Constant state implementation for this drawable class.
	 */
	static final class CircularState extends ProgressState {

		/**
		 * Radius for the progress/indeterminate oval.
		 */
<span class="nc" id="L976">		int radius = -1;</span>

		/**
		 * Current rotation of the progress/indeterminate oval.
		 */
		float rotation;

		/**
		 * Creates a new instance of empty CircularState.
		 */
<span class="nc" id="L986">		CircularState() {</span>
<span class="nc" id="L987">		}</span>

		/**
		 * Creates a new instance of CircularState with parameters copied from the specified
		 * &lt;var&gt;state&lt;/var&gt;.
		 *
		 * @param state The state from which to create the new one.
		 */
		CircularState(CircularState state) {
<span class="nc" id="L996">			super(state);</span>
<span class="nc" id="L997">			this.radius = state.radius;</span>
<span class="nc" id="L998">			this.rotation = state.rotation;</span>
<span class="nc" id="L999">		}</span>

		/**
		 */
		@NonNull
		@Override
		public Drawable newDrawable() {
<span class="nc" id="L1006">			return new CircularProgressDrawable(this, null, null);</span>
		}

		/**
		 */
		@NonNull
		@Override
		public Drawable newDrawable(Resources res) {
<span class="nc" id="L1014">			return new CircularProgressDrawable(this, res, null);</span>
		}

		/**
		 */
		@NonNull
		@Override
		public Drawable newDrawable(Resources res, Resources.Theme theme) {
<span class="nc" id="L1022">			return new CircularProgressDrawable(this, res, theme);</span>
		}
	}

	/**
	 * Creates a new instance of CircularProgressDrawable from the specified &lt;var&gt;state&lt;/var&gt;.
	 *
	 * @param state The state from which to create the new progress drawable instance.
	 * @param res   An application resources.
	 * @param theme A theme to be applied to the new progress drawable instance.
	 */
<span class="nc" id="L1033">	private CircularProgressDrawable(CircularState state, Resources res, Resources.Theme theme) {</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">		if (theme != null &amp;&amp; state.canApplyTheme()) {</span>
<span class="nc" id="L1035">			changeConstantState(mProgressState = new CircularState(state));</span>
<span class="nc" id="L1036">			applyTheme(theme);</span>
		} else {
<span class="nc" id="L1038">			changeConstantState(mProgressState = state);</span>
		}
<span class="nc" id="L1040">		this.mBackgroundTintFilter = TintDrawable.createTintFilter(this, state.backgroundTint, state.backgroundTintMode);</span>
<span class="nc" id="L1041">		this.mProgressTintFilter = TintDrawable.createTintFilter(this, state.progressTint, state.progressTintMode);</span>
<span class="nc" id="L1042">		this.mIndeterminateTintFilter = TintDrawable.createTintFilter(this, state.indeterminateTint, state.indeterminateTintMode);</span>
<span class="nc" id="L1043">	}</span>

	/**
	 * This class holds all data about the arrow.
	 */
<span class="nc" id="L1048">	private static final class ArrowInfo {</span>

		/**
		 * Wide of the arrow. This determines size of the arrow's triangle base.
		 */
		float wide;

		/**
		 * Path determining the arrow.
		 */
<span class="nc" id="L1058">		Path path = new Path();</span>

		/**
		 * Heading point of the arrow's {@link #path}.
		 */
		PointF headPoint;

		/**
		 * Back centered point of the arrow's {@link #path}.
		 */
		PointF backCenterPoint;

		/**
		 * Current scale of the arrow.
		 */
<span class="nc" id="L1073">		float scale = 1;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>