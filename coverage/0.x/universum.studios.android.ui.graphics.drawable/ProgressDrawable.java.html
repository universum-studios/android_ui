<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ProgressDrawable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.graphics.drawable</a> &gt; <span class="el_source">ProgressDrawable.java</span></div><h1>ProgressDrawable.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.graphics.drawable;

import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.CornerPathEffect;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffColorFilter;
import android.graphics.Rect;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.SystemClock;
import android.support.annotation.ColorInt;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Interpolator;

import java.util.Arrays;

import universum.studios.android.ui.UiConfig;

/**
 * This Drawable class represents base implementation for drawables that can draw a progress or an
 * indeterminate graphics. &lt;b&gt;Note&lt;/b&gt;, that this drawable class does not draw any progress or
 * indeterminate graphics, such a logic depends on the concrete implementation of the ProgressDrawable
 * like {@link CircularProgressDrawable} or {@link LinearProgressDrawable}.
 * &lt;p&gt;
 * The ProgressDrawable implements base API to support setting of progress value by {@link #setProgress(int)},
 * supplying color for progress/indeterminate graphics by {@link #setColor(int)} or {@link #setColors(int[])}
 * for &lt;b&gt;multicolored&lt;/b&gt; graphics feature which can be enabled {@link #setMultiColored(boolean)}.
 * &lt;p&gt;
 * All features related to appearance of the ProgressDrawable like changing its alpha value by {@link #setAlpha(int)}
 * or tinting of its graphics by {@link #setTintList(android.content.res.ColorStateList)} and
 * {@link #setTintMode(android.graphics.PorterDuff.Mode)} are supported.
 *
 * &lt;h3&gt;Animating&lt;/h3&gt;
 * The ProgressDrawable also provides base implementation to support running of animations within
 * an implementation of this class. For purpose of this documentation, a time interval between call
 * of {@link #start()} and call of {@link #stop()} is called &lt;b&gt;animation session&lt;/b&gt; or
 * &lt;b&gt;indeterminate animation session&lt;/b&gt; in case of &lt;b&gt;indeterminate&lt;/b&gt; mode.
 *
 * &lt;h3&gt;Tinting&lt;/h3&gt;
 * This drawable provides extended tinting API via following setters:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #setProgressTintList(android.content.res.ColorStateList)}&lt;/li&gt;
 * &lt;li&gt;{@link #setProgressTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
 * &lt;li&gt;{@link #setIndeterminateTintList(android.content.res.ColorStateList)}&lt;/li&gt;
 * &lt;li&gt;{@link #setIndeterminateTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
 * &lt;li&gt;{@link #setBackgroundTintList(android.content.res.ColorStateList)}&lt;/li&gt;
 * &lt;li&gt;{@link #setBackgroundTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Callbacks&lt;/h3&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * {@link ProgressDrawable.AnimationCallback}
 * &lt;p&gt;
 * This callback can be used to receive callback about &lt;b&gt;started&lt;/b&gt; and &lt;b&gt;stopped&lt;/b&gt; animation
 * for the ProgressDrawable to which is this callback attached.
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@link ProgressDrawable.ExplodeAnimationCallback}
 * &lt;p&gt;
 * This callback can be used to receive callback about &lt;b&gt;exploded&lt;/b&gt; or &lt;b&gt;imploded&lt;/b&gt; thickness
 * of the ProgressDrawable to which is this callback attached.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Martin Albedinsky
 */
public abstract class ProgressDrawable extends Drawable implements Animatable {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Listener which can receive callbacks about &lt;b&gt;started&lt;/b&gt; or &lt;b&gt;stopped&lt;/b&gt; animation session
	 * of progress drawable.
	 */
	public interface AnimationCallback {

		/**
		 * Invoked whenever a new animation session is started for the specified progress &lt;var&gt;drawable&lt;/var&gt;.
		 *
		 * @param drawable The progress drawable for which has been requested new animation session
		 *                 by {@link #start()} and the drawable has been before that call in the
		 *                 idle mode.
		 */
		void onStarted(@NonNull ProgressDrawable drawable);

		/**
		 * Invoked whenever the current animation sessions is stopped for the specified progress
		 * &lt;var&gt;drawable&lt;/var&gt;.
		 *
		 * @param drawable The progress drawable for which has been stopped its current animation
		 *                 sessions by {@link #stop()} or {@link #stopImmediate()} and the drawable
		 *                 has been before that call in the animation mode.
		 */
		void onStopped(@NonNull ProgressDrawable drawable);
	}

	/**
	 * Listener which can receive callbacks about &lt;b&gt;exploded&lt;/b&gt; and &lt;b&gt;imploded&lt;/b&gt; thickness of
	 * progress drawable.
	 */
	public interface ExplodeAnimationCallback {

		/**
		 * Invoked whenever an explosion of the specified progress &lt;var&gt;drawable&lt;/var&gt; is finished.
		 *
		 * @param drawable The progress drawable for which has been explosion of its thickness
		 *                 finished after {@link #explode()} has been called upon the drawable.
		 */
		void onExploded(@NonNull ProgressDrawable drawable);

		/**
		 * Invoked whenever an implosion of the specified progress &lt;var&gt;drawable&lt;/var&gt; is finished.
		 *
		 * @param drawable The progress drawable for which has been implosion of its thickness
		 *                 finished after {@link #implode()} has been called upon the drawable.
		 */
		void onImploded(@NonNull ProgressDrawable drawable);
	}

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;BaseProgressDrawable&quot;;

	/**
	 * Base flag for DETERMINATE mode.
	 * &lt;p&gt;
	 * This flag is only for internal purpose, use mode flags specified by implementations of this
	 * progress drawable instead for convenience.
	 */
	public static final int DETERMINATE = 0x01;

	/**
	 * Base flag for INDETERMINATE mode. In this mode a value of progress is not accepted by progress
	 * drawable and call to {@link #setProgress(int)} is ignored.
	 * &lt;p&gt;
	 * This flag is only for internal purpose, use mode flags specified by implementations of this
	 * progress drawable instead for convenience.
	 */
	public static final int INDETERMINATE = 0x02;

	/**
	 * Default maximum value of the progress which can be set to progress drawable.
	 */
	public static final int MAX_PROGRESS = 100;

	/**
	 * Maximum level value that can be set to this progress bar instead progress value.
	 */
<span class="nc" id="L186">	private static int MAX_LEVEL = 10000;</span>

	/**
	 * Boolean flag indicating whether an instance of {@link ProgressDrawable} requires the software
	 * layer to be used by a view that is hosting such progress drawable so its drawing will work
	 * properly.
	 * &lt;p&gt;
	 * Software layer for the view can be requested via {@link android.view.View#setLayerType(int, android.graphics.Paint)}.
	 */
<span class="nc bnc" id="L195" title="All 4 branches missed.">	public static final boolean REQUIRES_SOFTWARE_LAYER = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN;</span>

	/**
	 * Update interval for animations running by this drawable in milliseconds.
	 * &lt;p&gt;
	 * Value: &lt;b&gt;60 fps&lt;/b&gt;
	 */
	static final long FRAME_UPDATE_INTERVAL = UiConfig.ANIMATION_FRAME_UPDATE_INTERVAL;

	/**
	 * Alpha value of the default background color.
	 */
	static final int BACKGROUND_COLOR_ALPHA = 54;

	/**
	 * Default color for progress drawable's graphics.
	 */
<span class="nc" id="L212">	static final int DEFAULT_COLOR = Color.parseColor(&quot;#03a9f4&quot;);</span>

	/**
	 * Flag indicating whether this drawable is mutated or not. That's it, if it shares its current
	 * state or not.
	 */
	static final int PFLAG_MUTATED = 0x00000001;

	/**
	 * Flag indicating whether this drawable's progress can be multi colored. That's it, can be drawn
	 * with multiple colors (but one at the time) when in {@link #INDETERMINATE} mode.
	 */
	static final int PFLAG_MULTI_COLORED = 0x00000002;

	/**
	 * Flag indicating whether this drawable is running some animation or not.
	 */
	static final int PFLAG_RUNNING = 0x00000004;

	/**
	 * Flag indicating whether this drawable is expanded (visible in thickness) or not.
	 */
	static final int PFLAG_EXPLODED = 0x00000008;

	/**
	 * Flag indicating whether the progress of this drawable should be rounded or not.
	 */
	static final int PFLAG_ROUNDED = 0x00000010;

	/**
	 * Flag indicating whether the indeterminate is being finished or not.
	 */
	static final int PFLAG_FINISHING_INDETERMINATE = 0x00000020;

	/**
	 * Flag indicating whether the graphics of this drawable should be drawn in edit mode or not.
	 *
	 * @see View#isInEditMode()
	 */
	static final int PFLAG_IN_EDIT_MODE = 0x00000040;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Task to update current data of this drawable. This task should be used primary for update of
	 * indeterminate data.
	 */
<span class="nc" id="L265">	final Runnable UPDATE = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc bnc" id="L271" title="All 2 branches missed.">			if (onUpdate()) {</span>
<span class="nc" id="L272">				invalidateSelf();</span>
<span class="nc" id="L273">				scheduleSelf(this, computeFramesScheduleTime());</span>
			}
<span class="nc" id="L275">		}</span>
	};

	/**
	 * Task used to explode thickness of this progress drawable after {@link #explode()} has been
	 * called.
	 */
<span class="nc" id="L282">	private final Runnable EXPLODE_THICKNESS = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if (mProgressState.useThickness &lt; mProgressState.rawThickness) {</span>
<span class="nc" id="L289">				final float update = computeExplodeImplodeUpdate();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">				if (onThicknessChange(mProgressState.useThickness += update)) {</span>
<span class="nc" id="L291">					invalidateSelf();</span>
				}
<span class="nc" id="L293">				scheduleSelf(this, computeFramesScheduleTime());</span>
<span class="nc" id="L294">			} else {</span>
<span class="nc" id="L295">				onExploded(true);</span>
			}
<span class="nc" id="L297">		}</span>
	};

	/**
	 * Task used to implode thickness of this progress drawable after {@link #implode()} has been
	 * called.
	 */
<span class="nc" id="L304">	private final Runnable IMPLODE_THICKNESS = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc bnc" id="L310" title="All 2 branches missed.">			if (mProgressState.useThickness &gt; 0) {</span>
<span class="nc" id="L311">				final float update = computeExplodeImplodeUpdate();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">				if (onThicknessChange(mProgressState.useThickness -= update)) {</span>
<span class="nc" id="L313">					invalidateSelf();</span>
				}
<span class="nc" id="L315">				scheduleSelf(this, computeFramesScheduleTime());</span>
<span class="nc" id="L316">			} else {</span>
<span class="nc" id="L317">				onExploded(false);</span>
			}
<span class="nc" id="L319">		}</span>
	};

	/**
	 * Paint used to draw graphics (background if any, progress, ...) of this drawable.
	 */
<span class="nc" id="L325">	final Paint PAINT = new Paint(Paint.ANTI_ALIAS_FLAG);</span>

	/**
	 * Current maximum for progress which can be set to this progress drawable.
	 */
<span class="nc" id="L330">	float mMax = MAX_PROGRESS;</span>

	/**
	 * Current progress drawn by this drawable if it is in {@link #DETERMINATE}.
	 */
	int mProgress;

	/**
	 * Tint filter used to tint background graphics of this drawable.
	 */
	PorterDuffColorFilter mBackgroundTintFilter;

	/**
	 * Tint filter used to tint progress graphics of this drawable.
	 */
	PorterDuffColorFilter mProgressTintFilter;

	/**
	 * Tint filter used to tint indeterminate graphics of this drawable.
	 */
	PorterDuffColorFilter mIndeterminateTintFilter;

	/**
	 * Current mode of this drawable. This mode determines behaviour of this drawable and also how
	 * how should by this drawable drawn.
	 */
<span class="nc" id="L356">	int mMode = DETERMINATE;</span>

	/**
	 * Bounds set to this drawable by {@link #setBounds(int, int, int, int)} or {@link #setBounds(android.graphics.Rect)}.
	 */
<span class="nc" id="L361">	Rect mBounds = new Rect();</span>

	/**
	 * Interpolator used to interpolate computed update values for indeterminate mode.
	 */
<span class="nc" id="L366">	Interpolator mIndeterminateInterpolator = new AccelerateDecelerateInterpolator();</span>

	/**
	 * Index of the color used to draw this drawbale's progress when it is in the {@link #INDETERMINATE}.
	 * mode. This index is used when this drawable is set to behave like multi colored drawable
	 * ({@link #PFLAG_MULTI_COLORED}), so it uses set of specified colors (set by {@link #setColors(int[])},
	 * to draw its current progress.
	 * &lt;p&gt;
	 * How the colors set is used really depends on the implementation, but basic logic is to use
	 * next color from the set for the &quot;next&quot; indeterminate block of this drawable.
	 */
	private int mCurrentColorIndex;

	/**
	 * Set of private flags of this progress drawable.
	 */
<span class="nc" id="L382">	int mPrivateFlags = PFLAG_EXPLODED;</span>

	/**
	 * Duration used for the thickness explode/implode animation.
	 */
<span class="nc" id="L387">	private long mExplodeDuration = 300;</span>

	/**
	 * Current state of this drawable. Updating and managing of this state (its values) relies on
	 * the specific implementation of this drawable.
	 */
	private ProgressState mProgressState;

	/**
	 * Listener to receive callbacks about started and stopped animation session of this progress
	 * drawable.
	 */
	private AnimationCallback mAnimationCallback;

	/**
	 * Listener to receive callbacks about exploded and imploded thickness of this progress drawable.
	 */
	private ExplodeAnimationCallback mExplodeAnimationCallback;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of ProgressDrawable.
	 */
<span class="nc" id="L413">	protected ProgressDrawable() {</span>
<span class="nc" id="L414">		ensureConstantState(null);</span>
<span class="nc" id="L415">	}</span>

	/**
	 * Creates a new instance of ProgressDrawable with the specified &lt;var&gt;color&lt;/var&gt;.
	 *
	 * @param color The color used to draw progress or indeterminate graphics of the new drawable.
	 */
<span class="nc" id="L422">	protected ProgressDrawable(int color) {</span>
<span class="nc" id="L423">		ensureConstantState(null);</span>
<span class="nc" id="L424">		setColor(color);</span>
<span class="nc" id="L425">	}</span>

	/**
	 * Creates a new instance of ProgressDrawable with the specified set of &lt;var&gt;colors&lt;/var&gt;.
	 *
	 * @param colors The set of colors used to draw indeterminate graphics of the new drawable when
	 *               in &lt;b&gt;INDETERMINATE&lt;/b&gt; mode.
	 */
<span class="nc" id="L433">	protected ProgressDrawable(int[] colors) {</span>
<span class="nc" id="L434">		ensureConstantState(null);</span>
<span class="nc" id="L435">		setColors(colors);</span>
<span class="nc" id="L436">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Ensures that the constant state of this progress drawable is initialized.
	 *
	 * @param state A current state which should be used to initialize new one.
	 */
	abstract void ensureConstantState(ProgressState state);

	/**
	 * Sets a boolean flag determining whether this drawable should draw its graphics in edit (preview)
	 * mode or not.
	 *
	 * @param inEditMode {@code True} to draw graphics in edit mode, {@code false} otherwise.
	 * @see #isInEditMode()
	 * @see View#isInEditMode()
	 */
	public final void setInEditMode(boolean inEditMode) {
<span class="nc bnc" id="L458" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_IN_EDIT_MODE) != inEditMode) {</span>
<span class="nc" id="L459">			this.updatePrivateFlags(PFLAG_IN_EDIT_MODE, inEditMode);</span>
<span class="nc" id="L460">			invalidateSelf();</span>
		}
<span class="nc" id="L462">	}</span>

	/**
	 * Returns flag indicating whether this drawable draws its graphics in edit mode or not.
	 *
	 * @return {@code True} if graphics is drawn in edit (preview) mode, {@code false} otherwise.
	 */
	public final boolean isInEditMode() {
<span class="nc" id="L470">		return hasPrivateFlag(PFLAG_IN_EDIT_MODE);</span>
	}

	/**
	 */
	@Override
	public void draw(Canvas canvas) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">		if (mProgressState.useThickness &gt; 0) {</span>
<span class="nc" id="L478">			final ColorFilter colorFilter = PAINT.getColorFilter();</span>
<span class="nc bnc" id="L479" title="All 8 branches missed.">			if ((mProgressState.drawColor &gt;&gt;&gt; 24) != 0 || colorFilter != null || mProgressTintFilter != null || mIndeterminateTintFilter != null) {</span>
				// Draw background whenever we have none-transparent color for it.
<span class="nc bnc" id="L481" title="All 4 branches missed.">				if ((mProgressState.backgroundDrawColor &gt;&gt;&gt; 24) != 0 || mBackgroundTintFilter != null) {</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">					if (colorFilter == null &amp;&amp; mBackgroundTintFilter != null) {</span>
<span class="nc" id="L483">						PAINT.setColorFilter(mBackgroundTintFilter);</span>
					}

<span class="nc" id="L486">					PAINT.setColor(mProgressState.backgroundDrawColor);</span>
<span class="nc" id="L487">					onDrawBackground(canvas, PAINT, colorFilter);</span>
					// Restore paint's original color filter.
<span class="nc" id="L489">					PAINT.setColorFilter(colorFilter);</span>
				}

<span class="nc" id="L492">				PAINT.setColor(mProgressState.drawColor);</span>
<span class="nc" id="L493">				onDraw(canvas, PAINT, colorFilter);</span>
				// Restore paint's original color filter.
<span class="nc" id="L495">				PAINT.setColorFilter(colorFilter);</span>
			}
		}
<span class="nc" id="L498">	}</span>

	/**
	 * Invoked whenever {@link #draw(android.graphics.Canvas)} is called for this progress drawable
	 * and there is background color set and its alpha value is not {@code 0}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that any color filter set to the given &lt;var&gt;paint&lt;/var&gt; will be clear after this
	 * call.
	 *
	 * @param canvas      Canvas on which to draw background graphics.
	 * @param paint       A paint that can be used for drawing operations. This paint has already
	 *                    tint filter specified, based on {@link #setBackgroundTintList(android.content.res.ColorStateList)}
	 *                    and {@link #setBackgroundTintMode(android.graphics.PorterDuff.Mode)} parameters.
	 * @param colorFilter Color filter obtained from the specified paint.
	 */
	protected void onDrawBackground(@NonNull Canvas canvas, @NonNull Paint paint, @Nullable ColorFilter colorFilter) {
<span class="nc" id="L514">	}</span>

	/**
	 * Invoked whenever {@link #draw(android.graphics.Canvas)} is called for this progress drawable
	 * and the current alpha value of the current color is not {@code 0}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that any color filter set to the given &lt;var&gt;paint&lt;/var&gt; will be clear after this
	 * call.
	 *
	 * @param canvas      Canvas on which to draw progress or indeterminate graphics.
	 * @param paint       A paint that can be used for drawing operations.
	 * @param colorFilter Color filter obtained from the specified paint.
	 */
	protected abstract void onDraw(@NonNull Canvas canvas, @NonNull Paint paint, @Nullable ColorFilter colorFilter);

	/**
	 * Starts a new animation session of this progress drawable. The new session is started only if
	 * this drawable does not have animation session running at this time and its current mode is not
	 * &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 * &lt;p&gt;
	 * Do not forget to stop the animation session by {@link #stop()} or {@link #stopImmediate()}
	 * whenever this drawable is no longer visible or drawn.
	 */
	@Override
	public void start() {
<span class="nc bnc" id="L539" title="All 4 branches missed.">		if (mMode != DETERMINATE &amp;&amp; (mPrivateFlags &amp; PFLAG_RUNNING) == 0) onStart();</span>
<span class="nc" id="L540">	}</span>

	/**
	 * Stops the current animation session of this progress drawable. The sessions is stopped only
	 * if this drawable does have animation session running at this time and its current mode is not
	 * &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 */
	public void stopImmediate() {
<span class="nc bnc" id="L548" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_RUNNING) != 0) onStopImmediate();</span>
<span class="nc" id="L549">	}</span>

	/**
	 * Like {@link #stopImmediate()}, but this will stop the current animation session after drawing
	 * of the currently visible indeterminate graphics is finished, so it will not look like the
	 * current graphics just &quot;vanished&quot;.
	 */
	@Override
	public void stop() {
<span class="nc bnc" id="L558" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_RUNNING) != 0) onStop();</span>
<span class="nc" id="L559">	}</span>

	/**
	 * Returns a flag indicating whether this drawable does have animation sessions currently running
	 * or not.
	 *
	 * @return {@code True} if animation session is running, {@code false} otherwise.
	 */
	@Override
	public boolean isRunning() {
<span class="nc bnc" id="L569" title="All 4 branches missed.">		return mMode != DETERMINATE &amp;&amp; (mPrivateFlags &amp; PFLAG_RUNNING) != 0;</span>
	}

	/**
	 * Animates thickness of this progress drawable from {@code 0} to value specified by {@link #setThickness(float)}.
	 * &lt;p&gt;
	 * Does nothing if thickness of this drawable is already exploded.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that this will not affect in any way currently running animation session started
	 * by {@link #start()}.
	 *
	 * @see #implode()
	 * @see #isExploded()
	 */
	public void explode() {
<span class="nc bnc" id="L584" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_EXPLODED) == 0) onExplode();</span>
<span class="nc" id="L585">	}</span>

	/**
	 * Animates thickness of this progress drawable from value specified by {@link #setThickness(float)}
	 * to {@code 0}.
	 * &lt;p&gt;
	 * Does nothing if thickness of this drawable is already imploded.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that this will not affect in any way currently running animation session started
	 * by {@link #start()}.
	 *
	 * @see #explode()
	 * @see #isExploded()
	 */
	public void implode() {
<span class="nc bnc" id="L600" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_EXPLODED) != 0) onImplode();</span>
<span class="nc" id="L601">	}</span>

	/**
	 * Sets a flag indicating whether thickness of this progress drawable is exploded or imploded.
	 * This will also update thickness of this drawable.
	 *
	 * @param exploded {@code True} to set thickness to value specified by {@link #setThickness(float)}
	 *                 {@code false} to {@code 0} so this drawable will be invisible.
	 * @see #isExploded()
	 */
	public void setExploded(boolean exploded) {
<span class="nc bnc" id="L612" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_EXPLODED) != exploded) {</span>
<span class="nc" id="L613">			this.updatePrivateFlags(PFLAG_EXPLODED, exploded);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">			if (exploded) {</span>
<span class="nc" id="L615">				mProgressState.useThickness = mProgressState.rawThickness;</span>
			} else {
<span class="nc" id="L617">				mProgressState.useThickness = 0;</span>
			}
<span class="nc bnc" id="L619" title="All 2 branches missed.">			if (onExplodedChange(exploded)) {</span>
<span class="nc" id="L620">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L623">	}</span>

	/**
	 * Returns a flag indicating whether thickness of this progress drawable is exploded or imploded.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that if progress drawable is imploded, it means its current thickness is at {@code 0},
	 * so it is not being drawn.
	 *
	 * @return {@code True} if thickness is value specified by {@link #setThickness(float)},
	 * {@code false}  otherwise.
	 */
	public boolean isExploded() {
<span class="nc bnc" id="L635" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_EXPLODED) != 0;</span>
	}

	/**
	 * Sets the duration for explode/implode animation of this progress drawable.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see #getExplodeDuration()
	 * @see #explode()
	 * @see #implode()
	 */
	public void setExplodeDuration(long duration) {
<span class="nc" id="L647">		this.mExplodeDuration = duration;</span>
<span class="nc" id="L648">	}</span>

	/**
	 * Returns the duration used for explode/implode animation.
	 *
	 * @return Animation duration in milliseconds.
	 * @see #setExplodeDuration(long)
	 * @see #explode()
	 * @see #implode()
	 */
	public long getExplodeDuration() {
<span class="nc" id="L659">		return mExplodeDuration;</span>
	}

	/**
	 */
	@Override
	public Drawable mutate() {
<span class="nc bnc" id="L666" title="All 4 branches missed.">		if ((mPrivateFlags &amp; PFLAG_MUTATED) == 0 &amp;&amp; super.mutate() == this) {</span>
<span class="nc" id="L667">			ensureConstantState(mProgressState);</span>
<span class="nc" id="L668">			updatePrivateFlags(PFLAG_MUTATED, true);</span>
		}
<span class="nc" id="L670">		return this;</span>
	}

	/**
	 */
	@Override
	public void applyTheme(@NonNull Resources.Theme theme) {
<span class="nc" id="L677">	}</span>

	/**
	 */
	@Override
	public boolean canApplyTheme() {
<span class="nc" id="L683">		return false;</span>
	}

	/**
	 * Sets the maximum value of progress which can be set to this progress drawable by {@link #setProgress(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;100&lt;/b&gt;
	 *
	 * @param max The desired progress maximum.
	 * @see #getMax()
	 */
	public void setMax(int max) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">		if (mMax != max) {</span>
<span class="nc" id="L696">			this.mMax = Math.max(0, max);</span>
<span class="nc" id="L697">			onProgressChange(mProgress);</span>
		}
<span class="nc" id="L699">	}</span>

	/**
	 * Sets the current maximum of this progress drawable.
	 *
	 * @return The maximum value of progress which can be set by {@link #setProgress(int)}.
	 */
	public int getMax() {
<span class="nc" id="L707">		return (int) mMax;</span>
	}

	/**
	 * @see #setProgress(int)
	 */
	@Override
	protected boolean onLevelChange(int level) {
<span class="nc" id="L715">		return setProgress((int) (level / (float) MAX_LEVEL * mMax));</span>
	}

	/**
	 * Sets the current progress value of this progress drawable which determines size of progress
	 * drawn by this drawable.
	 * &lt;p&gt;
	 * Does nothing if the current mode is &lt;b&gt;INDETERMINATE&lt;/b&gt;.
	 *
	 * @param progress The desired progress. Should be from the range {@code [0, getMax()]}.
	 * @return {@code True} if progress has been changed, {@code false} otherwise.
	 * @see #getProgress()
	 */
	public boolean setProgress(int progress) {
<span class="nc bnc" id="L729" title="All 8 branches missed.">		if (mMode != INDETERMINATE &amp;&amp; mProgress != progress &amp;&amp; progress &gt;= 0 &amp;&amp; progress &lt;= mMax) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">			if (onProgressChange(mProgress = progress)) {</span>
<span class="nc" id="L731">				invalidateSelf();</span>
<span class="nc" id="L732">				return true;</span>
			}
		}
<span class="nc" id="L735">		return false;</span>
	}

	/**
	 * Invoked whenever {@link #setProgress(int)} is called and the current progress has been changed.
	 * &lt;p&gt;
	 * This implementation does nothing and returns {@code false}.
	 *
	 * @param progress The currently changed progress.
	 * @return {@code True} if this drawable should be invalidated due to this change, {@code false}
	 * otherwise.
	 */
	protected boolean onProgressChange(int progress) {
<span class="nc" id="L748">		return false;</span>
	}

	/**
	 * Returns the progress value set to this progress drawable by {@link #setProgress(int)}.
	 *
	 * @return Current progress or {@code 0} if the current mode is not &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 */
	public int getProgress() {
<span class="nc bnc" id="L757" title="All 2 branches missed.">		return mMode != INDETERMINATE ? mProgress : 0;</span>
	}

	/**
	 * Changes mode of this progress drawable. The progress mode specifies behaviour and drawing
	 * of this drawable and its progress.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that changing the current mode will not affect in any way currently running
	 * animation session, just drawing behaviour of the progress/indeterminate graphics. This means,
	 * that changing mode to for example &lt;b&gt;INDETERMINATE&lt;/b&gt; will not start indeterminate animation
	 * session by {@link #start()}, this is responsibility of the user (view) of this drawable to
	 * start or stop animations properly. This is due to performance, so changing mode will not start
	 * animations at time when the view which hosts this drawable is not attached to window yet.
	 *
	 * @param mode A flag of the desired mode.
	 * @see #getMode()
	 */
	public void setMode(int mode) {
<span class="nc bnc" id="L775" title="All 2 branches missed.">		if (mMode != mode) {</span>
<span class="nc" id="L776">			onPreModeChange(mode);</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">			if (onModeChange(mMode = mode)) {</span>
<span class="nc" id="L778">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L781">	}</span>

	/**
	 * Invoked whenever {@link #setMode(int)} is called and the current mode should be changed.
	 * &lt;p&gt;
	 * This implementation does nothing.
	 *
	 * @param mode The mode which will be changed after this call.
	 */
	protected void onPreModeChange(int mode) {
<span class="nc" id="L791">	}</span>

	/**
	 * Invoked whenever {@link #setMode(int)} is called and the current mode has been changed.
	 * &lt;p&gt;
	 * This implementation does nothing and returns {@code false}.
	 *
	 * @param mode The currently changed mode.
	 * @return {@code True} if this drawable should be invalidated due to this change, {@code false}
	 * otherwise.
	 */
	protected boolean onModeChange(int mode) {
<span class="nc" id="L803">		return false;</span>
	}

	/**
	 * Returns the current mode of this progress drawable set by {@link #setMode(int)}.
	 *
	 * @return Current mode.
	 * @see #setMode(int)
	 */
	public int getMode() {
<span class="nc" id="L813">		return mMode;</span>
	}

	/**
	 * Sets the color used to draw graphics of this progress drawable.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that this color is used only if the multicolored mode is disabled. See {@link #setMultiColored(boolean)}
	 * for more info.
	 *
	 * @param color The desired color.
	 * @see #getColor()
	 */
	public void setColor(@ColorInt int color) {
<span class="nc bnc" id="L826" title="All 4 branches missed.">		if (mProgressState.rawColor != color || mProgressState.drawColor != color) {</span>
<span class="nc" id="L827">			mProgressState.color = mProgressState.rawColor = mProgressState.drawColor = color;</span>
<span class="nc" id="L828">			invalidateSelf();</span>
		}
<span class="nc" id="L830">	}</span>

	/**
	 * Returns the color used to draw graphics of this progress drawable.
	 *
	 * @return The current color. This color can be modified whenever {@link #setAlpha(int)} is called.
	 * @see #setColor(int)
	 */
	@ColorInt
	public int getColor() {
<span class="nc" id="L840">		return mProgressState.drawColor;</span>
	}

	/**
	 * Sets the set of colors used to draw graphics of this progress drawable. The given colors
	 * are used only if the mode of this drawable is &lt;b&gt;INDETERMINATE&lt;/b&gt; and the multicolored mode
	 * is enabled by {@link #setMultiColored(boolean)}.
	 * &lt;p&gt;
	 * How a specific color is picked from the given set depends on a specific implementation of this
	 * progress drawable, but basically the current color is changed whenever this drawable enters a
	 * next indeterminate &quot;session&quot;.
	 *
	 * @param colors The desired set of colors. May be {@code null} but not empty.
	 * @see #getColors()
	 */
	public void setColors(@Nullable int[] colors) {
<span class="nc bnc" id="L856" title="All 4 branches missed.">		if (colors != null &amp;&amp; colors.length == 0) {</span>
<span class="nc" id="L857">			throw new IllegalArgumentException(&quot;Empty array with colors is not allowed.&quot;);</span>
		}

<span class="nc bnc" id="L860" title="All 2 branches missed.">		if (!Arrays.equals(mProgressState.colors, colors)) {</span>
<span class="nc" id="L861">			this.mProgressState.colors = colors;</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">			if ((mPrivateFlags &amp; PFLAG_MULTI_COLORED) != 0) {</span>
<span class="nc" id="L863">				changeNextColor();</span>
<span class="nc" id="L864">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L867">	}</span>

	/**
	 * Returns the set of colors used to draw graphics of this progress drawable in the
	 * &lt;b&gt;INDETERMINATE&lt;/b&gt; mode.
	 *
	 * @return Set of colors or {@code null} if no colors were specified.
	 * @see #setColors(int[])
	 */
	public int[] getColors() {
<span class="nc" id="L877">		return mProgressState.colors;</span>
	}

	/**
	 * Sets a flag indicating whether this progress drawable should use set of colors specified by
	 * {@link #setColors(int[])} to draw its graphics whenever in the &lt;b&gt;INDETERMINATE&lt;/b&gt; mode.
	 *
	 * @param multiColored {@code True} to use set of colors, {@code false} to use color specified
	 *                     by {@link #setColor(int)}.
	 * @see #isMultiColored()
	 */
	public void setMultiColored(boolean multiColored) {
<span class="nc bnc" id="L889" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_MULTI_COLORED) != multiColored) {</span>
<span class="nc" id="L890">			this.updatePrivateFlags(PFLAG_MULTI_COLORED, multiColored);</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">			if (!multiColored) {</span>
<span class="nc" id="L892">				changeColor(mProgressState.color);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">				if (mMode == INDETERMINATE) {</span>
<span class="nc" id="L894">					changeBackgroundColor(mProgressState.backgroundColor);</span>
				}
			}
		}
<span class="nc" id="L898">	}</span>

	/**
	 * Returns a flag indicating whether this progress drawable uses set of colors or single color
	 * to draw its graphics.
	 *
	 * @return {@code True} if this drawable is multicolored, {@code false} otherwise.
	 * @see #setMultiColored(boolean)
	 */
	public boolean isMultiColored() {
<span class="nc bnc" id="L908" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_MULTI_COLORED) != 0;</span>
	}

	/**
	 * Sets the color used to draw background of this progress drawable.
	 *
	 * @param color The desired background color.
	 * @see #getBackgroundColor()
	 */
	public void setBackgroundColor(@ColorInt int color) {
<span class="nc bnc" id="L918" title="All 4 branches missed.">		if (mProgressState.backgroundRawColor != color || mProgressState.backgroundDrawColor != color) {</span>
<span class="nc" id="L919">			mProgressState.backgroundColor = mProgressState.backgroundRawColor = mProgressState.backgroundDrawColor = color;</span>
<span class="nc" id="L920">			invalidateSelf();</span>
		}
<span class="nc" id="L922">	}</span>

	/**
	 * Returns the background color of this progress drawable.
	 *
	 * @return Background color. This color is modified whenever {@link #setAlpha(int)} is called.
	 * @see #setBackgroundColor(int)
	 */
	@ColorInt
	public int getBackgroundColor() {
<span class="nc" id="L932">		return mProgressState.backgroundDrawColor;</span>
	}

	/**
	 * Sets the thickness of this progress drawable. The specified thickness can be animated by
	 * {@link #explode()} or {@link #implode()}.
	 * &lt;p&gt;
	 * How the thickness is used when drawing this drawable depends on a specific implementation of
	 * this drawable.
	 *
	 * @param thickness The desired thickness in pixels.
	 * @see #getThickness()
	 */
	public void setThickness(float thickness) {
<span class="nc bnc" id="L946" title="All 4 branches missed.">		if (mProgressState.rawThickness != thickness || mProgressState.useThickness != thickness) {</span>
<span class="nc" id="L947">			mProgressState.rawThickness = mProgressState.useThickness = Math.max(0, thickness);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">			if (onThicknessChange(mProgressState.useThickness)) {</span>
<span class="nc" id="L949">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L952">	}</span>

	/**
	 * Invoked whenever {@link #setThickness(float)} is called and the current thickness has been changed.
	 * This will be also invoked during running &lt;b&gt;explode&lt;/b&gt; or &lt;b&gt;implode&lt;/b&gt; animation.
	 * &lt;p&gt;
	 * This implementation does nothing and returns {@code false}.
	 *
	 * @param thickness The currently changed thickness.
	 * @return {@code True} if this drawable should be invalidated due to this change, {@code false}
	 * otherwise.
	 */
	protected boolean onThicknessChange(float thickness) {
<span class="nc" id="L965">		return false;</span>
	}

	/**
	 * Returns the thickness of this progress drawable.
	 *
	 * @return Current thickness in pixels.
	 * @see #setThickness(float)
	 */
	public float getThickness() {
<span class="nc" id="L975">		return mProgressState.useThickness;</span>
	}

	/**
	 * Sets a flag indicating whether a &quot;shape&quot; of this progress drawable should be rounded or not.
	 *
	 * @param rounded {@code True} to enable rounded feature, {@code false} otherwise.
	 * @see #isRounded()
	 */
	public void setRounded(boolean rounded) {
<span class="nc bnc" id="L985" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ROUNDED) != rounded) {</span>
<span class="nc" id="L986">			this.updatePrivateFlags(PFLAG_ROUNDED, rounded);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">			if (onRoundedChange(rounded)) {</span>
<span class="nc" id="L988">				invalidateSelf();</span>
			}
		}
<span class="nc" id="L991">	}</span>

	/**
	 * Invoked whenever {@link #setRounded(boolean)} is called and the current boolean flag for
	 * rounded feature has been changed.
	 * &lt;p&gt;
	 * This implementation does nothing and returns {@code false}.
	 *
	 * @param rounded The current boolean flag for rounded feature.
	 * @return {@code True} if this drawable should be invalidated due to this change, {@code false}
	 * otherwise.
	 */
	protected boolean onRoundedChange(boolean rounded) {
<span class="nc" id="L1004">		return false;</span>
	}

	/**
	 * Returns a flag indicating whether a &quot;shape&quot; of this progress drawable is rounded or not.
	 *
	 * @return {@code True} if shape is rounded, {@code false} otherwise.
	 * @see #setRounded(boolean)
	 */
	public boolean isRounded() {
<span class="nc bnc" id="L1014" title="All 2 branches missed.">		return (mPrivateFlags &amp; PFLAG_ROUNDED) != 0;</span>
	}

	/**
	 * Sets the interpolator used to interpolate computed update values for indeterminate blocks
	 * whenever animation session for none &lt;b&gt;DETERMINATE&lt;/b&gt; mode is running.
	 * &lt;p&gt;
	 * Default interpolator is {@link android.view.animation.AccelerateDecelerateInterpolator}.
	 *
	 * @param interpolator The desired interpolator.
	 * @see #getIndeterminateInterpolator()
	 */
	public void setIndeterminateInterpolator(@NonNull Interpolator interpolator) {
<span class="nc" id="L1027">		this.mIndeterminateInterpolator = interpolator;</span>
<span class="nc" id="L1028">	}</span>

	/**
	 * Returns the interpolator used whenever the current mode is none &lt;b&gt;DETERMINATE&lt;/b&gt; to interpolate
	 * update values for indeterminate blocks.
	 *
	 * @return Indeterminate interpolator.
	 * @see #setIndeterminateInterpolator(android.view.animation.Interpolator)
	 */
	@NonNull
	public Interpolator getIndeterminateInterpolator() {
<span class="nc" id="L1039">		return mIndeterminateInterpolator;</span>
	}

	/**
	 * Sets the speed for indeterminate blocks update used whenever the current mode is none
	 * &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 * &lt;p&gt;
	 * Default speed is {@code 1f}. This speed should be changed only with a good reason to.
	 *
	 * @param speed The desired speed. Should be from the range {@code [0, infinite)}.
	 * @see #getIndeterminateSpeed()
	 */
	public void setIndeterminateSpeed(float speed) {
<span class="nc bnc" id="L1052" title="All 2 branches missed.">		if (mProgressState.indeterminateSpeed != speed) {</span>
<span class="nc" id="L1053">			this.mProgressState.indeterminateSpeed = Math.max(0, speed);</span>
		}
<span class="nc" id="L1055">	}</span>

	/**
	 * Returns the current speed to speed up indeterminate blocks update.
	 *
	 * @return Current indeterminate speed.
	 * @see #setIndeterminateSpeed(float)
	 */
	public float getIndeterminateSpeed() {
<span class="nc" id="L1064">		return mProgressState.indeterminateSpeed;</span>
	}

	/**
	 * Sets the progress color's alpha value.
	 *
	 * @param alpha The desired alpha value to set. Should be from the range [0, 255].
	 */
	@Override
	public void setAlpha(int alpha) {
<span class="nc" id="L1074">		alpha += alpha &gt;&gt; 7; // Ensure range [0, 255]</span>
<span class="nc" id="L1075">		this.updateDrawingColor((mProgressState.rawColor &gt;&gt;&gt; 24) * alpha &gt;&gt; 8);</span>
<span class="nc" id="L1076">		this.updateBackgroundDrawingColor((mProgressState.backgroundRawColor &gt;&gt;&gt; 24) * alpha &gt;&gt; 8);</span>
<span class="nc" id="L1077">	}</span>

	/**
	 * Returns the alpha value of this progress drawable's color.
	 *
	 * @return The alpha value in the range [0, 255].
	 */
	@Override
	public int getAlpha() {
<span class="nc" id="L1086">		return mProgressState.drawColor &gt;&gt;&gt; 24;</span>
	}

	/**
	 */
	@Override
	public void setColorFilter(ColorFilter colorFilter) {
<span class="nc" id="L1093">		PAINT.setColorFilter(colorFilter);</span>
<span class="nc" id="L1094">	}</span>

	/**
	 * Groups:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #setBackgroundTintList(android.content.res.ColorStateList)}&lt;/li&gt;
	 * &lt;li&gt;{@link #setProgressTintList(android.content.res.ColorStateList)}&lt;/li&gt;
	 * &lt;li&gt;{@link #setIndeterminateTintList(android.content.res.ColorStateList)}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * into one call.
	 */
	@Override
	public void setTintList(ColorStateList tint) {
<span class="nc" id="L1107">		setBackgroundTintList(tint);</span>
<span class="nc" id="L1108">		setProgressTintList(tint);</span>
<span class="nc" id="L1109">		setIndeterminateTintList(tint);</span>
<span class="nc" id="L1110">	}</span>

	/**
	 * Groups:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link #setBackgroundTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
	 * &lt;li&gt;{@link #setProgressTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
	 * &lt;li&gt;{@link #setIndeterminateTintMode(android.graphics.PorterDuff.Mode)}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * into one call.
	 */
	@Override
	public void setTintMode(@NonNull PorterDuff.Mode tintMode) {
<span class="nc" id="L1123">		setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L1124">		setProgressTintMode(tintMode);</span>
<span class="nc" id="L1125">		setIndeterminateTintMode(tintMode);</span>
<span class="nc" id="L1126">	}</span>

	/**
	 * Sets a tint for the background graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tint Color state list to use for tinting of the background graphics. May be {@code null}
	 *             to clear the current background tint.
	 */
	public void setBackgroundTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L1138">		mProgressState.backgroundTint = tint;</span>
<span class="nc" id="L1139">		this.mBackgroundTintFilter = TintDrawable.createTintFilter(this, tint, mProgressState.backgroundTintMode);</span>
<span class="nc" id="L1140">		invalidateSelf();</span>
<span class="nc" id="L1141">	}</span>

	/**
	 * Sets a tint blending mode for the background graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tintMode The desired Porter-Duff blending mode.
	 */
	public void setBackgroundTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L1152">		mProgressState.backgroundTintMode = tintMode;</span>
<span class="nc" id="L1153">		this.mBackgroundTintFilter = TintDrawable.createTintFilter(this, mProgressState.backgroundTint, tintMode);</span>
<span class="nc" id="L1154">		invalidateSelf();</span>
<span class="nc" id="L1155">	}</span>

	/**
	 * Sets a tint for the progress graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tint Color state list to use for tinting of the progress graphics. May be {@code null}
	 *             to clear the current progress tint.
	 */
	public void setProgressTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L1167">		mProgressState.progressTint = tint;</span>
<span class="nc" id="L1168">		this.mProgressTintFilter = TintDrawable.createTintFilter(this, tint, mProgressState.progressTintMode);</span>
<span class="nc" id="L1169">		invalidateSelf();</span>
<span class="nc" id="L1170">	}</span>

	/**
	 * Sets a tint blending mode for the progress graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tintMode The desired Porter-Duff blending mode.
	 */
	public void setProgressTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L1181">		mProgressState.progressTintMode = tintMode;</span>
<span class="nc" id="L1182">		this.mProgressTintFilter = TintDrawable.createTintFilter(this, mProgressState.progressTint, tintMode);</span>
<span class="nc" id="L1183">		invalidateSelf();</span>
<span class="nc" id="L1184">	}</span>

	/**
	 * Sets a tint for the indeterminate graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tint Color state list to use for tinting of the indeterminate graphics. May be {@code null}
	 *             to clear the current indeterminate tint.
	 */
	public void setIndeterminateTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L1196">		mProgressState.indeterminateTint = tint;</span>
<span class="nc" id="L1197">		this.mIndeterminateTintFilter = TintDrawable.createTintFilter(this, tint, mProgressState.indeterminateTintMode);</span>
<span class="nc" id="L1198">		invalidateSelf();</span>
<span class="nc" id="L1199">	}</span>

	/**
	 * Sets a tint blending mode for the indeterminate graphics of this drawable.
	 * &lt;p&gt;
	 * Setting a color filter via {@link #setColorFilter(android.graphics.ColorFilter)} will override
	 * the tint.
	 *
	 * @param tintMode The desired Porter-Duff blending mode.
	 */
	public void setIndeterminateTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L1210">		mProgressState.indeterminateTintMode = tintMode;</span>
<span class="nc" id="L1211">		this.mIndeterminateTintFilter = TintDrawable.createTintFilter(this, mProgressState.indeterminateTint, tintMode);</span>
<span class="nc" id="L1212">		invalidateSelf();</span>
<span class="nc" id="L1213">	}</span>

	/**
	 */
	@Override
	public int getOpacity() {
<span class="nc bnc" id="L1219" title="All 6 branches missed.">		if (mProgressTintFilter != null || mIndeterminateTintFilter != null || PAINT.getColorFilter() != null) {</span>
<span class="nc" id="L1220">			return PixelFormat.TRANSLUCENT;</span>
		}
<span class="nc bnc" id="L1222" title="All 3 branches missed.">		switch (mProgressState.drawColor &gt;&gt;&gt; 24) {</span>
			case 255:
<span class="nc" id="L1224">				return PixelFormat.OPAQUE;</span>
			case 0:
<span class="nc" id="L1226">				return PixelFormat.TRANSPARENT;</span>
		}
<span class="nc" id="L1228">		return PixelFormat.TRANSLUCENT;</span>
	}

	/**
	 */
	@Override
	public ConstantState getConstantState() {
<span class="nc" id="L1235">		return mProgressState;</span>
	}

	/**
	 * Registers a callback to be invoked whenever the animation session for this progress drawable
	 * is started or stopped.
	 *
	 * @param callback Listener callback. {@code Null} is allowed to clear the current callback.
	 */
	public void setAnimationCallback(@Nullable AnimationCallback callback) {
<span class="nc" id="L1245">		this.mAnimationCallback = callback;</span>
<span class="nc" id="L1246">	}</span>

	/**
	 * Registers a callback to be invoked whenever the thickness of this progress drawable is
	 * exploded or imploded.
	 *
	 * @param callback Listener callback. {@code Null} is allowed to clear the current callback.
	 */
	public void setExplodeAnimationCallback(@Nullable ExplodeAnimationCallback callback) {
<span class="nc" id="L1255">		this.mExplodeAnimationCallback = callback;</span>
<span class="nc" id="L1256">	}</span>

	/**
	 */
	@Override
	public boolean onLayoutDirectionChanged(int layoutDirection) {
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (mProgressState.direction != layoutDirection) {</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">			switch (layoutDirection) {</span>
				case View.LAYOUT_DIRECTION_LTR:
				case View.LAYOUT_DIRECTION_RTL:
<span class="nc" id="L1266">					mProgressState.direction = layoutDirection;</span>
<span class="nc" id="L1267">					invalidateSelf();</span>
<span class="nc" id="L1268">					return true;</span>
			}
		}
<span class="nc" id="L1271">		return super.onLayoutDirectionChanged(layoutDirection);</span>
	}

	/**
	 * Returns the layout direction of this progress drawable.
	 *
	 * @return One of {@link android.view.View#LAYOUT_DIRECTION_LTR LAYOUT_DIRECTION_LTR},
	 * {@link android.view.View#LAYOUT_DIRECTION_RTL LAYOUT_DIRECTION_RTL}.
	 */
	public int getLayoutDirection() {
<span class="nc" id="L1281">		return mProgressState.direction;</span>
	}

	/**
	 */
	@Override
	protected boolean onStateChange(int[] state) {
<span class="nc" id="L1288">		boolean appearanceChange = false;</span>
<span class="nc bnc" id="L1289" title="All 4 branches missed.">		if (mProgressState.progressTint != null &amp;&amp; mProgressState.progressTintMode != null) {</span>
<span class="nc" id="L1290">			this.mProgressTintFilter = TintDrawable.createTintFilter(</span>
					this, mProgressState.progressTint, mProgressState.progressTintMode
			);
<span class="nc" id="L1293">			appearanceChange = true;</span>
		}
<span class="nc bnc" id="L1295" title="All 4 branches missed.">		if (mProgressState.indeterminateTint != null &amp;&amp; mProgressState.indeterminateTintMode != null) {</span>
<span class="nc" id="L1296">			this.mIndeterminateTintFilter = TintDrawable.createTintFilter(</span>
					this, mProgressState.indeterminateTint, mProgressState.indeterminateTintMode
			);
<span class="nc" id="L1299">			appearanceChange = true;</span>
		}
<span class="nc bnc" id="L1301" title="All 4 branches missed.">		if (mProgressState.backgroundTint != null &amp;&amp; mProgressState.backgroundTintMode != null) {</span>
<span class="nc" id="L1302">			this.mBackgroundTintFilter = TintDrawable.createTintFilter(</span>
					this, mProgressState.backgroundTint, mProgressState.backgroundTintMode
			);
<span class="nc" id="L1305">			appearanceChange = true;</span>
		}
<span class="nc bnc" id="L1307" title="All 4 branches missed.">		return super.onStateChange(state) || appearanceChange;</span>
	}

	/**
	 */
	@Override
	protected void onBoundsChange(Rect bounds) {
<span class="nc" id="L1314">		super.onBoundsChange(mBounds = bounds);</span>
<span class="nc" id="L1315">	}</span>

	/**
	 * Invoked whenever {@link #setExploded(boolean)} is called and the current boolean flag for
	 * exploded state has been changed.
	 * &lt;p&gt;
	 * This implementation does nothing and returns {@code false}.
	 *
	 * @param exploded The current boolean flag for exploded state.
	 * @return {@code True} if this drawable should be invalidated due to this change, {@code false}
	 * otherwise.
	 */
	protected boolean onExplodedChange(boolean exploded) {
<span class="nc" id="L1328">		return false;</span>
	}

	/**
	 * Invoked whenever {@link #start()} is called and this progress drawable does not have animation
	 * session currently running and the current mode is none &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 */
	protected abstract void onStart();

	/**
	 * Invoked whenever {@link #stop()} is called and this progress drawable does have animation
	 * sessions currently running and the current mode is none &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 */
	protected abstract void onStop();

	/**
	 * Invoked whenever {@link #stopImmediate()} is called and this progress drawable does have animation
	 * sessions currently running and the current mode is none &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 */
	protected abstract void onStopImmediate();

	/**
	 * Invoked whenever {@link #explode()} is called and thickness of this progress drawable is not
	 * exploded yet.
	 * &lt;p&gt;
	 * This implementation will schedule updates to increase the current thickness to the value
	 * specified by {@link #setThickness(float)}.
	 */
	protected void onExplode() {
<span class="nc" id="L1357">		scheduleSelf(EXPLODE_THICKNESS, 0);</span>
<span class="nc" id="L1358">	}</span>

	/**
	 * Invoked whenever {@link #implode()} is called and thickness of this progress drawable is not
	 * imploded yet.
	 * &lt;p&gt;
	 * This implementation will schedule updates to decrease the current thickness to {@code 0}.
	 */
	protected void onImplode() {
<span class="nc" id="L1367">		scheduleSelf(IMPLODE_THICKNESS, 0);</span>
<span class="nc" id="L1368">	}</span>

	/**
	 * Invoked whenever {@link #UPDATE} task has been scheduled or this method returns {@code true}.
	 *
	 * @return {@code True} to invalidate this drawable and re-schedule the {@link #UPDATE} task so
	 * this method will be invoked again after {@link #FRAME_UPDATE_INTERVAL}, {@code false} to
	 * cancel UPDATE task scheduling loop.
	 */
	boolean onUpdate() {
<span class="nc" id="L1378">		return false;</span>
	}

	/**
	 * Notifies the current AnimationCallback (if any), that the animation session of this progress
	 * drawable has been started.
	 */
	final void notifyStarted() {
<span class="nc" id="L1386">		updatePrivateFlags(PFLAG_RUNNING, true);</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">		if (mAnimationCallback != null) {</span>
<span class="nc" id="L1388">			mAnimationCallback.onStarted(this);</span>
		}
<span class="nc" id="L1390">	}</span>

	/**
	 * Notifies the current AnimationCallback (if any), that the current animation session of this
	 * progress drawable has been stopped.
	 */
	final void notifyStopped() {
<span class="nc" id="L1397">		updatePrivateFlags(PFLAG_RUNNING, false);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">		if (mAnimationCallback != null) {</span>
<span class="nc" id="L1399">			mAnimationCallback.onStopped(this);</span>
		}
<span class="nc" id="L1401">	}</span>

	/**
	 * Invoked whenever {@link #explode()} or {@link #implode()} has been called and the related
	 * animation has been finished.
	 * &lt;p&gt;
	 * This will also notifies the current ExplodeAnimationCallback (if any).
	 *
	 * @param exploded {@code True} if thickness has been just now exploded, {@code false} if has
	 *                 been imploded.
	 */
	void onExploded(boolean exploded) {
<span class="nc" id="L1413">		this.updatePrivateFlags(PFLAG_EXPLODED, exploded);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">		if (mExplodeAnimationCallback != null) {</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">			if (exploded) {</span>
<span class="nc" id="L1416">				mExplodeAnimationCallback.onExploded(this);</span>
			} else {
<span class="nc" id="L1418">				mExplodeAnimationCallback.onImploded(this);</span>
			}
		}
<span class="nc" id="L1421">	}</span>

	/**
	 * Changes the current background color to the specified one.
	 *
	 * @param color The new background color.
	 */
	void changeBackgroundColor(int color) {
<span class="nc bnc" id="L1429" title="All 2 branches missed.">		if (mProgressState.backgroundColor == Color.TRANSPARENT) {</span>
<span class="nc" id="L1430">			return;</span>
		}

<span class="nc bnc" id="L1433" title="All 4 branches missed.">		if (mProgressState.backgroundRawColor != color || mProgressState.backgroundDrawColor != color) {</span>
<span class="nc" id="L1434">			mProgressState.backgroundRawColor = color;</span>
			// Recompute alpha value for the new background color.
<span class="nc" id="L1436">			this.updateBackgroundDrawingColor(mProgressState.backgroundDrawColor &gt;&gt;&gt; 24);</span>
		}
<span class="nc" id="L1438">	}</span>

	/**
	 * Changes the current color to the specified one.
	 *
	 * @param color The new color.
	 */
	void changeColor(int color) {
<span class="nc bnc" id="L1446" title="All 4 branches missed.">		if (mProgressState.rawColor != color || mProgressState.drawColor != color) {</span>
<span class="nc" id="L1447">			mProgressState.rawColor = color;</span>
			// Recompute alpha value for the new color.
<span class="nc" id="L1449">			this.updateDrawingColor(mProgressState.drawColor &gt;&gt;&gt; 24);</span>
		}
<span class="nc" id="L1451">	}</span>

	/**
	 * Updates current drawing color to a color for the current color index for &lt;b&gt;multicolored&lt;/b&gt;
	 * mode, or to the raw color set by {@link #setColor(int)}, to ensure that all colors are properly
	 * set including background color.
	 */
	void updateColor() {
<span class="nc" id="L1459">		this.mCurrentColorIndex--;</span>
<span class="nc" id="L1460">		changeNextColor();</span>
<span class="nc" id="L1461">	}</span>

	/**
	 * Changes the next color from the current set of colors (if any) as current color for this
	 * progress drawable.
	 * &lt;p&gt;
	 * If the multicolored mode is disabled, this will reset the current color to the default color
	 * specified by {@link #setColor(int)}.
	 */
	void changeNextColor() {
<span class="nc bnc" id="L1471" title="All 2 branches missed.">		if (mProgressState.colors == null) {</span>
<span class="nc" id="L1472">			this.mCurrentColorIndex = 0;</span>
<span class="nc" id="L1473">			return;</span>
		}

<span class="nc bnc" id="L1476" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_MULTI_COLORED) != 0) {</span>
<span class="nc" id="L1477">			this.mCurrentColorIndex++;</span>
<span class="nc bnc" id="L1478" title="All 4 branches missed.">			if (mCurrentColorIndex &gt;= mProgressState.colors.length || mCurrentColorIndex &lt; 0) {</span>
<span class="nc" id="L1479">				this.mCurrentColorIndex = 0;</span>
			}
<span class="nc" id="L1481">			final int color = mProgressState.colors[mCurrentColorIndex];</span>
<span class="nc" id="L1482">			changeColor(color);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">			if (mMode == INDETERMINATE) {</span>
<span class="nc" id="L1484">				changeBackgroundColor(Color.argb(</span>
						BACKGROUND_COLOR_ALPHA,
<span class="nc" id="L1486">						Color.red(color),</span>
<span class="nc" id="L1487">						Color.green(color),</span>
<span class="nc" id="L1488">						Color.blue(color)</span>
				));
			}
<span class="nc bnc" id="L1491" title="All 2 branches missed.">		} else if (mCurrentColorIndex != 0) {</span>
<span class="nc" id="L1492">			this.mCurrentColorIndex = 0;</span>
<span class="nc" id="L1493">			changeColor(mProgressState.color);</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">			if (mMode == INDETERMINATE) {</span>
<span class="nc" id="L1495">				changeBackgroundColor(mProgressState.backgroundColor);</span>
			}
		}
<span class="nc" id="L1498">	}</span>

	/**
	 * Resets the current color of this progress drawable to the default color specified by {@link #setColor(int)}
	 * or to the first color from the colors set specified by {@link #setColors(int[])} depends
	 * on if the multicolored mode is enabled or not.
	 */
	void resetCurrentColor() {
<span class="nc" id="L1506">		this.mCurrentColorIndex = -1;</span>
<span class="nc" id="L1507">		changeNextColor();</span>
<span class="nc" id="L1508">	}</span>

	/**
	 * Changes the current constant state of this progress drawable.
	 *
	 * @param state The new constant state.
	 */
	void changeConstantState(ProgressState state) {
<span class="nc" id="L1516">		this.mProgressState = state;</span>
<span class="nc" id="L1517">	}</span>

	/**
	 * Updates the given &lt;var&gt;paint&lt;/var&gt; in the way, that changes its options in order to enable
	 * or disable rounded feature for the paint.
	 *
	 * @param paint   The paint to update.
	 * @param rounded {@code True} if the paint should support rounded feature so a graphics drawn
	 *                using the paint will have rounded corners, {@code false} to clear the current
	 *                rounded feature.
	 * @return The specified paint with updated &lt;b&gt;stroke join, stroke cap&lt;/b&gt; and &lt;b&gt;path effect&lt;/b&gt;.
	 */
	Paint updatePaintToRounded(Paint paint, boolean rounded) {
<span class="nc bnc" id="L1530" title="All 2 branches missed.">		if (rounded) {</span>
<span class="nc" id="L1531">			paint.setStrokeJoin(Paint.Join.ROUND);</span>
<span class="nc" id="L1532">			paint.setStrokeCap(Paint.Cap.ROUND);</span>
<span class="nc" id="L1533">			paint.setPathEffect(new CornerPathEffect(mProgressState.useThickness));</span>
		} else {
<span class="nc" id="L1535">			paint.setStrokeJoin(Paint.Join.MITER);</span>
<span class="nc" id="L1536">			paint.setStrokeCap(Paint.Cap.BUTT);</span>
<span class="nc" id="L1537">			paint.setPathEffect(null);</span>
		}
<span class="nc" id="L1539">		return paint;</span>
	}

	/**
	 * Updates the current constant state from the values in the typed array.
	 */
	void updateStateFromTypedArray(TypedArray typedArray) {
		// Cannot be properly implemented.
<span class="nc" id="L1547">	}</span>

	/**
	 * Computes value of update for explode/implode task.
	 *
	 * @return Computed update value.
	 */
	final float computeExplodeImplodeUpdate() {
<span class="nc" id="L1555">		return mProgressState.rawThickness / (mExplodeDuration / FRAME_UPDATE_INTERVAL);</span>
	}

	/**
	 * Updates the current private flags.
	 *
	 * @param flag Value of the desired flag to add/remove to/from the current private flags.
	 * @param add  Boolean flag indicating whether to add or remove the specified &lt;var&gt;flag&lt;/var&gt;.
	 */
	void updatePrivateFlags(int flag, boolean add) {
<span class="nc bnc" id="L1565" title="All 2 branches missed.">		if (add) {</span>
<span class="nc" id="L1566">			this.mPrivateFlags |= flag;</span>
		} else {
<span class="nc" id="L1568">			this.mPrivateFlags &amp;= ~flag;</span>
		}
<span class="nc" id="L1570">	}</span>

	/**
	 * Returns a boolean flag indicating whether the specified &lt;var&gt;flag&lt;/var&gt; is contained within
	 * the current private flags or not.
	 *
	 * @param flag Value of the flag to check.
	 * @return {@code True} if the requested flag is contained, {@code false} otherwise.
	 */
	boolean hasPrivateFlag(int flag) {
<span class="nc bnc" id="L1580" title="All 2 branches missed.">		return (mPrivateFlags &amp; flag) != 0;</span>
	}

	/**
	 * Computes schedule time for {@link #scheduleSelf(Runnable, long)} method for the specified
	 * &lt;var&gt;delay&lt;/var&gt;.
	 *
	 * @param delay The desired delay for the scheduling task.
	 * @return Computed schedule time with the specified delay and {@link android.os.SystemClock#uptimeMillis()}
	 * as base.
	 */
	static long computeScheduleTime(long delay) {
<span class="nc" id="L1592">		return SystemClock.uptimeMillis() + delay;</span>
	}

	/**
	 * Computes schedule time for tasks/animations run by this progress drawable in &lt;b&gt;60 fps&lt;/b&gt; rate.
	 *
	 * @return Computed schedule time with {@link #FRAME_UPDATE_INTERVAL} delay and {@link android.os.SystemClock#uptimeMillis()}
	 * as base.
	 */
	static long computeFramesScheduleTime() {
<span class="nc" id="L1602">		return computeScheduleTime(FRAME_UPDATE_INTERVAL);</span>
	}

	/**
	 * Updates the current color used to draw graphics of this progress drawable.
	 *
	 * @param alpha An alpha value to be updated for the current color.
	 */
	private void updateDrawingColor(int alpha) {
<span class="nc" id="L1611">		final int drawColor = (mProgressState.rawColor &lt;&lt; 8 &gt;&gt;&gt; 8) | (alpha &lt;&lt; 24);</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">		if (mProgressState.drawColor != drawColor) {</span>
<span class="nc" id="L1613">			mProgressState.drawColor = drawColor;</span>
<span class="nc" id="L1614">			invalidateSelf();</span>
		}
<span class="nc" id="L1616">	}</span>

	/**
	 * Updates the current color used to draw background of this progress drawable.
	 *
	 * @param alpha An alpha value to be updated for the background color.
	 */
	private void updateBackgroundDrawingColor(int alpha) {
<span class="nc" id="L1624">		final int drawColor = (mProgressState.backgroundRawColor &lt;&lt; 8 &gt;&gt;&gt; 8) | (alpha &lt;&lt; 24);</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">		if (mProgressState.backgroundDrawColor != drawColor) {</span>
<span class="nc" id="L1626">			mProgressState.backgroundDrawColor = drawColor;</span>
<span class="nc" id="L1627">			invalidateSelf();</span>
		}
<span class="nc" id="L1629">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Constant state implementation for this drawable class.
	 */
	static abstract class ProgressState extends ConstantState {

		/**
		 * Multicolored set of colors for indeterminate mode.
		 */
		int[] colors;

		/**
		 * Raw &quot;untouched&quot; color set by {@link #setColor(int)}.
		 */
		int color;

		/**
		 * Current color from multicolored set ({@link #colors}) used to update {@link #drawColor}.
		 */
		int rawColor;

		/**
		 * Color modified by {@link #setAlpha(int)} used to draw progress or indeterminate blocks.
		 */
		int drawColor;

		/**
		 * Raw &quot;untouched&quot; color set by {@link #setBackgroundColor(int)}.
		 */
		int backgroundColor;

		/**
		 * Current color from multicolored set ({@link #colors}) with modified alpha for background
		 * used to update {@link #backgroundDrawColor}.
		 */
		int backgroundRawColor;

		/**
		 * Color modified by {@link #setAlpha(int)} used to draw background.
		 */
		int backgroundDrawColor;

		/**
		 * Thickness of progress drawable's shape set by {@link #setThickness(float)}.
		 */
		float rawThickness;

		/**
		 * Thickness modified during exploding/imploding of progress drawable.
		 */
		float useThickness;

		/**
		 * Speed for the indeterminate updates.
		 * &lt;p&gt;
		 * &lt;b&gt;Note&lt;/b&gt;, that this does not influences the FPS for the running indeterminate animation,
		 * but rather the ratio for the update deltas for a start and sweep angle of the progress arc.
		 */
<span class="nc" id="L1692">		float indeterminateSpeed = 1f;</span>

		/**
		 * Direction in which to draw progress drawable's graphics.
		 */
		int direction;

		/**
		 * Color state list used to apply tint to the background graphics.
		 */
		ColorStateList backgroundTint;

		/**
		 * Blending mode used to apply the progress background tint.
		 */
<span class="nc" id="L1707">		PorterDuff.Mode backgroundTintMode = TintDrawable.DEFAULT_TINT_MODE;</span>

		/**
		 * Color state list used to apply tint to the progress graphics.
		 */
		ColorStateList progressTint;

		/**
		 * Blending mode used to apply the progress graphics tint.
		 */
<span class="nc" id="L1717">		PorterDuff.Mode progressTintMode = TintDrawable.DEFAULT_TINT_MODE;</span>

		/**
		 * Color state list used to apply tint to the indeterminate graphics.
		 */
		ColorStateList indeterminateTint;

		/**
		 * Blending mode used to apply the indeterminate graphics tint.
		 */
<span class="nc" id="L1727">		PorterDuff.Mode indeterminateTintMode = TintDrawable.DEFAULT_TINT_MODE;</span>

		/**
		 */
		int[] themeAttrs;

		/**
		 */
		int changingConfigurations;

		/**
		 * Creates a new instance of empty ProgressState.
		 */
<span class="nc" id="L1740">		ProgressState() {</span>
<span class="nc" id="L1741">		}</span>

		/**
		 * Creates a new instance of ProgressState with parameters copied from the specified &lt;var&gt;state&lt;/var&gt;.
		 *
		 * @param state The state from which to create the new one.
		 */
<span class="nc" id="L1748">		ProgressState(@NonNull ProgressState state) {</span>
<span class="nc" id="L1749">			this.colors = state.colors;</span>
<span class="nc" id="L1750">			this.color = state.color;</span>
<span class="nc" id="L1751">			this.rawColor = state.rawColor;</span>
<span class="nc" id="L1752">			this.drawColor = state.drawColor;</span>
<span class="nc" id="L1753">			this.backgroundColor = state.backgroundColor;</span>
<span class="nc" id="L1754">			this.backgroundRawColor = state.backgroundRawColor;</span>
<span class="nc" id="L1755">			this.backgroundDrawColor = state.backgroundDrawColor;</span>
<span class="nc" id="L1756">			this.rawThickness = state.rawThickness;</span>
<span class="nc" id="L1757">			this.useThickness = state.useThickness;</span>
<span class="nc" id="L1758">			this.indeterminateSpeed = state.indeterminateSpeed;</span>
<span class="nc" id="L1759">			this.backgroundTint = state.backgroundTint;</span>
<span class="nc" id="L1760">			this.backgroundTintMode = state.backgroundTintMode;</span>
<span class="nc" id="L1761">			this.progressTint = state.progressTint;</span>
<span class="nc" id="L1762">			this.progressTintMode = state.progressTintMode;</span>
<span class="nc" id="L1763">			this.indeterminateTint = state.indeterminateTint;</span>
<span class="nc" id="L1764">			this.indeterminateTintMode = state.indeterminateTintMode;</span>
<span class="nc" id="L1765">			this.changingConfigurations = state.changingConfigurations;</span>
<span class="nc" id="L1766">			this.themeAttrs = state.themeAttrs;</span>
<span class="nc" id="L1767">		}</span>

		/**
		 */
		@Override
		public boolean canApplyTheme() {
<span class="nc bnc" id="L1773" title="All 2 branches missed.">			return themeAttrs != null;</span>
		}

		/**
		 */
		@Override
		public int getChangingConfigurations() {
<span class="nc" id="L1780">			return changingConfigurations;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>