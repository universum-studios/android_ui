<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PullController.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.controller</a> &gt; <span class="el_source">PullController.java</span></div><h1>PullController.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.controller;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.TypedArray;
import android.os.Build;
import android.support.annotation.AttrRes;
import android.support.annotation.IntDef;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.StyleRes;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Interpolator;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.ArrayList;
import java.util.List;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.widget.Pullable;
import universum.studios.android.ui.widget.Scrollable;

/**
 * PullController can be used to support &lt;b&gt;pull&lt;/b&gt; feature for the scrollable views, especially
 * collections like {@link android.widget.ListView} or {@link android.widget.ScrollView}. A view that
 * wants to provide pull feature need to implement required {@link Scrollable} interface that specifies
 * simple API needed for this controller to properly handle this feature.
 * &lt;p&gt;
 * PullController supports pulling of the attached pullable view at its &lt;b&gt;start&lt;/b&gt; and &lt;b&gt;end&lt;/b&gt;
 * depending on the view's orientation that is determined via {@link Scrollable#getOrientation()}
 * by changing the view's &lt;b&gt;top and bottom&lt;/b&gt; ({@link View#offsetTopAndBottom(int)}) or &lt;b&gt;left and right&lt;/b&gt;
 * ({@link View#offsetLeftAndRight(int)}) offset. Whether the pulling at start or end is enabled or
 * not can be requested via {@link #setPullMode(int)} and passing flags for the desired pull type.
 * Visibility of pull can be requested via {@link #setPullVisibility(int, boolean)} and also passing
 * the desired pull flags.
 * &lt;p&gt;
 * To receive callback about the current pull, a watcher needs to register {@link Pullable.OnPullListener}
 * that receives callbacks about the &lt;b&gt;started&lt;/b&gt;, &lt;b&gt;performed&lt;/b&gt;, &lt;b&gt;released&lt;/b&gt; or &lt;b&gt;collapsed&lt;/b&gt;
 * pull. {@link Pullable.OnPullOverflowListener} that can be also registered receives one callback
 * about the &lt;b&gt;pull overflow&lt;/b&gt;.
 * &lt;p&gt;
 * There are a lot of properties that can be set to customize the pull behaviour, for example how
 * much can be the view pulled ({@link #setPullDistance(float)}), or how much time does the collapse
 * pull animation takes ({@link #setPullCollapseDuration(long)}).
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * PullController is meant to be used within views so it also supports set up from {@link AttributeSet}
 * via {@link #setUpFromAttrs(android.content.Context, android.util.AttributeSet, int, int)} method
 * that should be called from within a constructor of the pullable view that uses this controller
 * to provide the pull feature. See {@link R.styleable#Ui_PullController PullController Attributes}.
 *
 * @param &lt;V&gt; Type of the pullable view.
 * @author Martin Albedinsky
 */
public class PullController&lt;V extends View &amp; Pullable&gt; extends BasePullController&lt;V&gt; {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;PullController&quot;;

	/**
	 * Defines an annotation for determining set of allowed flags for {@link #setPullMode(int)} and
	 * {@link #setPullVisibility(int, boolean)} methods.
	 */
	@Retention(RetentionPolicy.SOURCE)
	@IntDef(flag = true, value = {NONE, START, END})
	public @interface PullFlags {
	}

	/**
	 * Flag for {@link #setPullMode(int)} to indicate that neither start or end pull are enabled.
	 */
	public static final int NONE = PullHelper.NONE;

	/**
	 * Flag for {@link #setPullMode(int)} to indicate that the pull at the start of a pullable view
	 * is enabled.
	 */
	public static final int START = PullHelper.START;

	/**
	 * Flag for {@link #setPullMode(int)} to indicate that the pull at the end of a pullable view
	 * is enabled.
	 */
	public static final int END = PullHelper.END;

	/**
	 * Default duration for the pull collapse animation.
	 */
	private static final int PULL_COLLAPSE_DURATION = 200;

	/**
	 * Flag indicating whether the fixed time for pull collapse animation is enabled or not.
	 */
	private static final int PFLAG_PULL_COLLAPSE_FIXED_TIME_ENABLED = 0x00000001;

	/**
	 * Flag indicating whether the over-scroll animation is enabled or not.
	 */
	private static final int PFLAG_OVER_SCROLL_ANIMATION_ENABLED = 0x00000001 &lt;&lt; 1;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Current pull data.
	 */
<span class="nc" id="L150">	final PullImpl PULL = new PullImpl();</span>

	/**
	 * Tracker used to track velocity value to determine whether to initiate pull or not.
	 */
<span class="nc" id="L155">	private final VelocityTracker VELOCITY_TRACKER = VelocityTracker.obtain();</span>

	/**
	 * Animations helper used to run animations upon this controller regardless current Android version.
	 */
	private final Animations mAnimations;

	/**
	 * Set of pull listeners which can receive callbacks about &lt;b&gt;started&lt;/b&gt;, &lt;b&gt;performed&lt;/b&gt;,
	 * &lt;b&gt;released&lt;/b&gt; and &lt;b&gt;collapsed&lt;/b&gt; pull.
	 */
	private List&lt;Pullable.OnPullListener&gt; mListeners;

	/**
	 * Set of pull listeners which can receive callback about &lt;b&gt;pull overflow&lt;/b&gt;.
	 */
	private List&lt;Pullable.OnPullOverflowListener&gt; mOverflowListeners;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of PullController to handle pulling of the specified &lt;var&gt;view&lt;/var&gt;.
	 *
	 * @param view The view of which pull to handle by the new controller.
	 */
	public PullController(@NonNull V view) {
<span class="nc" id="L183">		super(view);</span>
<span class="nc" id="L184">		this.mAnimations = Animations.get(this);</span>
<span class="nc" id="L185">		updatePrivateFlags(PFLAG_PULL_COLLAPSE_FIXED_TIME_ENABLED, true);</span>
<span class="nc" id="L186">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Performs configuration of this controller from the given &lt;var&gt;attrs&lt;/var&gt;.
	 *
	 * @param context      Context used to obtain values for the given attributes.
	 * @param attrs        Set of attributes with values to be used to set up this controller.
	 * @param defStyleAttr An attribute which contains a reference to a default style resource, for
	 *                     the view attached to this controller, within a theme of the given context.
	 * @param defStyleRes  Resource id of the default style for the view attached to this controller.
	 * @return {@code True} if some setting of this controller has been changed, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;ResourceType&quot;)
	public boolean setUpFromAttrs(@NonNull Context context, AttributeSet attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
<span class="nc" id="L204">		final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.Ui_PullController, defStyleAttr, defStyleRes);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (typedArray != null) {</span>
<span class="nc" id="L206">			this.ensurePullHelper();</span>
<span class="nc" id="L207">			final int n = typedArray.getIndexCount();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">			for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L209">				final int index = typedArray.getIndex(i);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">				if (index == R.styleable.Ui_PullController_uiPullMode) {</span>
<span class="nc" id="L211">					setPullMode(typedArray.getInteger(index, mPullHelper.getPullMode()));</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_PullController_uiPullMinVelocity) {</span>
<span class="nc" id="L213">					setPullMinVelocity(typedArray.getFloat(index, getPullMinVelocity()));</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_PullController_uiPullDistanceFraction) {</span>
<span class="nc" id="L215">					setPullDistanceFraction(typedArray.getFloat(index, getPullDistanceFraction()));</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_PullController_uiPullDistance) {</span>
<span class="nc" id="L217">					setPullDistance(typedArray.getDimensionPixelSize(index, (int) getPullDistance()));</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_PullController_uiPullCollapseDuration) {</span>
<span class="nc" id="L219">					setPullCollapseDuration(typedArray.getInt(index, (int) mAnimations.pullCollapseDuration));</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_PullController_uiPullCollapseDelay) {</span>
<span class="nc" id="L221">					setPullCollapseDelay(typedArray.getInt(index, (int) mAnimations.pullCollapseDelay));</span>
				}
			}
<span class="nc" id="L224">			typedArray.recycle();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">			return n &gt; 0;</span>
		}
<span class="nc" id="L227">		return false;</span>
	}

	/**
	 * Sets the mode for pull to determine which pull to handle by this controller.
	 *
	 * @param mode The desired mode. One of {@link #START}, {@link #END} or theirs combination or
	 *             {@link #NONE} to disable pull.
	 * @see R.attr#uiPullMode ui:uiPullMode
	 * @see #getPullMode()
	 */
	public void setPullMode(@PullFlags int mode) {
<span class="nc" id="L239">		this.ensurePullHelper();</span>
<span class="nc" id="L240">		mPullHelper.setPullMode(mode);</span>
<span class="nc" id="L241">	}</span>

	/**
	 * Returns the current mode for pull.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #START} | {@link #END}&lt;/b&gt;
	 *
	 * @return Pull mode.
	 * @see #setPullMode(int)
	 */
	@PullFlags
	@SuppressWarnings(&quot;ResourceType&quot;)
	public int getPullMode() {
<span class="nc" id="L254">		this.ensurePullHelper();</span>
<span class="nc" id="L255">		return mPullHelper.getPullMode();</span>
	}

	/**
	 * Sets a flag indicating whether a pull for the specified &lt;var&gt;pull&lt;/var&gt; flags should be visible
	 * or not. This determines whether the attached pullable view should be really offset by this
	 * controller or not. If visibility is set to {@code false} for a specific pull, the pullable view
	 * will not be offset but pull callbacks will be still fired with computed pull value.
	 *
	 * @param pull    The pull flags of which visibility to set.
	 * @param visible {@code True} to set visible, {@code false} otherwise.
	 * @see #isPullVisible(int)
	 */
	public void setPullVisibility(@PullFlags int pull, boolean visible) {
<span class="nc" id="L269">		this.ensurePullHelper();</span>
<span class="nc" id="L270">		mPullHelper.setPullVisibility(pull, visible);</span>
<span class="nc" id="L271">	}</span>

	/**
	 * Returns a flag indicating whether a pull for the specified &lt;var&gt;pull&lt;/var&gt; flags is visible,
	 * so the pullable view is really offset by this controller, or not.
	 *
	 * @param pull The pull flags of which visibility to check.
	 * @return {@code True} if pull is visible, {@code false} otherwise.
	 * @see #setPullVisibility(int, boolean)
	 */
	public boolean isPullVisible(@PullFlags int pull) {
<span class="nc" id="L282">		this.ensurePullHelper();</span>
<span class="nc" id="L283">		return mPullHelper.isPullVisible(pull);</span>
	}

	/**
	 * Sets the interpolator for pull collapse animation.
	 *
	 * @param interpolator The desired interpolator used when collapsing pull by animation.
	 */
	public void setPullCollapseInterpolator(@Nullable Interpolator interpolator) {
<span class="nc" id="L292">		mAnimations.interpolator = interpolator;</span>
<span class="nc" id="L293">	}</span>

	/**
	 * Sets the duration for pull collapse animation.
	 *
	 * @param duration The desired duration in milliseconds used when collapsing pull by animation.
	 * @see R.attr#uiPullCollapseDuration ui:uiPullCollapseDuration
	 * @see #getPullCollapseDuration()
	 */
	public void setPullCollapseDuration(long duration) {
<span class="nc" id="L303">		mAnimations.pullCollapseDuration = Math.max(0, duration);</span>
<span class="nc" id="L304">	}</span>

	/**
	 * Returns the duration for pull collapse animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;300 ms&lt;/b&gt;
	 *
	 * @return Collapse duration in milliseconds.
	 * @see #setPullCollapseDuration(long)
	 */
	public long getPullCollapseDuration() {
<span class="nc" id="L315">		return mAnimations.pullCollapseDuration;</span>
	}

	/**
	 * Sets the delay for pull collapse animation.
	 *
	 * @param delay The desired delay in milliseconds used when collapsing pull by animation.
	 * @see R.attr#uiPullCollapseDelay ui:uiPullCollapseDelay
	 * @see #getPullCollapseDelay()
	 */
	public void setPullCollapseDelay(long delay) {
<span class="nc" id="L326">		mAnimations.pullCollapseDelay = Math.max(0, delay);</span>
<span class="nc" id="L327">	}</span>

	/**
	 * Returns the delay for pull collapse animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;0&lt;/b&gt;
	 *
	 * @return Collapse delay in milliseconds.
	 * @see #setPullCollapseDelay(long)
	 */
	public long getPullCollapseDelay() {
<span class="nc" id="L338">		return mAnimations.pullCollapseDelay;</span>
	}

	/**
	 * Sets a flag indicating whether the duration for pull collapse animation set by {@link #setPullCollapseDuration(long)}
	 * should be used as fixed value or if it should be computed relatively to the distance of the
	 * current pull needed to collapse by animation.
	 *
	 * @param enabled {@code True} to use fixed value, {@code false} to use relative value depends
	 *                on the current pull to collapse.
	 * @see #isPullCollapseFixedTimeEnabled()
	 */
	public void setPullCollapseFixedDurationEnabled(boolean enabled) {
<span class="nc" id="L351">		updatePrivateFlags(PFLAG_PULL_COLLAPSE_FIXED_TIME_ENABLED, enabled);</span>
<span class="nc" id="L352">	}</span>

	/**
	 * Returns a flag indicating whether the duration set by {@link #setPullCollapseDuration(long)}
	 * is used as fixed value or relative value.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;false&lt;/b&gt;
	 *
	 * @return {@code True} if it is used as fixed, {@code false} as relative value.
	 */
	public boolean isPullCollapseFixedTimeEnabled() {
<span class="nc" id="L363">		return hasPrivateFlag(PFLAG_PULL_COLLAPSE_FIXED_TIME_ENABLED);</span>
	}

	/**
	 * Sets a flag indicating whether the over-scroll animation is played whenever the attached
	 * pullable view is over-scrolled, and specific criteria to play the animation are matched, or not.
	 *
	 * @param enabled {@code True} to play over-scroll animation whenever {@link #dispatchOverScroll(int, int, boolean, boolean)}
	 *                is called upon this controller from the attached pullable view, {@code false}
	 *                otherwise.
	 * @see #isOverScrollAnimationEnabled()
	 */
	public void setOverScrollAnimationEnabled(boolean enabled) {
<span class="nc" id="L376">		updatePrivateFlags(PFLAG_OVER_SCROLL_ANIMATION_ENABLED, enabled);</span>
<span class="nc" id="L377">	}</span>

	/**
	 * Returns a flag indicating whether the over-scroll animation is played for the attached pullable
	 * view over-scroll or not.
	 *
	 * @return {@code True} if the animation is played, {@code false} otherwise.
	 * @see #setOverScrollAnimationEnabled(boolean)
	 */
	public boolean isOverScrollAnimationEnabled() {
<span class="nc" id="L387">		return hasPrivateFlag(PFLAG_OVER_SCROLL_ANIMATION_ENABLED);</span>
	}

	/**
	 * Registers a callback to be invoked whenever the pull upon the attached pullable view is &lt;b&gt;started&lt;/b&gt;,
	 * &lt;b&gt;performed&lt;/b&gt;, &lt;b&gt;released&lt;/b&gt; or &lt;b&gt;collapsed&lt;/b&gt;.
	 *
	 * @param listener Listener callback to register.
	 * @see #unregisterOnPullListener(Pullable.OnPullListener)
	 */
	public void registerOnPullListener(@NonNull Pullable.OnPullListener listener) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">		if (mListeners == null) this.mListeners = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		if (!mListeners.contains(listener)) mListeners.add(listener);</span>
<span class="nc" id="L400">	}</span>

	/**
	 * Un-registers previously registered OnPullListener listener.
	 *
	 * @param listener Listener callback to un-register.
	 * @see #registerOnPullListener(Pullable.OnPullListener)
	 */
	public void unregisterOnPullListener(@NonNull Pullable.OnPullListener listener) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (mListeners != null) mListeners.remove(listener);</span>
<span class="nc" id="L410">	}</span>

	/**
	 * Registers a callback to be invoked whenever the pull overflow upon the attached pullable view
	 * is &lt;b&gt;performed&lt;/b&gt;.
	 *
	 * @param listener Listener callback to register.
	 * @see #unregisterOnPullOverflowListener(Pullable.OnPullOverflowListener)
	 */
	public void registerOnPullOverflowListener(@NonNull Pullable.OnPullOverflowListener listener) {
<span class="nc bnc" id="L420" title="All 2 branches missed.">		if (mOverflowListeners == null) this.mOverflowListeners = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (!mOverflowListeners.contains(listener)) mOverflowListeners.add(listener);</span>
<span class="nc" id="L422">	}</span>

	/**
	 * Un-registers previously registered OnPullOverflowListener listener.
	 *
	 * @param listener Listener callback to un-register.
	 * @see #registerOnPullOverflowListener(Pullable.OnPullOverflowListener)
	 */
	public void unregisterOnPullOverflowListener(@NonNull Pullable.OnPullOverflowListener listener) {
<span class="nc bnc" id="L431" title="All 2 branches missed.">		if (mOverflowListeners != null) mOverflowListeners.remove(listener);</span>
<span class="nc" id="L432">	}</span>

	/**
	 */
	@Override
	public boolean shouldInterceptTouchEvent(@NonNull MotionEvent event) {
<span class="nc bnc" id="L438" title="All 4 branches missed.">		return isPullEnabled() &amp;&amp; super.shouldInterceptTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	public boolean processTouchEvent(@NonNull MotionEvent event) {
<span class="nc bnc" id="L445" title="All 4 branches missed.">		return isPullEnabled() &amp;&amp; super.processTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	void onPullHelperChanged(PullHelper helper) {
<span class="nc" id="L452">		super.onPullHelperChanged(helper);</span>
<span class="nc" id="L453">		mAnimations.onTargetsChanged(this);</span>
<span class="nc" id="L454">	}</span>

	/**
	 * Returns boolean flag indicating whether the pull handling is enabled or not.
	 *
	 * @return {@code True} if pull is enabled, {@code false} otherwise.
	 */
	private boolean isPullEnabled() {
<span class="nc" id="L462">		this.ensurePullHelper();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">		return mPullHelper.getPullMode() != NONE;</span>
	}

	/**
	 */
	@Override
	protected void onPullStarted() {
<span class="nc" id="L470">		super.onPullStarted();</span>
<span class="nc bnc" id="L471" title="All 4 branches missed.">		if (mListeners != null &amp;&amp; !mListeners.isEmpty()) {</span>
<span class="nc" id="L472">			final PullImpl pull = PULL.clone();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">			for (Pullable.OnPullListener listener : mListeners) {</span>
<span class="nc" id="L474">				listener.onPullStarted(mView, pull);</span>
<span class="nc" id="L475">			}</span>
		}
<span class="nc" id="L477">	}</span>

	/**
	 */
	@Override
	protected void onApplyPull(int pull, float position) {
<span class="nc" id="L483">		super.onApplyPull(pull, position);</span>
<span class="nc" id="L484">		PULL.position = position;</span>
<span class="nc" id="L485">		this.notifyPull();</span>
<span class="nc" id="L486">	}</span>

	/**
	 * Notifies the current listeners that the pull has been performed.
	 */
	final void notifyPull() {
<span class="nc bnc" id="L492" title="All 4 branches missed.">		if (mListeners != null &amp;&amp; !mListeners.isEmpty()) {</span>
<span class="nc" id="L493">			final PullImpl pull = PULL.clone();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">			for (Pullable.OnPullListener listener : mListeners) {</span>
<span class="nc" id="L495">				listener.onPull(mView, pull);</span>
<span class="nc" id="L496">			}</span>
		}
<span class="nc" id="L498">	}</span>

	/**
	 */
	@Override
	protected void onPullOverflow(float pull, float overflow, float position) {
<span class="nc" id="L504">		super.onPullOverflow(pull, overflow, position);</span>
<span class="nc" id="L505">		PULL.pullOverflowPosition = position;</span>
<span class="nc bnc" id="L506" title="All 4 branches missed.">		if (mOverflowListeners != null &amp;&amp; !mOverflowListeners.isEmpty()) {</span>
<span class="nc" id="L507">			final PullImpl currentPull = PULL.clone();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">			for (Pullable.OnPullOverflowListener listener : mOverflowListeners) {</span>
<span class="nc" id="L509">				listener.onPullOverflow(mView, currentPull);</span>
<span class="nc" id="L510">			}</span>
		}
<span class="nc" id="L512">	}</span>

	/**
	 */
	@Override
	protected void onPullReleased(float pull, float position) {
<span class="nc" id="L518">		super.onPullReleased(pull, position);</span>
<span class="nc bnc" id="L519" title="All 4 branches missed.">		if (mListeners != null &amp;&amp; !mListeners.isEmpty()) {</span>
<span class="nc" id="L520">			final PullImpl currentPull = PULL.clone();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			for (Pullable.OnPullListener listener : mListeners) {</span>
<span class="nc" id="L522">				listener.onPullReleased(mView, currentPull);</span>
<span class="nc" id="L523">			}</span>
		}
<span class="nc" id="L525">	}</span>

	/**
	 */
	@Override
	protected void onCollapsePull(float pull, float position) {
<span class="nc" id="L531">		mAnimations.cancel();</span>
<span class="nc" id="L532">		mAnimations.collapsePull(pull);</span>
<span class="nc" id="L533">	}</span>

	/**
	 */
	@Override
	protected void onPullCollapsed() {
<span class="nc" id="L539">		super.onPullCollapsed();</span>
<span class="nc" id="L540">		PULL.collapsing = false;</span>
<span class="nc" id="L541">		PULL.position = 0;</span>
<span class="nc" id="L542">		PULL.pullOverflowPosition = 0;</span>
<span class="nc bnc" id="L543" title="All 4 branches missed.">		if (mListeners != null &amp;&amp; !mListeners.isEmpty()) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">			for (Pullable.OnPullListener listener : mListeners) {</span>
<span class="nc" id="L545">				listener.onPullCollapsed(mView);</span>
<span class="nc" id="L546">			}</span>
		}
<span class="nc" id="L548">	}</span>

	/**
	 * Called to dispatch over-scroll of the attached pullable view. If the pull is enabled and also
	 * pull over-scroll animation is enabled by {@link #setOverScrollAnimationEnabled(boolean)}, this
	 * will run over-scroll animation upon the pullable view which will look like same as the pull
	 * performed by a user.
	 *
	 * @param scrollX  Current scroll X of the pullable view.
	 * @param scrollY  Current scroll Y of the pullable view.
	 * @param clampedX {@code True} if &lt;var&gt;scrollX&lt;/var&gt; was clamped to an over-scroll boundary,
	 *                 {@code false} otherwise.
	 * @param clampedY {@code True} if &lt;var&gt;scrollY&lt;/var&gt; was clamped to an over-scroll boundary,
	 *                 {@code false} otherwise.
	 * @return {@code True} if over-scroll animation has been started, {@code false} otherwise.
	 */
	public boolean dispatchOverScroll(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {
<span class="nc bnc" id="L565" title="All 4 branches missed.">		if (!isPullEnabled() || !hasPrivateFlag(PFLAG_OVER_SCROLL_ANIMATION_ENABLED)) {</span>
<span class="nc" id="L566">			return false;</span>
		}

<span class="nc" id="L569">		final float overScroll = mPullHelper.computeOverScroll(scrollX, scrollY, clampedX, clampedY, VELOCITY_TRACKER, UiConfig.VELOCITY_UNITS);</span>
<span class="nc" id="L570">		final float absOverScroll = Math.abs(overScroll);</span>
<span class="nc bnc" id="L571" title="All 4 branches missed.">		if (absOverScroll &gt; 0 &amp;&amp; !mAnimations.isRunning()) {</span>
<span class="nc" id="L572">			mAnimations.mimicOverScroll(absOverScroll);</span>
<span class="nc" id="L573">			return true;</span>
		}
<span class="nc" id="L575">		return false;</span>
	}

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Class used to hold data about the current pull handled by {@link PullController}.
	 *
	 * @author Martin Albedinsky
	 */
	private final class PullImpl implements Pullable.Pull, Cloneable {

		/**
		 * Current position of the pull.
		 */
		float position;

		/**
		 * Current position of the pull overflow.
		 */
		float pullOverflowPosition;

		/**
		 * Flag indicating whether pull is being collapsing by animation or not.
		 */
		boolean collapsing;

		/**
		 * Creates a new instance of empty Pull.
		 */
<span class="nc" id="L607">		private PullImpl() {</span>
<span class="nc" id="L608">		}</span>

		/**
		 */
		@Override
		public float getPosition() {
<span class="nc" id="L614">			return position;</span>
		}

		/**
		 */
		@Override
		public float getPullOverflowPosition() {
<span class="nc" id="L621">			return pullOverflowPosition;</span>
		}

		/**
		 */
		@Override
		public boolean collapse() {
<span class="nc bnc" id="L628" title="All 2 branches missed.">			if (!collapsing) {</span>
<span class="nc" id="L629">				this.collapsing = true;</span>
<span class="nc" id="L630">				collapsePull();</span>
<span class="nc" id="L631">				return true;</span>
			}
<span class="nc" id="L633">			return false;</span>
		}

		/**
		 */
		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		protected PullImpl clone() {
			try {
<span class="nc" id="L642">				return (PullImpl) super.clone();</span>
<span class="nc" id="L643">			} catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L644">				throw new AssertionError();</span>
			}
		}
	}

	/**
	 * Animations interface for this controller.
	 */
	private static abstract class Animations {

		/**
		 * Pull controller for which to run animations.
		 */
		final PullController controller;

		/**
		 * Duration for the pull collapse animation. The pull collapse animation is played when the current
		 * pull is released by a user to move pullable view to its original offset.
		 */
<span class="nc" id="L663">		long pullCollapseDuration = PULL_COLLAPSE_DURATION;</span>

		/**
		 * Delay for the pull collapse animation.
		 */
		long pullCollapseDelay;

		/**
		 * Interpolator used to interpolate animated pull value.
		 */
<span class="nc" id="L673">		Interpolator interpolator = new DecelerateInterpolator();</span>

		/**
		 * Creates a new instance of Animations interface for the specified pull &lt;var&gt;controller&lt;/var&gt;.
		 *
		 * @param controller The pull controller for which to run animations.
		 */
<span class="nc" id="L680">		Animations(PullController controller) {</span>
<span class="nc" id="L681">			this.controller = controller;</span>
<span class="nc" id="L682">		}</span>

		/**
		 * Returns a new instance of Animations implementation specific for the current animations
		 * API capabilities.
		 *
		 * @param controller The pull controller upon which will the returned Animations object run
		 *                   all requested animations.
		 * @return New instance of Animations implementation.
		 */
		static Animations get(PullController controller) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">			return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ?</span>
					new HoneyCombAnimations(controller) :
					new DefaultAnimations(controller);
		}

		/**
		 * Called whenever some of animation targets has changed so they should be reattached to
		 * theirs animators.
		 *
		 * @param controller The pull controller that uses these animations.
		 */
		void onTargetsChanged(PullController controller) {
<span class="nc" id="L705">		}</span>

		/**
		 * Starts animation to collapse current pull.
		 *
		 * @param pull The desired pull value from which to run collapse animation.
		 */
		abstract void collapsePull(float pull);

		/**
		 * Starts animation to mimic over scroll behaviour with the specified &lt;var&gt;overScroll&lt;/var&gt;
		 * value.
		 *
		 * @param overScroll The desired over scroll value.
		 */
		abstract void mimicOverScroll(float overScroll);

		/**
		 * Returns boolean flag indicating whether this wrapper is running some animations or not.
		 *
		 * @return {@code True} if some animations are running, {@code false} otherwise.
		 */
		boolean isRunning() {
<span class="nc" id="L728">			return false;</span>
		}

		/**
		 * Cancels all running animations.
		 */
		void cancel() {
<span class="nc" id="L735">		}</span>
	}

	/**
	 * Default implementation of {@link Animations}.
	 */
	private static final class DefaultAnimations extends Animations {

		/**
		 * Runnable action used to schedule execution of {@link #handlePullCollapsed()}.
		 */
<span class="nc" id="L746">		private final Runnable HANDLE_PULL_COLLAPSED = new Runnable() {</span>
			@Override
			public void run() {
<span class="nc" id="L749">				controller.handlePullCollapsed();</span>
<span class="nc" id="L750">			}</span>
		};

		/**
		 * Creates a new instance of DefaultAnimations for the specified pull &lt;var&gt;controller&lt;/var&gt;.
		 */
		DefaultAnimations(PullController controller) {
<span class="nc" id="L757">			super(controller);</span>
<span class="nc" id="L758">		}</span>

		/**
		 */
		@Override
		void collapsePull(float pull) {
			// We do not run any animation, just handle like if we did and animation did ended.
<span class="nc" id="L765">			controller.postDelayed(HANDLE_PULL_COLLAPSED, 50);</span>
<span class="nc" id="L766">		}</span>

		/**
		 */
		@Override
		void mimicOverScroll(float overScroll) {
			// Ignored.
<span class="nc" id="L773">		}</span>
	}

	/**
	 * A {@link Animations} implementation used on Android versions above (including) {@link Build.VERSION_CODES#HONEYCOMB}.
	 */
	@TargetApi(Build.VERSION_CODES.HONEYCOMB)
	private static final class HoneyCombAnimations extends Animations {

		/**
		 * Animator used to animate pull.
		 */
<span class="nc" id="L785">		private final ObjectAnimator PULL_ANIMATOR = ObjectAnimator.ofInt(this, &quot;pullOffset&quot;, 0, 0);</span>

		{
<span class="nc" id="L788">			PULL_ANIMATOR.addListener(new AnimatorListenerAdapter() {</span>

				/**
				 */
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc" id="L794">					controller.mPullHelper.mPullOffset = (int) PULL_ANIMATOR.getAnimatedValue();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">					if (controller.mPullHelper.mPullOffset == 0) {</span>
<span class="nc" id="L796">						controller.handlePullCollapsed();</span>
					}
<span class="nc" id="L798">				}</span>
			});
<span class="nc" id="L800">			PULL_ANIMATOR.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {</span>

				/**
				 */
				@Override
				public void onAnimationUpdate(ValueAnimator animation) {
<span class="nc" id="L806">					controller.notifyPull();</span>
<span class="nc" id="L807">				}</span>
			});
		}

		/**
		 * Runnable used to start animation to mimic over-scroll.
		 */
		private final CollapseOverScrollAction mimicOverScroll;

		/**
		 * Creates a new instance of HoneyCombAnimations for the specified pull &lt;var&gt;controller&lt;/var&gt;.
		 */
		HoneyCombAnimations(PullController controller) {
<span class="nc" id="L820">			super(controller);</span>
<span class="nc" id="L821">			this.mimicOverScroll = new CollapseOverScrollAction(this);</span>
<span class="nc" id="L822">			onTargetsChanged(controller);</span>
<span class="nc" id="L823">		}</span>

		/**
		 */
		@Override
		void onTargetsChanged(PullController controller) {
<span class="nc" id="L829">			super.onTargetsChanged(controller);</span>
<span class="nc" id="L830">			PULL_ANIMATOR.setTarget(controller.mPullHelper);</span>
<span class="nc" id="L831">		}</span>

		/**
		 */
		@Override
		void collapsePull(float pull) {
<span class="nc" id="L837">			PULL_ANIMATOR.setIntValues((int) pull, 0);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">			PULL_ANIMATOR.setDuration(controller.hasPrivateFlag(PFLAG_PULL_COLLAPSE_FIXED_TIME_ENABLED) ?</span>
					pullCollapseDuration :
<span class="nc" id="L840">					Math.round(pullCollapseDuration * (Math.abs(pull) / controller.mPullDistance))</span>
			);
<span class="nc" id="L842">			PULL_ANIMATOR.setStartDelay(pullCollapseDelay);</span>
<span class="nc" id="L843">			PULL_ANIMATOR.setInterpolator(interpolator);</span>
<span class="nc" id="L844">			PULL_ANIMATOR.start();</span>
<span class="nc" id="L845">		}</span>

		/**
		 */
		@Override
		void mimicOverScroll(float overScroll) {
<span class="nc" id="L851">			final int duration = Math.round(overScroll);</span>
<span class="nc" id="L852">			PULL_ANIMATOR.setIntValues(0, (int) overScroll);</span>
<span class="nc" id="L853">			PULL_ANIMATOR.setDuration(duration);</span>
<span class="nc" id="L854">			PULL_ANIMATOR.setInterpolator(interpolator);</span>
<span class="nc" id="L855">			mimicOverScroll.overScroll = overScroll;</span>
<span class="nc" id="L856">			controller.postDelayed(mimicOverScroll, duration);</span>
<span class="nc" id="L857">			PULL_ANIMATOR.start();</span>
<span class="nc" id="L858">		}</span>

		/**
		 */
		@Override
		boolean isRunning() {
<span class="nc" id="L864">			return PULL_ANIMATOR.isRunning();</span>
		}

		/**
		 */
		@Override
		void cancel() {
<span class="nc" id="L871">			PULL_ANIMATOR.cancel();</span>
<span class="nc" id="L872">		}</span>
	}

	/**
	 * Action used to collapse the current over-scroll.
	 */
	private static class CollapseOverScrollAction implements Runnable {

		/**
		 * Animations used to mimic over-scroll.
		 */
		final Animations animations;

		/**
		 * Value of the over-scroll to collapse.
		 */
		float overScroll;

		/**
		 * Creates a new instance of CollapseOverScrollAction with the given &lt;var&gt;animations&lt;/var&gt;.
		 *
		 * @param animations Animations used to mimic over-scroll.
		 */
<span class="nc" id="L895">		CollapseOverScrollAction(Animations animations) {</span>
<span class="nc" id="L896">			this.animations = animations;</span>
<span class="nc" id="L897">		}</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L903">			animations.mimicOverScroll(overScroll);</span>
<span class="nc" id="L904">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>