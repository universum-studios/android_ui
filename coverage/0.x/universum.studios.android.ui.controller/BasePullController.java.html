<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BasePullController.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.controller</a> &gt; <span class="el_source">BasePullController.java</span></div><h1>BasePullController.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.controller;

import android.support.annotation.FloatRange;
import android.support.annotation.NonNull;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.animation.Interpolator;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.UiException;
import universum.studios.android.ui.interpolator.ResistanceInterpolator;
import universum.studios.android.ui.widget.Orientation;
import universum.studios.android.ui.widget.Scrollable;

/**
 * Base class for controllers that want to provide on pull gesture based features like &lt;b&gt;pull&lt;/b&gt;
 * or &lt;b&gt;refresh&lt;/b&gt;.
 *
 * @param &lt;V&gt; Type of the pullable view.
 * @author Martin Albedinsky
 */
abstract class BasePullController&lt;V extends View &amp; Scrollable&gt; {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Interface used to transform computed pull value for the current pull position. Transformer
	 * can use for example implementation of {@link android.view.animation.Interpolator} to simulate
	 * pull based on a specific curve.
	 *
	 * @author Martin Albedinsky
	 */
	public interface PullTransformer {

		/**
		 * Called to transform pull offset for the specified position.
		 *
		 * @param offset   Computed offset by {@link BasePullController} as delta from the last and
		 *                 current touch event.
		 * @param position Position of the current pull depending on the current value of pull and
		 *                 maximum pull distance.
		 * @return Transformed pull offset to be used by the controller.
		 */
		float transform(float offset, float position);
	}

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;BasePullController&quot;;

	/**
	 * State indicating that no actions are currently handled by this controller.
	 */
	private static final int STATE_IDLE = 0x00;

	/**
	 * State indicating that the pullable view is being scrolled at this time.
	 */
	private static final int STATE_SCROLLING = 0x01;

	/**
	 * State indicating that this controller is ready to start pulling process.
	 */
	private static final int STATE_READY_TO_PULL = 0x02;

	/**
	 * State indicating that this controller is performing pull upon the pullable view by offsetting
	 * its start/end position.
	 */
	private static final int STATE_PULLING = 0x03;

	/**
	 * State indicating that the current pull has been released by a user.
	 */
	private static final int STATE_RELEASED = 0x04;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * View of which pull will be managed by this controller.
	 */
	final V mView;

	/**
	 * Helper used to apply pull to the attached pullable view.
	 */
	PullHelper mPullHelper;

	/**
	 * Distance determining how much pull can be applied to the attached view.
	 */
	float mPullDistance;

	/**
	 * Fraction determining value of {@link #mPullDistance} from the size of the attached view.
	 */
<span class="nc" id="L130">	float mPullDistanceFraction = 0.25f;</span>

	/**
	 * Value of the current pull.
	 */
	float mPull;

	/**
	 * Value of the current pull overflow.
	 */
	float mPullOverflow;

	/**
	 * Tracker used to track velocity value to determine whether to initiate pull or not.
	 */
<span class="nc" id="L145">	private final VelocityTracker VELOCITY_TRACKER = VelocityTracker.obtain();</span>

	/**
	 * Set of private flags for this controller.
	 */
	private int mPrivateFlags;

	/**
	 * Current state of this controller determining its pull handling.
	 */
<span class="nc" id="L155">	private int mState = STATE_IDLE;</span>

	/**
	 * Minimal velocity (in pixels per second) for pull to start.
	 */
	private float mPullMinVelocity;

	/**
	 * Helper used to transform computed value for the pull. This transformer can use {@link android.view.animation.Interpolator}
	 * to simulate pull based on specific curve.
	 */
<span class="nc" id="L166">	private PullTransformer mPullTransformer = new PullTransformerImpl();</span>

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of BasePullController with the specified &lt;var&gt;view&lt;/var&gt; attached.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that only views with {@link Orientation#VERTICAL}, {@link Orientation#HORIZONTAL}
	 * orientation are supported.
	 *
	 * @param view The view of which pull should be managed by the new controller.
	 * @see Scrollable#getOrientation()
	 */
<span class="nc" id="L181">	protected BasePullController(@NonNull V view) {</span>
<span class="nc" id="L182">		this.mView = view;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">		switch (mView.getOrientation()) {</span>
			case Orientation.VERTICAL:
			case Orientation.HORIZONTAL:
<span class="nc" id="L186">				break;</span>
			default:
<span class="nc" id="L188">				throw UiException.misconfiguration(&quot;Only views with VERTICAL | HORIZONTAL orientation are supported.&quot;);</span>
		}
<span class="nc" id="L190">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Sets the minimum velocity to initiate pull.
	 *
	 * @param velocity The desired velocity value for {@link UiConfig#VELOCITY_UNITS} units.
	 * @see R.attr#uiPullMinVelocity ui:uiPullMinVelocity
	 * @see #getPullMinVelocity()
	 */
	public void setPullMinVelocity(float velocity) {
<span class="nc" id="L204">		this.mPullMinVelocity = Math.max(0, velocity);</span>
<span class="nc" id="L205">	}</span>

	/**
	 * Returns the minimum velocity to initiate pull.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;0&lt;/b&gt;
	 *
	 * @return Minimum velocity.
	 * @see #setPullMinVelocity(float)
	 */
	public float getPullMinVelocity() {
<span class="nc" id="L216">		return mPullMinVelocity;</span>
	}

	/**
	 * Sets the distance which determines how much can be the attached view pulled.
	 *
	 * @param distance The desired value in pixels to determine maximum pull distance.
	 * @see R.attr#uiPullDistance ui:uiPullDistance
	 * @see #getPullDistance()
	 * @see #setPullDistanceFraction(float)
	 */
	public void setPullDistance(float distance) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (mPullDistance != distance) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">			if ((mPullDistance = Math.max(0, distance)) &gt; 0) {</span>
<span class="nc" id="L230">				this.mPullDistanceFraction = 0;</span>
<span class="nc" id="L231">				this.ensurePullDistance();</span>
			}
		}
<span class="nc" id="L234">	}</span>

	/**
	 * Returns the value of the maximum pull distance.
	 * &lt;p&gt;
	 * Default value: see {@link #getPullDistanceFraction()}
	 *
	 * @return Maximum pull distance in pixels or {@code -1} if the pull distance cannot be right now
	 * resolved due to not initialized size of the attached view yet.
	 * @see #setPullDistance(float)
	 */
	public float getPullDistance() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">		return ensurePullDistance() ? mPullDistance : -1;</span>
	}

	/**
	 * Sets the fraction for the maximum pull distance which determines how much can be the attached
	 * view pulled. The specified fraction will be used to compute maximum pull distance from the
	 * size of the view.
	 *
	 * @param fraction The desired fraction from the range {@code [0, 1f]}.
	 * @see R.attr#uiPullDistanceFraction ui:uiPullDistanceFraction
	 * @see #getPullDistanceFraction()
	 * @see #setPullDistance(float)
	 */
	public void setPullDistanceFraction(@FloatRange(from = 0, to = 1) float fraction) {
<span class="nc bnc" id="L260" title="All 6 branches missed.">		if (mPullDistanceFraction != fraction &amp;&amp; fraction &gt;= 0 &amp;&amp; fraction &lt;= 1) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if ((mPullDistanceFraction = fraction) &gt; 0) {</span>
<span class="nc" id="L262">				this.mPullDistance = 0;</span>
<span class="nc" id="L263">				this.ensurePullDistance();</span>
			}
		}
<span class="nc" id="L266">	}</span>

	/**
	 * Returns the fraction used to compute maximum pull distance.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;0.25f&lt;/b&gt;
	 *
	 * @return Pull fraction from the range {@code [0, 1f]}.
	 * @see #setPullDistanceFraction(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getPullDistanceFraction() {
<span class="nc" id="L278">		return mPullDistanceFraction;</span>
	}

	/**
	 * Ensures that {@link #mPullDistance} is properly initialized.
	 *
	 * @return {@code True} if pull distance has been resolved, {@code false} otherwise.
	 */
	private boolean ensurePullDistance() {
<span class="nc" id="L287">		this.ensurePullHelper();</span>
<span class="nc" id="L288">		final int pullableSize = mPullHelper.getViewSize();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">		if (pullableSize &gt; 0) {</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">			if (mPullDistance &lt;= 0 &amp;&amp; mPullDistanceFraction &gt; 0) {</span>
<span class="nc" id="L291">				this.mPullDistance = Math.round(pullableSize * mPullDistanceFraction);</span>
			} else {
<span class="nc" id="L293">				this.mPullDistance = Math.min(mPullDistance, pullableSize);</span>
			}
<span class="nc" id="L295">			return true;</span>
		}
<span class="nc" id="L297">		return false;</span>
	}

	/**
	 * Sets the transformer used to transform computed value for the current pull.
	 *
	 * @param transformer The desired transformer.
	 * @see #getPullTransformer()
	 */
	public void setPullTransformer(@NonNull PullTransformer transformer) {
<span class="nc" id="L307">		this.mPullTransformer = transformer;</span>
<span class="nc" id="L308">	}</span>

	/**
	 * Returns the current pull transformer of this PullController.
	 * &lt;p&gt;
	 * By default, this controller uses transformer implementation with {@link universum.studios.android.ui.interpolator.ResistanceInterpolator}
	 * to transform computed pull offset value based on its current position.
	 *
	 * @return Pull transformer.
	 * @see #setPullTransformer(PullTransformer)
	 */
	@NonNull
	public PullTransformer getPullTransformer() {
<span class="nc" id="L321">		return mPullTransformer;</span>
	}

	/**
	 * Sets the interpolator for the default {@link PullTransformer} of this controller.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that this can be applied only in case, when there is still default pull transformer
	 * used. If there is custom transformer set, that transformer should handle interpolation logic.
	 *
	 * @param interpolator The desired interpolator for the current pull transformer.
	 */
	public void setPullTransformerInterpolator(@NonNull Interpolator interpolator) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">		if (mPullTransformer instanceof PullTransformerImpl) {</span>
<span class="nc" id="L334">			((PullTransformerImpl) mPullTransformer).interpolator = interpolator;</span>
		}
<span class="nc" id="L336">	}</span>

	/**
	 * Checks whether the attached view that received the specified motion &lt;var&gt;event&lt;/var&gt; should
	 * intercept the event or not.
	 *
	 * @param event The motion event used to determine if to intercept or not.
	 * @return {@code True} if the event should be intercepted by the attached view so it should
	 * return {@code true} from within its {@link android.view.ViewGroup#onInterceptTouchEvent(android.view.MotionEvent)},
	 * {@code false} otherwise.
	 */
	public boolean shouldInterceptTouchEvent(@NonNull MotionEvent event) {
<span class="nc" id="L348">		this.ensurePullHelper();</span>
<span class="nc bnc" id="L349" title="All 6 branches missed.">		return mState == STATE_PULLING &amp;&amp; (mPullHelper.isViewScrolledAtStart() || mPullHelper.isViewScrolledAtEnd());</span>
	}

	/**
	 * Processes the specified motion &lt;var&gt;event&lt;/var&gt; received by the attached view. Based on the
	 * data of the event, this controller will perform pull upon the view if appropriate.
	 *
	 * @param event The motion event to be processed.
	 * @return {@code True} if the event was processed so attached view should return {@code true}
	 * from within its {@link View#onTouchEvent(android.view.MotionEvent)}, {@code false} otherwise.
	 */
	public boolean processTouchEvent(@NonNull MotionEvent event) {
<span class="nc" id="L361">		VELOCITY_TRACKER.addMovement(event);</span>
<span class="nc" id="L362">		boolean processed = false;</span>
<span class="nc" id="L363">		this.ensurePullHelper();</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">		switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span>
			case MotionEvent.ACTION_DOWN:
<span class="nc bnc" id="L366" title="All 2 branches missed.">				if (mState == STATE_IDLE) {</span>
<span class="nc bnc" id="L367" title="All 6 branches missed.">					if (!mPullHelper.hasViewChildren() || (mPullHelper.isViewScrolledAtStart() || mPullHelper.isViewScrolledAtEnd())) {</span>
<span class="nc" id="L368">						this.mState = STATE_READY_TO_PULL;</span>
<span class="nc" id="L369">						mPullHelper.dispatchPullInitiated(event);</span>
					}
				}
				break;
			case MotionEvent.ACTION_MOVE:
<span class="nc" id="L374">				final boolean touchChanged = mPullHelper.hasTouchChanged(event);</span>
<span class="nc bnc" id="L375" title="All 5 branches missed.">				switch (mState) {</span>
					case STATE_IDLE:
<span class="nc" id="L377">						this.mState = STATE_SCROLLING;</span>
<span class="nc" id="L378">						break;</span>
					case STATE_SCROLLING:
<span class="nc bnc" id="L380" title="All 6 branches missed.">						if (!mPullHelper.hasViewChildren() || (mPullHelper.isViewScrolledAtStart() || mPullHelper.isViewScrolledAtEnd())) {</span>
<span class="nc" id="L381">							this.mState = STATE_READY_TO_PULL;</span>
<span class="nc" id="L382">							mPullHelper.dispatchPullInitiated(event);</span>
						} else {
							break;
						}
					case STATE_READY_TO_PULL:
<span class="nc bnc" id="L387" title="All 2 branches missed.">						if (mPullHelper.shouldStartPull(event)) {</span>
<span class="nc" id="L388">							VELOCITY_TRACKER.computeCurrentVelocity(UiConfig.VELOCITY_UNITS);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">							if (mPullHelper.isAllowedVelocity(VELOCITY_TRACKER, mPullMinVelocity)) {</span>
<span class="nc" id="L390">								this.mState = STATE_PULLING;</span>
<span class="nc" id="L391">								onPullStarted();</span>
							}
<span class="nc bnc" id="L393" title="All 2 branches missed.">						} else if (mPullHelper.shouldCancelPull(event)) {</span>
<span class="nc" id="L394">							this.mState = STATE_IDLE;</span>
						}
						break;
					case STATE_PULLING:
<span class="nc" id="L398">						final float pullOffset = mPullHelper.computePullOffset(event);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">						if (mPullHelper.shouldExpandPull(event)) {</span>
<span class="nc" id="L400">							processed = onExpandPullBy(pullOffset);</span>
<span class="nc bnc" id="L401" title="All 6 branches missed.">						} else if ((mPullHelper.shouldCollapsePull(event) &amp;&amp; onCollapsePullBy(pullOffset)) || !touchChanged) {</span>
<span class="nc" id="L402">							processed = true;</span>
						}
						break;
				}
<span class="nc bnc" id="L406" title="All 2 branches missed.">				if (mState != STATE_SCROLLING) {</span>
<span class="nc" id="L407">					mPullHelper.dispatchPullPerformed(event);</span>
				}
				break;
			case MotionEvent.ACTION_CANCEL:
			case MotionEvent.ACTION_UP:
<span class="nc" id="L412">				VELOCITY_TRACKER.computeCurrentVelocity(UiConfig.VELOCITY_UNITS);</span>
<span class="nc" id="L413">				mPullHelper.dispatchPullReleased(event);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">				if (mState == STATE_PULLING) {</span>
<span class="nc" id="L415">					onPullReleased(mPull, mPull / mPullDistance);</span>
				} else {
<span class="nc" id="L417">					this.mState = STATE_IDLE;</span>
				}
				break;
		}
<span class="nc" id="L421">		return processed;</span>
	}

	/**
	 * Ensures that the pull helper is initialized.
	 */
	final void ensurePullHelper() {
<span class="nc" id="L428">		ensurePullHelper(PullHelper.START | PullHelper.END);</span>
<span class="nc" id="L429">	}</span>

	/**
	 * Ensures that the pull helper is initialized with the specified &lt;var&gt;pullMode&lt;/var&gt; flags.
	 *
	 * @param pullMode The desired pull mode flags. One of {@link PullHelper#NONE}, {@link PullHelper#START},
	 *                 {@link PullHelper#END} or theirs combination.
	 */
	final void ensurePullHelper(int pullMode) {
<span class="nc" id="L438">		final int viewOrientation = mView.getOrientation();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (mPullHelper != null) {</span>
<span class="nc" id="L440">			boolean updatePullHelper = false;</span>
<span class="nc bnc" id="L441" title="All 3 branches missed.">			switch (viewOrientation) {</span>
				case Orientation.VERTICAL:
<span class="nc" id="L443">					updatePullHelper = mPullHelper instanceof HorizontalPullHelper;</span>
<span class="nc" id="L444">					break;</span>
				case Orientation.HORIZONTAL:
<span class="nc" id="L446">					updatePullHelper = mPullHelper instanceof VerticalPullHelper;</span>
					break;
			}

<span class="nc bnc" id="L450" title="All 2 branches missed.">			if (updatePullHelper) {</span>
<span class="nc" id="L451">				final int restorePullMode = mPullHelper.getPullMode();</span>
<span class="nc" id="L452">				this.mPullHelper = null;</span>
<span class="nc" id="L453">				this.ensurePullHelper(restorePullMode);</span>
			}
<span class="nc" id="L455">			return;</span>
		}
<span class="nc bnc" id="L457" title="All 2 branches missed.">		switch (viewOrientation) {</span>
			case Orientation.HORIZONTAL:
<span class="nc" id="L459">				this.mPullHelper = new HorizontalPullHelper(mView);</span>
<span class="nc" id="L460">				break;</span>
			default:
<span class="nc" id="L462">				this.mPullHelper = new VerticalPullHelper(mView);</span>
				break;
		}
<span class="nc" id="L465">		mPullHelper.setPullMode(pullMode);</span>
<span class="nc" id="L466">		onPullHelperChanged(mPullHelper);</span>


<span class="nc" id="L469">	}</span>

	/**
	 * Invoked whenever a new instance of PullHelper has been initialized for this controller.
	 *
	 * @param helper The new helper that will be used by this controller.
	 */
	void onPullHelperChanged(PullHelper helper) {
<span class="nc" id="L477">	}</span>

	/**
	 * Invoked from {@link #processTouchEvent(MotionEvent)} whenever there has been observed touch
	 * motion that initiated the pull gesture. This is basically motion event with &lt;b&gt;DOWN&lt;/b&gt; followed
	 * by &lt;b&gt;MOVE&lt;/b&gt; action.
	 */
	protected void onPullStarted() {
<span class="nc" id="L485">		this.ensurePullDistance();</span>
<span class="nc" id="L486">	}</span>

	/**
	 * Invoked from {@link #processTouchEvent(MotionEvent)} whenever there has been observed touch
	 * motion that should expand the current pull. This is basically motion event with &lt;b&gt;MOVE&lt;/b&gt;
	 * action directed from the pull origin.
	 * &lt;p&gt;
	 * Default implementation updates the current pull via {@link #pullBy(float)} method with the
	 * specified &lt;var&gt;offset&lt;/var&gt; and in case of pull overflow invokes {@link #onPullOverflow(float, float, float)}
	 * with the computed overflow and the current pull position.
	 *
	 * @param offset The offset by which to expand the current pull.
	 * @return Always {@code true}.
	 */
	protected boolean onExpandPullBy(float offset) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (Math.abs(mPull) &lt; mPullDistance) {</span>
<span class="nc" id="L502">			pullBy(offset);</span>
		} else {
<span class="nc" id="L504">			this.mPullOverflow += mPullTransformer.transform(offset, mPullOverflow / mPullDistance);</span>
<span class="nc" id="L505">			onPullOverflow(mPull, mPullOverflow, mPullOverflow / mPullDistance);</span>
		}
<span class="nc" id="L507">		return true;</span>
	}

	/**
	 * Invoked whenever {@link #onExpandPullBy(float)} is called and the current pull value is already
	 * equal to {@link #getPullDistance()} so the offset of the attached view is not being updated.
	 *
	 * @param pull     The current pull value. Equals to {@link #getPullDistance()}.
	 * @param overflow The new overflow value. With the value of pull this is the total distance pulled
	 *                 by a user.
	 * @param position The current pull position determined from the current pull + pull overflow and
	 *                 available pull distance.
	 */
	protected void onPullOverflow(float pull, float overflow, float position) {
<span class="nc" id="L521">	}</span>

	/**
	 * Invoked from {@link #processTouchEvent(MotionEvent)} whenever there has been observed touch
	 * motion that should collapse the current pull. This is basically motion event with &lt;b&gt;MOVE&lt;/b&gt;
	 * action directed to the pull origin.
	 * &lt;p&gt;
	 * Default implementation updates the current pull via {@link #pullBy(float)} method with the
	 * specified &lt;var&gt;offset&lt;/var&gt; and in case of collapsed pull invokes {@link #onPullCollapsed()}.
	 *
	 * @param offset The offset by which to collapse the current pull.
	 * @return {@code True} if there remained some pull to be collapsed yet, {@code false} otherwise.
	 */
	protected boolean onCollapsePullBy(float offset) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">		final boolean positive = mPull &gt; 0;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (Math.abs(mPull) &lt;= mPullDistance) {</span>
<span class="nc" id="L537">			this.mPullOverflow = 0;</span>
		}
<span class="nc" id="L539">		pullBy(offset);</span>
<span class="nc bnc" id="L540" title="All 8 branches missed.">		if ((mPull &gt; 0 &amp;&amp; !positive) || (mPull &lt; 0 &amp;&amp; positive)) {</span>
<span class="nc" id="L541">			this.mState = STATE_IDLE;</span>
<span class="nc" id="L542">			this.ensurePullHelper();</span>
<span class="nc" id="L543">			mPullHelper.dispatchPullCollapsed();</span>
<span class="nc" id="L544">			this.mPull = mPullOverflow = 0;</span>
<span class="nc" id="L545">			onPullCollapsed();</span>
<span class="nc" id="L546">			return false;</span>
		}
<span class="nc" id="L548">		return true;</span>
	}

	/**
	 * Performs pull by the given &lt;var&gt;offset&lt;/var&gt; using {@link universum.studios.android.ui.controller.PullHelper}
	 * implementation specific for orientation of the attached view.
	 *
	 * @param offset The offset by which to pull.
	 */
	protected final void pullBy(float offset) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">		if (offset != 0) {</span>
<span class="nc" id="L559">			setViewFrozen(true);</span>
<span class="nc" id="L560">			this.mPull += mPullTransformer.transform(offset, mPull / mPullDistance);</span>
<span class="nc" id="L561">			int nextPull = (int) mPull;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">			if (nextPull != mPullHelper.mPullOffset) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">				if (Math.abs(nextPull) &gt; mPullDistance) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">					nextPull = (int) (nextPull &gt; 0 ? mPullDistance : -mPullDistance);</span>
<span class="nc" id="L565">					this.mPull = nextPull;</span>
				}
<span class="nc" id="L567">				onApplyPull(nextPull, mPull / mPullDistance);</span>
			}
		}
<span class="nc" id="L570">	}</span>

	/**
	 * Invoked whenever {@link #pullBy(float)} is called with a &lt;b&gt;none zero&lt;/b&gt; &lt;var&gt;offset&lt;/var&gt;
	 * and the new computed pull offset is different from the current one.
	 * &lt;p&gt;
	 * Default implementation offsets the attached view at top/bottom or left/right depending on its
	 * orientation.
	 *
	 * @param pull     The pull offset to apply to the attached view.
	 * @param position New pull position determined from the new pull and available pull distance.
	 */
	protected void onApplyPull(int pull, float position) {
<span class="nc" id="L583">		this.ensurePullHelper();</span>
<span class="nc" id="L584">		mPullHelper.setPullOffset(pull);</span>
<span class="nc" id="L585">	}</span>

	/**
	 * Sets the attached view frozen/un-frozen so it cannot to respond to user touches while the pull
	 * is being performed.
	 *
	 * @param frozen {@code True} to froze (disable, set un-pressed) the view, {@code false} otherwise.
	 */
	protected void setViewFrozen(boolean frozen) {
<span class="nc bnc" id="L594" title="All 4 branches missed.">		if (frozen &amp;&amp; mView.isPressed()) {</span>
<span class="nc" id="L595">			mView.setPressed(false);</span>
		}
<span class="nc bnc" id="L597" title="All 2 branches missed.">		if (mView.isEnabled() == frozen) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">			mView.setEnabled(!frozen);</span>
		}
<span class="nc" id="L600">	}</span>

	/**
	 * Invoked whenever a user releases the attached view during the pull gesture.
	 * &lt;p&gt;
	 * Default implementation calls {@link #collapsePull()} but inherited controllers may for example
	 * start here animation to collapse the specified pull for better user experience.
	 *
	 * @param pull     Current pull value.
	 * @param position Current pull position determined from the current pull and available pull distance.
	 */
	protected void onPullReleased(float pull, float position) {
<span class="nc" id="L612">		collapsePull();</span>
<span class="nc" id="L613">	}</span>

	/**
	 * Collapses the current pull if there is any via {@link #onCollapsePull(float, float)} or notifies
	 * that the pull is already collapsed via {@link #onPullCollapsed()}.
	 */
	protected final void collapsePull() {
<span class="nc bnc" id="L620" title="All 2 branches missed.">		if (mPull != 0) {</span>
<span class="nc" id="L621">			this.mState = STATE_RELEASED;</span>
<span class="nc" id="L622">			onCollapsePull(mPull, mPull / mPullDistance);</span>
		} else {
<span class="nc" id="L624">			this.handlePullCollapsed();</span>
		}
<span class="nc" id="L626">	}</span>

	/**
	 * Invoked whenever {@link #collapsePull()} is called and there is currently some pull value to
	 * be collapsed.
	 *
	 * @param pull     Current pull value to collapse.
	 * @param position Current pull position determined from the current pull and available pull distance.
	 */
	protected void onCollapsePull(float pull, float position) {
<span class="nc" id="L636">		this.handlePullCollapsed();</span>
<span class="nc" id="L637">	}</span>

	/**
	 * Handles the state when the pull has been fully collapsed. Will also invoke {@link #onPullCollapsed()}.
	 */
	final void handlePullCollapsed() {
<span class="nc" id="L643">		this.mState = STATE_IDLE;</span>
<span class="nc" id="L644">		this.ensurePullHelper();</span>
<span class="nc" id="L645">		mPullHelper.dispatchPullCollapsed();</span>
<span class="nc" id="L646">		this.mPull = mPullOverflow = 0;</span>
<span class="nc" id="L647">		onPullCollapsed();</span>
<span class="nc" id="L648">	}</span>

	/**
	 * Invoked whenever {@link #handlePullCollapsed()} is called. In most cases this will be due to
	 * fact that value of the pull has been decreased to {@code 0}.
	 */
	protected void onPullCollapsed() {
<span class="nc" id="L655">		setViewFrozen(false);</span>
<span class="nc" id="L656">	}</span>

	/**
	 * Delegate method for {@link View#postDelayed(Runnable, long)} of the attached view.
	 */
	final void postDelayed(Runnable action, int delay) {
<span class="nc" id="L662">		mView.postDelayed(action, delay);</span>
<span class="nc" id="L663">	}</span>

	/**
	 * Updates the current private flags.
	 *
	 * @param flag Value of the desired flag to add/remove to/from the current private flags.
	 * @param add  Boolean flag indicating whether to add or remove the specified &lt;var&gt;flag&lt;/var&gt;.
	 */
	@SuppressWarnings(&quot;unused&quot;)
	void updatePrivateFlags(int flag, boolean add) {
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (add) this.mPrivateFlags |= flag;</span>
<span class="nc" id="L674">		else this.mPrivateFlags &amp;= ~flag;</span>
<span class="nc" id="L675">	}</span>

	/**
	 * Returns a boolean flag indicating whether the specified &lt;var&gt;flag&lt;/var&gt; is contained within
	 * the current private flags or not.
	 *
	 * @param flag Value of the flag to check.
	 * @return {@code True} if the requested flag is contained, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;unused&quot;)
	boolean hasPrivateFlag(int flag) {
<span class="nc bnc" id="L686" title="All 2 branches missed.">		return (mPrivateFlags &amp; flag) != 0;</span>
	}

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Default implementation of PullTransformer. This transformer uses {@link ResistanceInterpolator}
	 * to compute pull offset transformation.
	 */
<span class="nc" id="L697">	private static final class PullTransformerImpl implements PullTransformer {</span>

		/**
		 * Interpolator used when transforming pull offset.
		 */
<span class="nc" id="L702">		Interpolator interpolator = new ResistanceInterpolator();</span>

		/**
		 */
		@Override
		public float transform(float offset, float position) {
<span class="nc bnc" id="L708" title="All 2 branches missed.">			if (interpolator != null) {</span>
<span class="nc" id="L709">				final float absPosition = Math.abs(position);</span>
<span class="nc" id="L710">				return offset * (1 + (interpolator.getInterpolation(absPosition) - absPosition));</span>
			}
<span class="nc" id="L712">			return offset;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>