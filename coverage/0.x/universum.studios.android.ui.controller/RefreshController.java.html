<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RefreshController.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.controller</a> &gt; <span class="el_source">RefreshController.java</span></div><h1>RefreshController.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.controller;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.SystemClock;
import android.support.annotation.AttrRes;
import android.support.annotation.FloatRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.Px;
import android.support.annotation.StyleRes;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.animation.AnimationUtils;
import android.view.animation.Interpolator;

import java.util.LinkedList;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.graphics.drawable.CircularProgressDrawable;
import universum.studios.android.ui.graphics.drawable.ProgressDrawable;
import universum.studios.android.ui.graphics.drawable.RefreshDrawable;
import universum.studios.android.ui.util.ResourceUtils;
import universum.studios.android.ui.widget.Pullable;
import universum.studios.android.ui.widget.Refreshable;
import universum.studios.android.ui.widget.Scrollable;

/**
 * RefreshController can be used to support &lt;b&gt;refresh&lt;/b&gt; feature for views with &lt;b&gt;refreshable&lt;/b&gt;
 * data set like {@link android.widget.ListView} or {@link android.widget.GridView}. A view that want
 * to provide refresh feature need to implement required {@link Scrollable} interface that specifies
 * simple API needed for this controller to properly handle this feature.
 * &lt;p&gt;
 * RefreshController uses {@link RefreshDrawable} as refresh indicator that is drawn near the top
 * edge of the refreshable view. To show/hide the indicator a user needs to pull down/up from/to the
 * view's top edge. Refresh callback will be fired after the indicator reaches a specific position
 * that can be specified via {@link #setRefreshPosition(float)}. There are a lot of properties that
 * can be set to customize the refresh behaviour, for example how much can be the  refresh indicator
 * pulled ({@link #setRefreshDistance(float)}) or the refresh indicator's transition
 * ({@link #setRefreshIndicatorTransition(int)}) determining how is the indicator transitioned to be
 * showed/hided during pull.
 * &lt;p&gt;
 * To receive callback about the initiated refresh, a watcher needs to register {@link Refreshable.OnRefreshListener}
 * listener of which {@link Refreshable.OnRefreshListener#onRefresh(Refreshable)} callback will be
 * fired whenever a user releases the refresh indicator at or after the refresh position. When there
 * is refreshing process finished, {@link RefreshController#setRefreshing(boolean)} need to be called
 * upon an instance of this controller class with {@code false} to dismiss the refresh indicator. This
 * method can be used also to show (pop) the refresh indicator for example, when the user clicks on
 * a refresh button.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * RefreshController is meant to be used within views so it also supports set up from {@link AttributeSet}
 * via {@link #setUpFromAttrs(Context, AttributeSet, int, int)} method that should be called from
 * within a constructor of the refreshable view that uses this controller to provide the refresh
 * feature. See {@link R.styleable#Ui_RefreshController RefreshController Attributes}.
 *
 * &lt;h3&gt;XML attributes for refresh indicator&lt;/h3&gt;
 * Refresh indicator drawable can be also styled by referencing the desired style via
 * {@link R.attr#uiRefreshIndicatorStyle uiRefreshIndicatorStyle} attribute.
 * See {@link R.styleable#Ui_RefreshIndicator RefreshIndicator Attributes}.
 * Also, the refresh indicator can be accessed via {@link #getRefreshIndicator()} method for styling
 * through Java code.
 *
 * @param &lt;V&gt; Type of the refreshable view.
 * @author Martin Albedinsky
 */
public class RefreshController&lt;V extends View &amp; Refreshable&gt; extends BasePullController&lt;V&gt; {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;RefreshController&quot;;

	/**
	 * Default refresh position. See {@link #mRefreshPosition}
	 */
	private static final float REFRESH_POINT = 0.6f;

	/**
	 * Radius of the refresh (circular) drawable in &lt;b&gt;dp&lt;/b&gt; units also with arrow size taken into
	 * count.
	 */
	private static final int REFRESH_INDICATOR_RADIUS = 17;

	/**
	 * Thickness of the refresh (circular) drawable in &lt;b&gt;dp&lt;/b&gt; units.
	 */
	private static final int REFRESH_INDICATOR_THICKNESS = 3;

	/**
	 * Maximum progress to be set to indicator during pull.
	 */
	private static final int MAX_INDICATOR_PULL_PROGRESS = 80;

	/**
	 * Maximum rotation which can be applied to indicator during pull.
	 */
	private static final float MAX_INDICATOR_PULL_ROTATION = 360f;

	/**
	 * Flag indicating whether the view using this helper is attached to window or not.
	 */
	private static final int PFLAG_ATTACHED_TO_WINDOW = 0x00000001;

	/**
	 * Flag indicating whether the view using this helper is being pulled or not.
	 */
	private static final int PFLAG_PULLING = 0x00000002;

	/**
	 * Flag indicating whether the refresh process is running or not.
	 */
	private static final int PFLAG_REFRESHING = 0x00000004;

	/**
	 * Flag indicating whether there was started animation to pop indicator or not.
	 */
	private static final int PFLAG_POPPING_INDICATOR = 0x00000008;

	/**
	 * Flag indicating whether there was started animation to dismiss indicator or not.
	 */
	private static final int PFLAG_DISMISSING_INDICATOR = 0x00000010;

	/**
	 * Flag indicating whether there is running some of the scheduled animations or not.
	 */
	private static final int PFLAG_RUNNING_SCHEDULED_ANIMATION = 0x00000020;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Runnable action used to schedule refreshable view's invalidation.
	 */
<span class="nc" id="L178">	private final Runnable INVALIDATE_VIEW = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L184">			mView.invalidate();</span>
<span class="nc" id="L185">		}</span>
	};

	/**
	 * Runnable action used to schedule refreshable view's unfrozing.
	 */
<span class="nc" id="L191">	private final Runnable UNFROZE_VIEW = new Runnable() {</span>
		@Override
		public void run() {
<span class="nc" id="L194">			setViewFrozen(false);</span>
<span class="nc" id="L195">		}</span>
	};

	/**
	 * Runnable action used to schedule refresh indicator's pop animation.
	 */
<span class="nc" id="L201">	private final Runnable POP_INDICATOR = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L207">			popIndicator();</span>
<span class="nc" id="L208">			updatePrivateFlags(PFLAG_REFRESHING, true);</span>
<span class="nc" id="L209">		}</span>
	};

	/**
	 * Runnable action used to schedule refresh indicator's dismiss animation.
	 */
<span class="nc" id="L215">	private final Runnable DISMISS_INDICATOR = new Runnable() {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L221">			dismissIndicator();</span>
<span class="nc" id="L222">			updatePrivateFlags(PFLAG_REFRESHING, false);</span>
<span class="nc" id="L223">		}</span>
	};

	/**
	 * Object holding data about the refresh indicator.
	 */
<span class="nc" id="L229">	private final IndicatorInfo INDICATOR_INFO = new IndicatorInfo();</span>

	/**
	 * Drawable used to draw refresh indicator.
	 */
	private final RefreshDrawable mIndicator;

	/**
	 * Flag determining type of the transition used to show/hide the indicator using pull.
	 */
<span class="nc" id="L239">	private int mIndicatorTransition = Refreshable.TRANSITION_BELOW;</span>

	/**
	 * Offset for the originating position of the refresh indicator.
	 */
	private int mIndicatorOffset;

	/**
	 * Animations helper used to run animations upon this controller regardless current Android version.
	 */
	private final Animations mAnimations;

	/**
	 * Dimension of the refreshable view.
	 */
	private int mViewWidth, mViewHeight;

	/**
	 * Callback to be invoked whenever the refresh has been initiated.
	 */
	private Refreshable.OnRefreshListener mRefreshListener;

	/**
	 * Position determining the boundary for refresh process to be initiated after a user releases the
	 * indicator.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #REFRESH_POINT}&lt;/b&gt;
	 */
<span class="nc" id="L267">	private float mRefreshPosition = REFRESH_POINT;</span>

	/**
	 * Position determining the boundary where should be the indicator settled after the refresh process
	 * has been initiated. This position is also used when popping the indicator by {@link #popIndicator()}
	 * method.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #mRefreshPosition}&lt;/b&gt;
	 */
<span class="nc" id="L276">	private float mRefreshSettlePosition = mRefreshPosition;</span>

	/**
	 * Time of the last invalidation of the refreshable view.
	 */
<span class="nc" id="L281">	private long mLastViewInvalidationTime = SystemClock.uptimeMillis();</span>

	/**
	 * Queue containing a set of runnables for the scheduled animations. This queue is used for animations
	 * that should be played one after another not at the same time.
	 */
	private LinkedList&lt;Runnable&gt; mScheduledAnimations;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of RefreshHelper to handle refreshing of the specified &lt;var&gt;view&lt;/var&gt;.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that the new RefreshHelper instance will register self as {@link Pullable.OnPullListener}
	 * into the PullController of the given view, so it will receive pull callbacks necessary to handle
	 * refresh feature.
	 *
	 * @param view The view of which refresh to handle by the new RefreshHelper.
	 */
	@SuppressWarnings(&quot;NewApi&quot;)
	public RefreshController(@NonNull V view) {
<span class="nc" id="L304">		super(view);</span>
		// Use software layer that is required for proper drawing work of refresh drawable.
<span class="nc bnc" id="L306" title="All 2 branches missed.">		if (ProgressDrawable.REQUIRES_SOFTWARE_LAYER) {</span>
<span class="nc" id="L307">			view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span>
		}
<span class="nc" id="L309">		this.mAnimations = Animations.get(this);</span>

		/**
		 * Initialize refresh indicator drawable.
		 */
<span class="nc" id="L314">		final Resources resources = view.getResources();</span>
<span class="nc" id="L315">		final float density = resources.getDisplayMetrics().density;</span>
<span class="nc" id="L316">		this.mIndicator = new RefreshDrawable();</span>
<span class="nc" id="L317">		mIndicator.setProgressRadius(Math.round(density * REFRESH_INDICATOR_RADIUS));</span>
<span class="nc" id="L318">		mIndicator.setProgressThickness(Math.round(density * REFRESH_INDICATOR_THICKNESS));</span>
<span class="nc" id="L319">		mIndicator.setBackground(ResourceUtils.getDrawable(resources, R.drawable.ui_sdw_drop_refresh_indicator, view.getContext().getTheme()));</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">		if (!view.isInEditMode()) {</span>
<span class="nc" id="L321">			mIndicator.setProgressColors(resources.getIntArray(R.array.ui_colors_indeterminate_progress));</span>
		}
<span class="nc" id="L323">		mIndicator.setProgressMultiColored(true);</span>
<span class="nc" id="L324">		mIndicator.setVisible(false, false);</span>
<span class="nc" id="L325">		mIndicator.setCallback(view);</span>
<span class="nc" id="L326">		final int indicatorHeight = mIndicator.getIntrinsicHeight();</span>
<span class="nc" id="L327">		mIndicator.setBounds(0, 0, mIndicator.getIntrinsicWidth(), indicatorHeight);</span>

<span class="nc" id="L329">		this.handleViewSizeChanged(view.getWidth(), view.getHeight());</span>
<span class="nc" id="L330">		this.resetIndicator(false);</span>
<span class="nc" id="L331">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Performs set up of this controller from the given &lt;var&gt;attrs&lt;/var&gt;.
	 *
	 * @param context      Context used to obtain values for the given attributes.
	 * @param attrs        Set of attributes with values to be used to set up this controller.
	 * @param defStyleAttr An attribute which contains a reference to a default style resource, for
	 *                     the view attached to this controller, within a theme of the given context.
	 * @param defStyleRes  Resource id of the default style for the view attached to this controller.
	 * @return {@code True} if some setting of this controller has been changed, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;ResourceType&quot;)
	public boolean setUpFromAttrs(@NonNull Context context, AttributeSet attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
<span class="nc" id="L349">		final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.Ui_RefreshController, defStyleAttr, defStyleRes);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		if (typedArray != null) {</span>
<span class="nc" id="L351">			final int n = typedArray.getIndexCount();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">			for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L353">				final int index = typedArray.getIndex(i);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">				if (index == R.styleable.Ui_RefreshController_uiRefreshDistance) {</span>
<span class="nc" id="L355">					setRefreshDistance(typedArray.getDimensionPixelSize(index, (int) mPullDistance));</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshDistanceFraction) {</span>
<span class="nc" id="L357">					setRefreshDistanceFraction(typedArray.getFloat(index, mPullDistanceFraction));</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshPosition) {</span>
<span class="nc" id="L359">					setRefreshPosition(typedArray.getFloat(index, mRefreshPosition));</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshSettlePosition) {</span>
<span class="nc" id="L361">					setRefreshSettlePosition(typedArray.getFloat(index, mRefreshSettlePosition));</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshSettleDuration) {</span>
<span class="nc" id="L363">					setRefreshSettleDuration(typedArray.getInt(index, (int) mAnimations.refreshSettleDuration));</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshGestureInterpolator) {</span>
<span class="nc" id="L365">					setRefreshGestureInterpolator(AnimationUtils.loadInterpolator(context, typedArray.getResourceId(index, 0)));</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorTransition) {</span>
<span class="nc" id="L367">					setRefreshIndicatorTransition(typedArray.getInteger(index, mIndicatorTransition));</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorHideDuration) {</span>
<span class="nc" id="L369">					setRefreshIndicatorHideDuration(typedArray.getInt(index, (int) mAnimations.indicatorHideDuration));</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorPopDuration) {</span>
<span class="nc" id="L371">					setRefreshIndicatorPopDuration(typedArray.getInt(index, (int) mAnimations.indicatorPopDuration));</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorDismissDuration) {</span>
<span class="nc" id="L373">					setRefreshIndicatorDismissDuration(typedArray.getInt(index, (int) mAnimations.indicatorDismissDuration));</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorArrowScaleDuration) {</span>
<span class="nc" id="L375">					setRefreshIndicatorArrowScaleDuration(typedArray.getInt(index, (int) mAnimations.indicatorArrowScaleDuration));</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorOffset) {</span>
<span class="nc" id="L377">					setRefreshIndicatorOffset(typedArray.getDimensionPixelSize(index, mIndicatorOffset));</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_RefreshController_uiRefreshIndicatorStyle) {</span>
<span class="nc" id="L379">					final int styleRes = typedArray.getResourceId(index, -1);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">					if (styleRes != -1) {</span>
<span class="nc" id="L381">						final TypedArray indArray = context.obtainStyledAttributes(styleRes, R.styleable.Ui_RefreshIndicator);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">						if (indArray != null) {</span>
<span class="nc" id="L383">							final int indN = indArray.getIndexCount();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">							for (int j = 0; j &lt; indN; j++) {</span>
<span class="nc" id="L385">								final int indIndex = indArray.getIndex(j);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">								if (indIndex == R.styleable.Ui_RefreshIndicator_uiRefreshColor) {</span>
<span class="nc" id="L387">									mIndicator.setProgressColor(indArray.getInt(index, mIndicator.getProgressColor()));</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">								} else if (indIndex == R.styleable.Ui_RefreshIndicator_uiRefreshColors) {</span>
<span class="nc" id="L389">									final int colorsRes = indArray.getResourceId(index, -1);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">									if (colorsRes != -1) {</span>
<span class="nc" id="L391">										mIndicator.setProgressColors(context.getResources().getIntArray(colorsRes));</span>
									}
<span class="nc bnc" id="L393" title="All 2 branches missed.">								} else if (indIndex == R.styleable.Ui_RefreshIndicator_uiRefreshMultiColored) {</span>
<span class="nc" id="L394">									mIndicator.setProgressMultiColored(indArray.getBoolean(index, mIndicator.isProgressMultiColored()));</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">								} else if (indIndex == R.styleable.Ui_RefreshIndicator_uiRefreshIndeterminateSpeed) {</span>
<span class="nc" id="L396">									mIndicator.setProgressIndeterminateSpeed(indArray.getFloat(index, mIndicator.getProgressIndeterminateSpeed()));</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">								} else if (indIndex == R.styleable.Ui_RefreshIndicator_android_thickness) {</span>
<span class="nc" id="L398">									mIndicator.setProgressThickness(indArray.getDimensionPixelSize(index, (int) mIndicator.getProgressThickness()));</span>
								}
							}
<span class="nc" id="L401">							indArray.recycle();</span>
						}
					}
				}
			}
<span class="nc" id="L406">			typedArray.recycle();</span>
<span class="nc" id="L407">			this.resetIndicator(false);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">			return n &gt; 0;</span>
		}
<span class="nc" id="L410">		return false;</span>
	}

	/**
	 * Sets the transition type determining how to transition the refresh indicator when it is being
	 * pulled down/up by a user.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that {@link Refreshable#TRANSITION_COPLANAR} transition will for now behave like
	 * {@link Refreshable#TRANSITION_ABOVE}. This is scheduled to be changed in the feature.
	 *
	 * @param transition The desired indicator's transition. One of {@link Refreshable#TRANSITION_BELOW TRANSITION_BELOW},
	 *                   {@link Refreshable#TRANSITION_COPLANAR TRANSITION_COPLANAR} or {@link Refreshable#TRANSITION_ABOVE TRANSITION_ABOVE}.
	 * @see R.attr#uiRefreshIndicatorTransition ui:uiRefreshIndicatorTransition
	 * @see #getRefreshIndicatorTransition()
	 */
	public void setRefreshIndicatorTransition(@Refreshable.IndicatorTransition int transition) {
<span class="nc" id="L426">		this.mIndicatorTransition = transition;</span>
<span class="nc" id="L427">	}</span>

	/**
	 * Returns the current transition type of the refresh indicator.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link Refreshable#TRANSITION_BELOW}&lt;/b&gt;
	 *
	 * @return One of {@link Refreshable#TRANSITION_BELOW TRANSITION_BELOW}, {@link Refreshable#TRANSITION_COPLANAR TRANSITION_COPLANAR}
	 * or {@link Refreshable#TRANSITION_ABOVE TRANSITION_ABOVE}.
	 * @see #setRefreshIndicatorTransition(int)
	 */
	@Refreshable.IndicatorTransition
	public int getRefreshIndicatorTransition() {
<span class="nc" id="L440">		return mIndicatorTransition;</span>
	}

	/**
	 * Sets the duration for the refresh indicator's hide animation.
	 * &lt;p&gt;
	 * The hide animation is played whenever user releases the indicator and its current position is
	 * before the {@link #getRefreshPosition()}.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see R.attr#uiRefreshIndicatorHideDuration ui:uiRefreshIndicatorHideDuration
	 * @see #getRefreshIndicatorHideDuration()
	 */
	public void setRefreshIndicatorHideDuration(long duration) {
<span class="nc" id="L454">		mAnimations.indicatorHideDuration = Math.max(0, duration);</span>
<span class="nc" id="L455">	}</span>

	/**
	 * Returns the duration used for the refresh indicator's hide animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;300 ms&lt;/b&gt;
	 *
	 * @return Duration in milliseconds.
	 * @see #setRefreshIndicatorHideDuration(long)
	 */
	public long getRefreshIndicatorHideDuration() {
<span class="nc" id="L466">		return mAnimations.indicatorPopDuration;</span>
	}

	/**
	 * Sets the duration for the refresh indicator's pop animation.
	 * &lt;p&gt;
	 * The pop animation is played whenever {@link #setRefreshing(boolean)} is called with {@code true}.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see R.attr#uiRefreshIndicatorPopDuration ui:uiRefreshIndicatorPopDuration
	 * @see #getRefreshIndicatorPopDuration()
	 */
	public void setRefreshIndicatorPopDuration(long duration) {
<span class="nc" id="L479">		mAnimations.indicatorPopDuration = Math.max(0, duration);</span>
<span class="nc" id="L480">	}</span>

	/**
	 * Returns the duration used for the refresh indicator's pop animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;300 ms&lt;/b&gt;
	 *
	 * @return Duration in milliseconds.
	 * @see #setRefreshIndicatorPopDuration(long)
	 */
	public long getRefreshIndicatorPopDuration() {
<span class="nc" id="L491">		return mAnimations.indicatorPopDuration;</span>
	}

	/**
	 * Sets the duration for the refresh indicator's dismiss animation.
	 * &lt;p&gt;
	 * The dismiss animation is played whenever {@link #setRefreshing(boolean)} is called with
	 * {@code false}.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see R.attr#uiRefreshIndicatorDismissDuration ui:uiRefreshIndicatorDismissDuration
	 * @see #getRefreshIndicatorDismissDuration()
	 */
	public void setRefreshIndicatorDismissDuration(long duration) {
<span class="nc" id="L505">		mAnimations.indicatorDismissDuration = Math.max(0, duration);</span>
<span class="nc" id="L506">	}</span>

	/**
	 * Returns the duration used for the refresh indicator's dismiss animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;300 ms&lt;/b&gt;
	 *
	 * @return Duration in milliseconds.
	 * @see #setRefreshIndicatorDismissDuration(long)
	 */
	public long getRefreshIndicatorDismissDuration() {
<span class="nc" id="L517">		return mAnimations.indicatorDismissDuration;</span>
	}

	/**
	 * Sets the duration for the refresh indicator's arrow scale down animation.
	 * &lt;p&gt;
	 * The arrow's scale down animation is played whenever the refresh process is initiated by releasing
	 * of the indicator when mode of the refresh drawable is changed to &lt;b&gt;indeterminate&lt;/b&gt; so the
	 * arrow needs to be hided.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see R.attr#uiRefreshIndicatorArrowScaleDuration ui:uiRefreshIndicatorArrowScaleDuration
	 * @see #getRefreshIndicatorArrowScaleDuration()
	 */
	public void setRefreshIndicatorArrowScaleDuration(long duration) {
<span class="nc" id="L532">		mAnimations.indicatorArrowScaleDuration = Math.max(0, duration);</span>
<span class="nc" id="L533">	}</span>

	/**
	 * Returns the duration used for the refresh indicator's arrow scale animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;1000 ms&lt;/b&gt;
	 *
	 * @return Duration in milliseconds.
	 * @see #setRefreshIndicatorArrowScaleDuration(long)
	 */
	public long getRefreshIndicatorArrowScaleDuration() {
<span class="nc" id="L544">		return mAnimations.indicatorArrowScaleDuration;</span>
	}

	/**
	 * Sets an offset for the originating position of the refresh indicator. This offset determines
	 * where should be the indicator positioned when a user starts the drag gesture to pull it down
	 * to initiate refresh.
	 * &lt;p&gt;
	 * This can be used for example in case of {@link Refreshable#TRANSITION_ABOVE} indicator's transition
	 * mode to move the originating position to the bottom if the refreshable view is offset from the
	 * top due to its layout margin or due to another view.
	 *
	 * @param offset The desired offset in pixels. Positive value will move the originating position
	 *               to the bottom, negative value to the top.
	 * @see R.attr#uiRefreshIndicatorOffset ui:uiRefreshIndicatorOffset
	 * @see #getRefreshIndicatorOffset()
	 * @see #setRefreshIndicatorTransition(int)
	 */
	public void setRefreshIndicatorOffset(@Px int offset) {
<span class="nc" id="L563">		this.mIndicatorOffset = offset;</span>
<span class="nc" id="L564">	}</span>

	/**
	 * Returns the offset of the refresh indicator's originating position.
	 *
	 * @return Indicator's originating offset in pixels.
	 * @see #setRefreshIndicatorOffset(int)
	 */
	@Px
	public int getRefreshIndicatorOffset() {
<span class="nc" id="L574">		return mIndicatorOffset;</span>
	}

	/**
	 * Sets a position determining the boundary for refresh process to be initiated after a user releases
	 * the refresh indicator.
	 * &lt;p&gt;
	 * The specified position is checked during the pull against the current position of the pull to
	 * resolve whether to initiate refresh or not.
	 *
	 * @param position The desired refresh position from the range {@code [0, 1]}.
	 * @see R.attr#uiRefreshPosition ui:uiRefreshPosition
	 * @see #getRefreshPosition()
	 */
	public void setRefreshPosition(@FloatRange(from = 0, to = 1) float position) {
<span class="nc bnc" id="L589" title="All 4 branches missed.">		if (position &gt;= 0 &amp;&amp; position &lt;= 1) this.mRefreshPosition = position;</span>
<span class="nc" id="L590">	}</span>

	/**
	 * Returns the current refresh position.
	 *
	 * @return Position from the range {@code [0, 1]}.
	 * @see #setRefreshPosition(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getRefreshPosition() {
<span class="nc" id="L600">		return mRefreshPosition;</span>
	}

	/**
	 * Sets a position determining the boundary for the refresh indicator to be settled on after a
	 * user releases it. This position needs to be smaller or equal than a refresh position specified
	 * by {@link #setRefreshPosition(float)}.
	 * &lt;p&gt;
	 * The specified position is used when preparing the settle animation to determine how much needs
	 * to be the refresh indicator moved back from its current (released) pull position.
	 *
	 * @param settlePosition The desired refresh settle position from the range {@code [0, refreshPosition]}.
	 * @see R.attr#uiRefreshSettlePosition ui:uiRefreshSettlePosition
	 * @see #getRefreshSettlePosition()
	 */
	public void setRefreshSettlePosition(float settlePosition) {
<span class="nc bnc" id="L616" title="All 6 branches missed.">		if (settlePosition &gt;= 0 &amp;&amp; settlePosition &lt;= 1 &amp;&amp; settlePosition &lt;= mRefreshPosition) {</span>
<span class="nc" id="L617">			this.mRefreshSettlePosition = settlePosition;</span>
		}
<span class="nc" id="L619">	}</span>

	/**
	 * Returns the current refresh settle position.
	 *
	 * @return Position from the range {@code [0, refreshPosition]}.
	 * @see #setRefreshSettlePosition(float)
	 */
	public float getRefreshSettlePosition() {
<span class="nc" id="L628">		return mRefreshSettlePosition;</span>
	}

	/**
	 * Sets the duration for the refresh indicator's settle animation.
	 * &lt;p&gt;
	 * The settle animation is played whenever a user releases the indicator and its current position
	 * is after the &lt;b&gt;settle position&lt;/b&gt; specified by {@link #setRefreshSettlePosition(float)}.
	 *
	 * @param duration The desired duration in milliseconds.
	 * @see R.attr#uiRefreshSettleDuration ui:uiRefreshSettleDuration
	 * @see #getRefreshSettleDuration()
	 */
	public void setRefreshSettleDuration(int duration) {
<span class="nc" id="L642">		mAnimations.refreshSettleDuration = Math.max(0, duration);</span>
<span class="nc" id="L643">	}</span>

	/**
	 * Returns the duration for the refresh indicator's settle animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;75 ms&lt;/b&gt;
	 *
	 * @return Duration in milliseconds.
	 * @see #setRefreshSettleDuration(int)
	 */
	public long getRefreshSettleDuration() {
<span class="nc" id="L654">		return mAnimations.refreshSettleDuration;</span>
	}

	/**
	 * Sets the distance which determines how much can be the the refresh indicator pulled.
	 *
	 * @param distance The desired value in pixels to determine maximum refresh distance.
	 * @see R.attr#uiRefreshDistance ui:uiRefreshDistance
	 */
	public void setRefreshDistance(float distance) {
<span class="nc" id="L664">		setPullDistance(distance);</span>
<span class="nc" id="L665">	}</span>

	/**
	 * Returns the value of the maximum refresh distance.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #getPullDistance()}&lt;/b&gt;
	 *
	 * @return Maximum refresh distance in pixels or {@code -1} if the refresh distance cannot be
	 * right now  resolved due to not initialized size of the attached refreshable view yet.
	 */
	public float getRefreshDistance() {
<span class="nc" id="L676">		return getPullDistance();</span>
	}

	/**
	 * Sets the fraction for the maximum refresh distance which determines how much can be the refresh
	 * indicator pulled. The specified fraction will be used to compute maximum refresh distance from
	 * the size of the refreshable view.
	 *
	 * @param fraction The desired fraction from the range {@code [0, 1f]}.
	 * @see #setRefreshDistance(float)
	 */
	public void setRefreshDistanceFraction(@FloatRange(from = 0, to = 1) float fraction) {
<span class="nc" id="L688">		setPullDistanceFraction(fraction);</span>
<span class="nc" id="L689">	}</span>

	/**
	 * Returns the fraction used to compute maximum refresh distance.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;0&lt;/b&gt;
	 *
	 * @return Refresh fraction from the range {@code [0, 1f]}.
	 */
	@FloatRange(from = 0, to = 1)
	public float getRefreshDistanceFraction() {
<span class="nc" id="L700">		return getPullDistanceFraction();</span>
	}

	/**
	 * Sets an interpolator that is used when interpolating pull value during refresh gesture.
	 *
	 * @param interpolator The desired interpolator.
	 * @see R.attr#uiRefreshGestureInterpolator ui:uiRefreshGestureInterpolator
	 * @see #setPullTransformerInterpolator(Interpolator)
	 */
	public void setRefreshGestureInterpolator(@NonNull Interpolator interpolator) {
<span class="nc" id="L711">		setPullTransformerInterpolator(interpolator);</span>
<span class="nc" id="L712">	}</span>

	/**
	 * Registers a callback to be invoked whenever a user releases the refresh indicator at or after
	 * the refresh position specified by {@link #setRefreshPosition(float)}.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnRefreshListener(@Nullable Refreshable.OnRefreshListener listener) {
<span class="nc" id="L721">		this.mRefreshListener = listener;</span>
<span class="nc" id="L722">	}</span>

	/**
	 * Called from the view which uses this helper to provide refresh feature to dispatch that this
	 * view has been attached to window.
	 * &lt;p&gt;
	 * This should be called whenever {@link View#onAttachedToWindow()} is invoked
	 * within the view.
	 */
	public void dispatchViewAttachedToWindow() {
<span class="nc bnc" id="L732" title="All 2 branches missed.">		if (!hasPrivateFlag(PFLAG_ATTACHED_TO_WINDOW)) {</span>
<span class="nc" id="L733">			this.updatePrivateFlags(PFLAG_ATTACHED_TO_WINDOW, true);</span>
<span class="nc" id="L734">			mIndicator.start();</span>
		}
<span class="nc" id="L736">	}</span>

	/**
	 * Called from the view which uses this helper to provide refresh feature to dispatch that this
	 * view has been detached from window.
	 * &lt;p&gt;
	 * This should be called whenever {@link View#onDetachedFromWindow()} is invoked
	 * within the view.
	 */
	public void dispatchViewDetachedFromWindow() {
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_ATTACHED_TO_WINDOW)) {</span>
<span class="nc" id="L747">			this.updatePrivateFlags(PFLAG_ATTACHED_TO_WINDOW, false);</span>
<span class="nc" id="L748">			mIndicator.stop();</span>
<span class="nc" id="L749">			mView.unscheduleDrawable(mIndicator);</span>
<span class="nc" id="L750">			mIndicator.setCallback(null);</span>
		}
<span class="nc" id="L752">	}</span>

	/**
	 * Called from the view which uses this helper to provide refresh feature to dispatch that a size
	 * of this view has been changed to the new one.
	 * &lt;p&gt;
	 * This should be called whenever {@link View#onSizeChanged(int, int, int, int)} is invoked
	 * within the view.
	 *
	 * @param width  New width of the view.
	 * @param height New height of the view.
	 */
	public void dispatchViewSizeChanged(int width, int height) {
<span class="nc bnc" id="L765" title="All 4 branches missed.">		if (mViewWidth != width || mViewHeight != height) {</span>
<span class="nc" id="L766">			this.handleViewSizeChanged(width, height);</span>
		}
<span class="nc" id="L768">	}</span>

	/**
	 * Handles change in the refreshable view's size. This stores the current dimensions of the view,
	 * updates refresh distance if necessary and invalidates the indicator.
	 *
	 * @param width  New width of the view.
	 * @param height New height of the view.
	 */
	private void handleViewSizeChanged(int width, int height) {
<span class="nc bnc" id="L778" title="All 4 branches missed.">		if (width &gt; 0 &amp;&amp; height &gt; 0) {</span>
<span class="nc" id="L779">			this.mViewWidth = width;</span>
<span class="nc" id="L780">			this.mViewHeight = height;</span>
<span class="nc" id="L781">			mIndicator.invalidateSelf();</span>
		}
<span class="nc" id="L783">	}</span>

	/**
	 * Returns the drawable which is drawn by this helper within {@link #drawRefreshIndicator(Canvas)}
	 * to indicate running refresh process.
	 * &lt;p&gt;
	 * &lt;b&gt;Use here returned drawable only for customization purposes like to change color or thickness
	 * of the progress arc. Any changes related to visibility or position will be changed in the feature
	 * by this helper so they will not persist.&lt;/b&gt;
	 *
	 * @return Refresh indicator's drawable.
	 */
	@NonNull
	public final RefreshDrawable getRefreshIndicator() {
<span class="nc" id="L797">		return mIndicator;</span>
	}

	/**
	 * Called to verify if the given &lt;var&gt;drawable&lt;/var&gt; is refresh indicator's drawable of this
	 * helper.
	 * &lt;p&gt;
	 * This should be called whenever {@link View#verifyDrawable(Drawable)}
	 * is invoked within the view.
	 *
	 * @param drawable The drawable to verify.
	 * @return {@code True} if the verified drawable is refresh indicator's drawable, {@code false}
	 * otherwise.
	 */
	public boolean verifyRefreshIndicatorDrawable(@NonNull Drawable drawable) {
<span class="nc bnc" id="L812" title="All 2 branches missed.">		return mIndicator == drawable;</span>
	}

	/**
	 * Draws the refresh indicator's drawable on the specified &lt;var&gt;canvas&lt;/var&gt;.
	 * &lt;p&gt;
	 * This should be called from within the view which uses this helper to provide refresh feature
	 * whenever {@link View#dispatchDraw(Canvas)}, so the indicator can be properly
	 * drawn above all content of the view.
	 *
	 * @param canvas The canvas on which to draw refresh indicator.
	 */
	@SuppressLint(&quot;NewApi&quot;)
	public void drawRefreshIndicator(@NonNull Canvas canvas) {
<span class="nc bnc" id="L826" title="All 4 branches missed.">		if (mIndicator.isVisible() || mView.isInEditMode()) {</span>
<span class="nc" id="L827">			final int indWidth = mIndicator.getIntrinsicWidth();</span>
<span class="nc" id="L828">			final int indHeight = mIndicator.getIntrinsicHeight();</span>
			// Modify (translate, scale, ...) and cut only the part of the canvas exactly for the
			// refresh indicator and draw it.
<span class="nc" id="L831">			final int saveCount = canvas.save();</span>
<span class="nc" id="L832">			canvas.translate(</span>
					mViewWidth / 2 - indWidth / 2,
					INDICATOR_INFO.top + INDICATOR_INFO.translationY
			);
<span class="nc" id="L836">			canvas.clipRect(mIndicator.getBounds());</span>
<span class="nc" id="L837">			canvas.scale(INDICATOR_INFO.scale, INDICATOR_INFO.scale, indWidth / 2f, indHeight / 2f);</span>
<span class="nc" id="L838">			mIndicator.draw(canvas);</span>
<span class="nc" id="L839">			canvas.restoreToCount(saveCount);</span>
<span class="nc" id="L840">			this.postInvalidateViewOnAnimation();</span>
		}
<span class="nc" id="L842">	}</span>

	/**
	 * Causes an invalidate of the pullable view to happen on the next animation time step.
	 */
	private void postInvalidateViewOnAnimation() {
<span class="nc bnc" id="L848" title="All 2 branches missed.">		if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) {</span>
<span class="nc" id="L849">			mView.postInvalidateOnAnimation();</span>
		} else {
<span class="nc" id="L851">			final long currentTime = SystemClock.uptimeMillis();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">			if (currentTime - mLastViewInvalidationTime &gt;= UiConfig.ANIMATION_FRAME_UPDATE_INTERVAL) {</span>
<span class="nc" id="L853">				mView.postDelayed(INVALIDATE_VIEW, UiConfig.ANIMATION_FRAME_UPDATE_INTERVAL);</span>
			}
<span class="nc" id="L855">			this.mLastViewInvalidationTime = currentTime;</span>
		}
<span class="nc" id="L857">	}</span>

	/**
	 */
	@Override
	public boolean shouldInterceptTouchEvent(@NonNull MotionEvent event) {
<span class="nc bnc" id="L863" title="All 4 branches missed.">		return !hasPrivateFlag(PFLAG_REFRESHING) &amp;&amp; super.shouldInterceptTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	public boolean processTouchEvent(@NonNull MotionEvent event) {
<span class="nc bnc" id="L870" title="All 4 branches missed.">		return !hasPrivateFlag(PFLAG_REFRESHING) &amp;&amp; super.processTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	void onPullHelperChanged(PullHelper helper) {
<span class="nc" id="L877">		super.onPullHelperChanged(helper);</span>
<span class="nc" id="L878">		helper.setPullMode(PullHelper.START);</span>
<span class="nc" id="L879">		helper.setPullVisibility(PullHelper.START, false);</span>
<span class="nc" id="L880">	}</span>

	/**
	 */
	@Override
	protected void onPullStarted() {
<span class="nc" id="L886">		super.onPullStarted();</span>
<span class="nc" id="L887">		this.updatePrivateFlags(PFLAG_PULLING, true);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">		if (!hasPrivateFlag(PFLAG_REFRESHING)) {</span>
<span class="nc" id="L889">			this.resetIndicator(true);</span>
<span class="nc" id="L890">			mIndicator.setProgressArrowVisible(true);</span>
		}
<span class="nc" id="L892">	}</span>

	/**
	 * Resets all properties related to position, alpha and scale of the indicator.
	 *
	 * @param visible {@code True} to set indicator's drawable visible, {@code false} otherwise.
	 */
	private void resetIndicator(boolean visible) {
<span class="nc" id="L900">		mIndicator.setCallback(null);</span>
<span class="nc bnc" id="L901" title="All 3 branches missed.">		switch (mIndicatorTransition) {</span>
			case Refreshable.TRANSITION_BELOW:
<span class="nc" id="L903">				INDICATOR_INFO.scale = 1f;</span>
<span class="nc" id="L904">				mIndicator.setAlpha(255);</span>
<span class="nc" id="L905">				setIndicatorTop(0);</span>
<span class="nc" id="L906">				break;</span>
			case Refreshable.TRANSITION_COPLANAR:
			case Refreshable.TRANSITION_ABOVE:
<span class="nc" id="L909">				INDICATOR_INFO.scale = 0f;</span>
<span class="nc" id="L910">				mIndicator.setAlpha(0);</span>
<span class="nc" id="L911">				setIndicatorTop(mIndicator.getIntrinsicHeight() / 2);</span>
				break;
		}
<span class="nc" id="L914">		INDICATOR_INFO.translationY = 0;</span>
<span class="nc" id="L915">		mIndicator.setVisible(visible, false);</span>
<span class="nc" id="L916">		mIndicator.setInEditMode(mView.isInEditMode());</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">		if (mView.isInEditMode()) {</span>
<span class="nc" id="L918">			INDICATOR_INFO.scale = 1f;</span>
<span class="nc" id="L919">			mIndicator.setAlpha(255);</span>
<span class="nc" id="L920">			mIndicator.setVisible(true, false);</span>
<span class="nc" id="L921">			setIndicatorTop(Math.round(mRefreshSettlePosition * mPullDistance));</span>
		}
<span class="nc" id="L923">		mIndicator.setCallback(mView);</span>
<span class="nc" id="L924">		mIndicator.invalidateSelf();</span>
<span class="nc" id="L925">	}</span>

	/**
	 */
	@Override
	protected void onApplyPull(int pull, float position) {
<span class="nc" id="L931">		final boolean isRefreshing = hasPrivateFlag(PFLAG_REFRESHING);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">		if (position &gt;= 0) {</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">			if (!isRefreshing &amp;&amp; !mAnimations.isPopDismissIndicatorAnimationRunning()) {</span>
<span class="nc" id="L934">				mIndicator.setCallback(null);</span>
<span class="nc" id="L935">				this.setIndicatorPullPosition(position);</span>
<span class="nc" id="L936">				mIndicator.setCallback(mView);</span>
<span class="nc" id="L937">				mIndicator.invalidateSelf();</span>
			}
<span class="nc bnc" id="L939" title="All 2 branches missed.">		} else if (isRefreshing) {</span>
			// User is pulling refreshable view from the bottom, just translate the indicator backward,
			// so it will look like it is still.
<span class="nc" id="L942">			INDICATOR_INFO.translationY = (int) (-position * mPullDistance);</span>
<span class="nc" id="L943">			mIndicator.invalidateSelf();</span>
		}
<span class="nc" id="L945">	}</span>

	/**
	 * Updates the current position of the refresh indicator. Depends on the {@link #mIndicatorTransition}
	 * type, this will update indicator's position, alpha or scale to properly transition indicator
	 * to its final refresh position or back.
	 *
	 * @param position The current pull position.
	 */
	final void setIndicatorPullPosition(float position) {
<span class="nc bnc" id="L955" title="All 2 branches missed.">		if (mIndicatorTransition != Refreshable.TRANSITION_NONE) {</span>
<span class="nc" id="L956">			final float refreshPos = position / mRefreshPosition;</span>

			// Rotate, fade and update progress of indicator.
<span class="nc bnc" id="L959" title="All 2 branches missed.">			if (position &lt;= mRefreshPosition) {</span>
<span class="nc" id="L960">				mIndicator.setProgress(Math.round(refreshPos * MAX_INDICATOR_PULL_PROGRESS));</span>
<span class="nc" id="L961">				mIndicator.setProgressAlpha(Math.round(position / mRefreshPosition * 127));</span>
<span class="nc" id="L962">				this.setIndicatorArrowScale(refreshPos);</span>
			} else {
<span class="nc" id="L964">				mIndicator.setProgress(MAX_INDICATOR_PULL_PROGRESS);</span>
<span class="nc" id="L965">				this.setIndicatorArrowScale(1);</span>
<span class="nc" id="L966">				mIndicator.setProgressAlpha(255);</span>
			}
<span class="nc" id="L968">			mIndicator.setProgressRotation(position * MAX_INDICATOR_PULL_ROTATION);</span>

			// Translate indicator based on the selected transition.
<span class="nc bnc" id="L971" title="All 3 branches missed.">			switch (mIndicatorTransition) {</span>
				case Refreshable.TRANSITION_BELOW:
<span class="nc" id="L973">					this.setIndicatorTopAndInvalidate(Math.round(position * mPullDistance));</span>
<span class="nc" id="L974">					break;</span>
				case Refreshable.TRANSITION_COPLANAR:
				case Refreshable.TRANSITION_ABOVE:
<span class="nc bnc" id="L977" title="All 2 branches missed.">					if (position &lt;= mRefreshPosition) {</span>
<span class="nc" id="L978">						this.setIndicatorScaleFadeRatio(refreshPos);</span>
					}
<span class="nc" id="L980">					final float indScaleSize = mIndicator.getIntrinsicHeight() * (1 - INDICATOR_INFO.scale);</span>
<span class="nc" id="L981">					this.setIndicatorTopAndInvalidate(Math.round(position * mPullDistance + indScaleSize / 2));</span>
					break;
			}
<span class="nc bnc" id="L984" title="All 2 branches missed.">			mIndicator.setVisible(position &gt; 0, false);</span>
		}
<span class="nc" id="L986">	}</span>

	/**
	 * Like {@link #setIndicatorTop(int)} but this will also cause the indicator's invalidation.
	 */
	private void setIndicatorTopAndInvalidate(int top) {
<span class="nc" id="L992">		setIndicatorTop(top);</span>
<span class="nc" id="L993">		mIndicator.invalidateSelf();</span>
<span class="nc" id="L994">	}</span>

	/**
	 * Updates the top position of the indicator and invalidates it.
	 *
	 * @param top The new top position for indicator.
	 */
	final void setIndicatorTop(int top) {
<span class="nc" id="L1002">		INDICATOR_INFO.top = top - mIndicator.getIntrinsicHeight() + mIndicatorOffset;</span>
<span class="nc" id="L1003">	}</span>

	/**
	 * Updates the scale and fade of the indicator based on the specified &lt;var&gt;ratio&lt;/var&gt; and
	 * invalidates it.
	 *
	 * @param ratio The new ratio for the current alpha and scale values for indicator.
	 */
	final void setIndicatorScaleFadeRatio(float ratio) {
<span class="nc" id="L1012">		INDICATOR_INFO.scale = ratio;</span>
<span class="nc" id="L1013">		mIndicator.setAlpha(Math.round(ratio * 255));</span>
<span class="nc" id="L1014">	}</span>

	/**
	 * Updates the scale of the indicator's arrow and invalidates it.
	 *
	 * @param scale The new scale value for indicator's arrow.
	 */
	final void setIndicatorArrowScale(float scale) {
<span class="nc" id="L1022">		mIndicator.setProgressArrowScale(scale);</span>
<span class="nc" id="L1023">	}</span>

	/**
	 */
	@Override
	protected void onPullReleased(float pull, float position) {
<span class="nc" id="L1029">		super.onPullReleased(pull, position);</span>
<span class="nc" id="L1030">		this.updatePrivateFlags(PFLAG_PULLING, false);</span>

<span class="nc bnc" id="L1032" title="All 2 branches missed.">		if (position &lt; mRefreshPosition) {</span>
<span class="nc" id="L1033">			this.hideIndicator(position);</span>
		} else {
			// Change mode to indeterminate and hide progress arrow by scaling it down.
<span class="nc" id="L1036">			changeProgressMode(CircularProgressDrawable.MODE_INDETERMINATE, null);</span>

<span class="nc" id="L1038">			mAnimations.scaleIndicatorArrowDown();</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">			if (position != mRefreshSettlePosition) {</span>
<span class="nc" id="L1040">				mAnimations.settleIndicator(position);</span>
			}

			// Unfroze view after indicator is settled.
<span class="nc" id="L1044">			mView.postDelayed(UNFROZE_VIEW, mAnimations.refreshSettleDuration);</span>

<span class="nc" id="L1046">			this.updatePrivateFlags(PFLAG_REFRESHING, true);</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">			if (mRefreshListener != null) {</span>
<span class="nc" id="L1048">				mRefreshListener.onRefresh(mView);</span>
			}
		}
<span class="nc" id="L1051">	}</span>

	/**
	 * Translates the indicator the the origin position from where it can be again pulled by a user.
	 *
	 * @param pullPosition The current pull position.
	 */
	private void hideIndicator(float pullPosition) {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">		if (pullPosition &gt; 0) mAnimations.hideIndicator(pullPosition);</span>
<span class="nc" id="L1060">	}</span>

	/**
	 */
	@Override
	protected void onCollapsePull(float pull, float position) {
<span class="nc" id="L1066">		super.onCollapsePull(pull, position);</span>
		// Keep view frozen until the indicator is hided/settled.
<span class="nc" id="L1068">		setViewFrozen(true);</span>
<span class="nc" id="L1069">	}</span>

	/**
	 * Sets a flag indicating whether the view using this helper is being right now refreshing or not.
	 * &lt;p&gt;
	 * Calling of this method will &lt;b&gt;pop&lt;/b&gt; (using scale + fade in animation) the refresh indicator
	 * if calling  with {@code true} or &lt;b&gt;dismisses&lt;/b&gt; (using scale + fade out animation) the
	 * indicator if calling with {@code false}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that it is not supported to show the refresh indicator while a user is pulling the
	 * refreshable view.&lt;/b&gt;
	 *
	 * @param refreshing {@code True} to dispatch that refresh process is running so the indicator
	 *                   should be visible, {@code false} to dispatch that refresh process has been
	 *                   finished so the indicator should be hided.
	 */
	public void setRefreshing(boolean refreshing) {
<span class="nc bnc" id="L1086" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_REFRESHING) != refreshing) {</span>
<span class="nc bnc" id="L1087" title="All 4 branches missed.">			if (refreshing &amp;&amp; hasPrivateFlag(PFLAG_PULLING)) {</span>
<span class="nc" id="L1088">				return;</span>
			}
<span class="nc bnc" id="L1090" title="All 2 branches missed.">			if (refreshing) {</span>
<span class="nc" id="L1091">				scheduleAnimation(POP_INDICATOR);</span>
			} else {
<span class="nc" id="L1093">				scheduleAnimation(DISMISS_INDICATOR);</span>
			}
		}
<span class="nc" id="L1096">	}</span>

	/**
	 * Returns a flag indicating whether the refresh should be running, so the indicator is currently
	 * visible and spinning, or not.
	 * &lt;p&gt;
	 * This method will return {@code true} only in case when a user pulls down a refresh indicator
	 * and releases it after a refresh position specified by {@link #setRefreshPosition(float)} or
	 * {@link #setRefreshing(boolean)} has been last time called with {@code true}.
	 *
	 * @return {@code True} if refresh is running, {@code false} otherwise.
	 */
	public boolean isRefreshing() {
<span class="nc" id="L1109">		return hasPrivateFlag(PFLAG_REFRESHING);</span>
	}

	/**
	 * Shows the refresh indicator with scale + fade in animation at the refresh position.
	 */
	private void popIndicator() {
<span class="nc" id="L1116">		mIndicator.setCallback(null);</span>
<span class="nc" id="L1117">		this.resetIndicator(true);</span>
<span class="nc" id="L1118">		mIndicator.setAlpha(0);</span>
		// Position the indicator at the settle position.
<span class="nc" id="L1120">		setIndicatorTop(Math.round(mRefreshSettlePosition * mPullDistance));</span>
<span class="nc" id="L1121">		mIndicator.setCallback(mView);</span>
<span class="nc" id="L1122">		changeProgressMode(CircularProgressDrawable.MODE_INDETERMINATE, false);</span>
<span class="nc" id="L1123">		mAnimations.popIndicator();</span>
<span class="nc" id="L1124">	}</span>

	/**
	 * Dismisses the refresh indicator with scale + fade out animation from its current position.
	 */
	private void dismissIndicator() {
<span class="nc" id="L1130">		mAnimations.dismissIndicator();</span>
<span class="nc" id="L1131">	}</span>

	/**
	 * Changes progress mode of the indicator's progress drawable to the specified one.
	 *
	 * @param mode      The desired progress mode. One of {@link CircularProgressDrawable#MODE_DETERMINATE}
	 *                  or {@link CircularProgressDrawable#MODE_INDETERMINATE}.
	 * @param showArrow {@code True} to set progress arrow visible, {@code false} otherwise. Supply
	 *                  {@code null} to not touch arrow's visibility.
	 */
	private void changeProgressMode(@CircularProgressDrawable.ProgressMode int mode, Boolean showArrow) {
<span class="nc" id="L1142">		mIndicator.setProgressMode(mode);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">		if (showArrow != null) {</span>
<span class="nc" id="L1144">			mIndicator.setProgressArrowVisible(showArrow);</span>
		}
<span class="nc" id="L1146">	}</span>

	/**
	 * Schedules the specified runnable that contains an animation execution code. If there is already
	 * running some animation that has been scheduled before, this will add the given runnable into
	 * the {@link #mScheduledAnimations} queue so it can be run after the current running animation
	 * ends.
	 *
	 * @param animationRunnable The animation runnable to be run.
	 */
	private void scheduleAnimation(Runnable animationRunnable) {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">		if (hasPrivateFlag(PFLAG_RUNNING_SCHEDULED_ANIMATION)) {</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">			if (mScheduledAnimations == null) {</span>
<span class="nc" id="L1159">				this.mScheduledAnimations = new LinkedList&lt;&gt;();</span>
			}
<span class="nc" id="L1161">			mScheduledAnimations.add(animationRunnable);</span>
		} else {
<span class="nc" id="L1163">			mView.post(animationRunnable);</span>
<span class="nc" id="L1164">			updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, true);</span>
		}
<span class="nc" id="L1166">	}</span>

	/**
	 * Starts the top (head) animation from the current scheduled animations (if any) if there is
	 * no animation running at this time.
	 *
	 * @see #mScheduledAnimations
	 */
	final void startScheduledAnimation() {
<span class="nc" id="L1175">		updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, false);</span>
<span class="nc" id="L1176">		final boolean runningAnimation = hasPrivateFlag(PFLAG_RUNNING_SCHEDULED_ANIMATION);</span>
<span class="nc bnc" id="L1177" title="All 6 branches missed.">		if (!runningAnimation &amp;&amp; mScheduledAnimations != null &amp;&amp; !mScheduledAnimations.isEmpty()) {</span>
<span class="nc" id="L1178">			mView.post(mScheduledAnimations.poll());</span>
<span class="nc" id="L1179">			updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, true);</span>
		}
<span class="nc" id="L1181">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Class holding info about the refresh indicator.
	 */
<span class="nc" id="L1190">	private static final class IndicatorInfo {</span>

		/**
		 * Current top position of the indicator.
		 */
		int top;

		/**
		 * Current translation Y of the indicator.
		 */
		int translationY;

		/**
		 * Current scale of the indicator.
		 */
<span class="nc" id="L1205">		float scale = 1f;</span>

		/**
		 */
		@Override
		public String toString() {
			//noinspection StringBufferReplaceableByString
<span class="nc" id="L1212">			final StringBuilder builder = new StringBuilder(IndicatorInfo.class.getSimpleName() + &quot;[&quot;);</span>
<span class="nc" id="L1213">			builder.append(&quot;top(&quot;);</span>
<span class="nc" id="L1214">			builder.append(top);</span>
<span class="nc" id="L1215">			builder.append(&quot;), translationY(&quot;);</span>
<span class="nc" id="L1216">			builder.append(translationY);</span>
<span class="nc" id="L1217">			builder.append(&quot;), scale(&quot;);</span>
<span class="nc" id="L1218">			builder.append(scale);</span>
<span class="nc" id="L1219">			return builder.append(&quot;)]&quot;).toString();</span>
		}
	}

	/**
	 * Animations interface for this controller.
	 */
	private static abstract class Animations {

		/**
		 * Refresh controller for which to run animations.
		 */
		final RefreshController controller;

		/**
		 * Duration for the indicator's settle animation. The settle animation is played whenever a user
		 * releases the indicator and its current position is after the {@link #mRefreshSettlePosition}.
		 * &lt;p&gt;
		 * Default value: &lt;b&gt;{@link UiConfig#ANIMATION_DURATION_SHORT} / 2&lt;/b&gt;
		 */
<span class="nc" id="L1239">		long refreshSettleDuration = UiConfig.ANIMATION_DURATION_SHORT / 2;</span>

		/**
		 * Duration for the indicator's hide animation. The hide animation is played whenever a user
		 * releases the indicator and its current position is before the {@link #mRefreshPosition}.
		 * &lt;p&gt;
		 * Default value: &lt;b&gt;{@link UiConfig#ANIMATION_DURATION_SHORT}&lt;/b&gt;
		 */
<span class="nc" id="L1247">		long indicatorHideDuration = UiConfig.ANIMATION_DURATION_SHORT;</span>

		/**
		 * Duration for the indicator's pop animation. The pop animation is played whenever {@link #popIndicator()}
		 * is called, that is also whenever {@link #setRefreshing(boolean)} is called with {@code true}.
		 * &lt;p&gt;
		 * Default value: &lt;b&gt;{@link UiConfig#ANIMATION_DURATION_MEDIUM}&lt;/b&gt;
		 */
<span class="nc" id="L1255">		long indicatorPopDuration = UiConfig.ANIMATION_DURATION_MEDIUM;</span>

		/**
		 * Duration for the indicator's dismiss animation. The dismiss animation is played whenever
		 * {@link #dismissIndicator()} is called, that is also whenever {@link #setRefreshing(boolean)}
		 * is called with {@code false}.
		 * &lt;p&gt;
		 * Default value: &lt;b&gt;250&lt;/b&gt;
		 */
<span class="nc" id="L1264">		long indicatorDismissDuration = 250L;</span>

		/**
		 * Duration for the indicator's arrow scale down animation. The arrow scale down animation is
		 * played whenever the refresh process is initiated by releasing of the indicator.
		 * &lt;p&gt;
		 * Default value: &lt;b&gt;{@link UiConfig#ANIMATION_DURATION_LONG} * 2&lt;/b&gt;
		 */
<span class="nc" id="L1272">		long indicatorArrowScaleDuration = UiConfig.ANIMATION_DURATION_LONG * 2;</span>

		/**
		 * Creates a new instance of Animations interface for the specified refresh &lt;var&gt;controller&lt;/var&gt;.
		 *
		 * @param controller The refresh controler for which to run animations.
		 */
<span class="nc" id="L1279">		Animations(RefreshController controller) {</span>
<span class="nc" id="L1280">			this.controller = controller;</span>
<span class="nc" id="L1281">		}</span>

		/**
		 * Returns a new instance of Animations implementation specific for the current animations
		 * API capabilities.
		 *
		 * @param controller The refresh controller upon which will the returned Animations object
		 *                   run  all requested animations.
		 * @return New instance of Animations implementation.
		 */
		static Animations get(RefreshController controller) {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">			return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ?</span>
					new HoneyCombAnimations(controller) :
					new DefaultAnimations(controller);
		}

		/**
		 * Starts animation to pop (show) the refresh indicator.
		 */
		abstract void popIndicator();

		/**
		 * Starts animation to dismiss (hide) the refresh indicator.
		 */
		abstract void dismissIndicator();

		/**
		 * Starts animation to hide the refresh indicator. Animation will translate the indicator
		 * to its starting position pull gesture.
		 *
		 * @param pullPosition Current pull position from which to hide indicator.
		 */
		abstract void hideIndicator(float pullPosition);

		/**
		 * Starts animation to scale the refresh indicator's arrow down.
		 */
		abstract void scaleIndicatorArrowDown();

		/**
		 * Starts animation to settle the refresh indicator on the settle position.
		 *
		 * @param pullPosition Current pull position from which to settle indicator.
		 */
		abstract void settleIndicator(float pullPosition);

		/**
		 * Returns boolean flag indicating whether this wrapper is running some animations or not.
		 *
		 * @return {@code True} if some animations are running, {@code false} otherwise.
		 */
		boolean isRunning() {
<span class="nc" id="L1333">			return isPopDismissIndicatorAnimationRunning();</span>
		}

		/**
		 * Returns boolean flag indicating whether the pop/dismiss indicator animation is running
		 * or not.
		 *
		 * @return {@code True} if indicator's pop or dismiss animation is running, {@code false}
		 * otherwise.
		 */
		boolean isPopDismissIndicatorAnimationRunning() {
<span class="nc" id="L1344">			return false;</span>
		}

		/**
		 * Cancels all running animations.
		 */
		void cancel() {
<span class="nc" id="L1351">		}</span>
	}

	/**
	 * Default implementation of {@link Animations}.
	 */
	private static final class DefaultAnimations extends Animations {

		/**
		 * Creates a new instance of DefaultAnimations for the specified refresh &lt;var&gt;controller&lt;/var&gt;.
		 */
		DefaultAnimations(RefreshController controller) {
<span class="nc" id="L1363">			super(controller);</span>
<span class="nc" id="L1364">		}</span>

		/**
		 */
		@Override
		void popIndicator() {
<span class="nc" id="L1370">			controller.setIndicatorScaleFadeRatio(1f);</span>
<span class="nc" id="L1371">			controller.mIndicator.invalidateSelf();</span>
<span class="nc" id="L1372">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, false);</span>
<span class="nc" id="L1373">		}</span>

		/**
		 */
		@Override
		void dismissIndicator() {
<span class="nc" id="L1379">			controller.setIndicatorScaleFadeRatio(0f);</span>
<span class="nc" id="L1380">			controller.mIndicator.setVisible(false, false);</span>
<span class="nc" id="L1381">			controller.changeProgressMode(CircularProgressDrawable.MODE_DETERMINATE, true);</span>
<span class="nc" id="L1382">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, false);</span>
<span class="nc" id="L1383">		}</span>

		/**
		 */
		@Override
		void hideIndicator(float pullPosition) {
<span class="nc" id="L1389">			controller.setIndicatorPullPosition(0f);</span>
<span class="nc" id="L1390">			controller.mIndicator.setVisible(false, false);</span>
<span class="nc" id="L1391">			controller.mView.postDelayed(controller.UNFROZE_VIEW, 50);</span>
<span class="nc" id="L1392">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, false);</span>
<span class="nc" id="L1393">		}</span>

		/**
		 */
		@Override
		void scaleIndicatorArrowDown() {
<span class="nc" id="L1399">			controller.mIndicator.setProgressArrowScale(0f);</span>
<span class="nc" id="L1400">			controller.mIndicator.setProgressArrowVisible(false);</span>
<span class="nc" id="L1401">		}</span>

		/**
		 */
		@Override
		void settleIndicator(float pullPosition) {
<span class="nc" id="L1407">			controller.setIndicatorTopAndInvalidate((int) (controller.mRefreshSettlePosition * controller.mPullDistance));</span>
<span class="nc" id="L1408">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, false);</span>
<span class="nc" id="L1409">		}</span>
	}

	/**
	 * A {@link Animations} implementation used on Android versions above (including) {@link Build.VERSION_CODES#HONEYCOMB}.
	 */
	@TargetApi(Build.VERSION_CODES.HONEYCOMB)
	private static final class HoneyCombAnimations extends Animations {

		/**
		 * Animator used to animate indicator's top position.
		 */
<span class="nc" id="L1421">		final ObjectAnimator INDICATOR_TOP_ANIMATOR = ObjectAnimator.ofInt(this, &quot;indicatorTop&quot;, 0, 0);</span>

		/**
		 * Animator used to animate indicator's pull position.
		 */
<span class="nc" id="L1426">		final ObjectAnimator INDICATOR_PULL_POSITION_ANIMATOR = ObjectAnimator.ofFloat(this, &quot;indicatorPullPosition&quot;, 0, 0);</span>

		/**
		 * Animator used to animate indicator's scale and alpha values.
		 */
<span class="nc" id="L1431">		final ObjectAnimator INDICATOR_POP_DISMISS_ANIMATOR = ObjectAnimator.ofFloat(this, &quot;indicatorScaleFadeRatio&quot;, 0, 0);</span>

		/**
		 * Animator used to animate indicator's arrow scale value.
		 */
<span class="nc" id="L1436">		final ObjectAnimator INDICATOR_ARROW_SCALE_ANIMATOR = ObjectAnimator.ofFloat(this, &quot;indicatorArrowScale&quot;, 0, 0);</span>

		/**
		 * Creates a new instance of HoneyCombAnimations for the specified refresh &lt;var&gt;controller&lt;/var&gt;.
		 */
		HoneyCombAnimations(RefreshController refreshController) {
<span class="nc" id="L1442">			super(refreshController);</span>
<span class="nc" id="L1443">			INDICATOR_TOP_ANIMATOR.setTarget(controller);</span>
<span class="nc" id="L1444">			INDICATOR_PULL_POSITION_ANIMATOR.setTarget(controller);</span>
<span class="nc" id="L1445">			INDICATOR_POP_DISMISS_ANIMATOR.setTarget(controller);</span>
<span class="nc" id="L1446">			INDICATOR_ARROW_SCALE_ANIMATOR.setTarget(controller);</span>

<span class="nc" id="L1448">			final Animator.AnimatorListener scheduledAnimationsListener = new AnimatorListenerAdapter() {</span>

				/**
				 */
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc" id="L1454">					controller.startScheduledAnimation();</span>
<span class="nc" id="L1455">				}</span>
			};

<span class="nc" id="L1458">			INDICATOR_TOP_ANIMATOR.addListener(scheduledAnimationsListener);</span>
<span class="nc" id="L1459">			INDICATOR_TOP_ANIMATOR.addListener(new AnimatorListenerAdapter() {</span>

				/**
				 */
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc bnc" id="L1465" title="All 2 branches missed.">					if (controller.INDICATOR_INFO.top &lt; 0) {</span>
<span class="nc" id="L1466">						controller.mIndicator.setVisible(false, false);</span>
<span class="nc" id="L1467">						controller.setViewFrozen(false);</span>
					}
<span class="nc" id="L1469">				}</span>
			});
<span class="nc" id="L1471">			INDICATOR_PULL_POSITION_ANIMATOR.addListener(scheduledAnimationsListener);</span>
<span class="nc" id="L1472">			INDICATOR_PULL_POSITION_ANIMATOR.addListener(new AnimatorListenerAdapter() {</span>
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc bnc" id="L1475" title="All 4 branches missed.">					if (controller.INDICATOR_INFO.top &lt; 0 || controller.INDICATOR_INFO.scale == 0) {</span>
<span class="nc" id="L1476">						controller.mIndicator.setVisible(false, false);</span>
<span class="nc" id="L1477">						controller.setViewFrozen(false);</span>
					}
<span class="nc" id="L1479">				}</span>
			});
<span class="nc" id="L1481">			INDICATOR_POP_DISMISS_ANIMATOR.addListener(scheduledAnimationsListener);</span>
<span class="nc" id="L1482">			INDICATOR_POP_DISMISS_ANIMATOR.addListener(new AnimatorListenerAdapter() {</span>

				/**
				 */
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc bnc" id="L1488" title="All 2 branches missed.">					if (controller.hasPrivateFlag(PFLAG_POPPING_INDICATOR)) {</span>
<span class="nc" id="L1489">						controller.updatePrivateFlags(PFLAG_POPPING_INDICATOR, false);</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">					} else if (controller.hasPrivateFlag(PFLAG_DISMISSING_INDICATOR)) {</span>
<span class="nc" id="L1491">						controller.updatePrivateFlags(PFLAG_DISMISSING_INDICATOR, false);</span>
<span class="nc" id="L1492">						controller.mIndicator.setVisible(false, false);</span>
<span class="nc" id="L1493">						controller.changeProgressMode(CircularProgressDrawable.MODE_DETERMINATE, true);</span>
					}
<span class="nc" id="L1495">				}</span>
			});
<span class="nc" id="L1497">			INDICATOR_ARROW_SCALE_ANIMATOR.addListener(new AnimatorListenerAdapter() {</span>

				/**
				 */
				@Override
				public void onAnimationEnd(Animator animation) {
<span class="nc bnc" id="L1503" title="All 2 branches missed.">					if (controller.mIndicator.getProgressArrowScale() == 0) {</span>
<span class="nc" id="L1504">						controller.mIndicator.setProgressArrowVisible(false);</span>
					}
<span class="nc" id="L1506">				}</span>
			});
<span class="nc" id="L1508">		}</span>

		/**
		 */
		@Override
		void popIndicator() {
<span class="nc" id="L1514">			controller.updatePrivateFlags(PFLAG_POPPING_INDICATOR, true);</span>
<span class="nc" id="L1515">			INDICATOR_POP_DISMISS_ANIMATOR.setFloatValues(0, 1);</span>
<span class="nc" id="L1516">			INDICATOR_POP_DISMISS_ANIMATOR.setDuration(indicatorPopDuration);</span>
<span class="nc" id="L1517">			INDICATOR_POP_DISMISS_ANIMATOR.start();</span>
<span class="nc" id="L1518">		}</span>

		/**
		 */
		@Override
		void dismissIndicator() {
<span class="nc" id="L1524">			controller.updatePrivateFlags(PFLAG_DISMISSING_INDICATOR, true);</span>
<span class="nc" id="L1525">			INDICATOR_POP_DISMISS_ANIMATOR.setFloatValues(1, 0);</span>
<span class="nc" id="L1526">			INDICATOR_POP_DISMISS_ANIMATOR.setDuration(indicatorDismissDuration);</span>
<span class="nc" id="L1527">			INDICATOR_POP_DISMISS_ANIMATOR.start();</span>
<span class="nc" id="L1528">		}</span>

		/**
		 */
		@Override
		void hideIndicator(float pullPosition) {
<span class="nc" id="L1534">			INDICATOR_PULL_POSITION_ANIMATOR.setFloatValues(pullPosition, 0);</span>
<span class="nc" id="L1535">			INDICATOR_PULL_POSITION_ANIMATOR.setDuration(indicatorHideDuration);</span>
<span class="nc" id="L1536">			INDICATOR_PULL_POSITION_ANIMATOR.start();</span>
<span class="nc" id="L1537">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, true);</span>
<span class="nc" id="L1538">		}</span>

		/**
		 */
		@Override
		void scaleIndicatorArrowDown() {
<span class="nc" id="L1544">			INDICATOR_ARROW_SCALE_ANIMATOR.setFloatValues(1, 0);</span>
<span class="nc" id="L1545">			INDICATOR_ARROW_SCALE_ANIMATOR.setDuration(indicatorArrowScaleDuration);</span>
<span class="nc" id="L1546">			INDICATOR_ARROW_SCALE_ANIMATOR.start();</span>
<span class="nc" id="L1547">		}</span>

		/**
		 */
		@Override
		void settleIndicator(float pullPosition) {
<span class="nc" id="L1553">			INDICATOR_TOP_ANIMATOR.setIntValues(</span>
					(int) (pullPosition * controller.mPullDistance),
<span class="nc" id="L1555">					(int) (controller.mRefreshSettlePosition * controller.mPullDistance)</span>
			);
<span class="nc" id="L1557">			INDICATOR_TOP_ANIMATOR.setDuration(refreshSettleDuration);</span>
<span class="nc" id="L1558">			INDICATOR_TOP_ANIMATOR.start();</span>
<span class="nc" id="L1559">			controller.updatePrivateFlags(PFLAG_RUNNING_SCHEDULED_ANIMATION, true);</span>
<span class="nc" id="L1560">		}</span>

		/**
		 */
		@Override
		boolean isPopDismissIndicatorAnimationRunning() {
<span class="nc" id="L1566">			return INDICATOR_POP_DISMISS_ANIMATOR.isRunning();</span>
		}

		/**
		 */
		@Override
		void cancel() {
<span class="nc" id="L1573">			super.cancel();</span>
<span class="nc" id="L1574">			INDICATOR_TOP_ANIMATOR.cancel();</span>
<span class="nc" id="L1575">			INDICATOR_PULL_POSITION_ANIMATOR.cancel();</span>
<span class="nc" id="L1576">			INDICATOR_POP_DISMISS_ANIMATOR.cancel();</span>
<span class="nc" id="L1577">			INDICATOR_ARROW_SCALE_ANIMATOR.cancel();</span>
<span class="nc" id="L1578">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>