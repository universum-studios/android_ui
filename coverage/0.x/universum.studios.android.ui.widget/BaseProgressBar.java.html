<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BaseProgressBar.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.widget</a> &gt; <span class="el_source">BaseProgressBar.java</span></div><h1>BaseProgressBar.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.widget;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.PorterDuff;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.annotation.AnyThread;
import android.support.annotation.AttrRes;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.StyleRes;
import android.support.v4.util.Pools;
import android.util.AttributeSet;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;

import java.util.ArrayList;
import java.util.List;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.graphics.drawable.ProgressDrawable;

/**
 * A {@link ViewWidget} implementation which represents a base container for {@link ProgressDrawable}
 * to draw a progress or an indeterminate graphics and primary to handle logic for which the ProgressDrawable
 * does not have enough capacity, like starting and stopping animations.
 * &lt;p&gt;
 * BaseProgressBar supports base logic to properly present the attached ProgressDrawable like
 * measuring based on the size of the drawable and also its drawing. This class also handles base
 * management, like starting/stopping of indeterminate animations for the progress drawable based
 * on its current mode (determinate or indeterminate), other modes need to be managed by a specific
 * implementation of the BaseProgressBar class.
 * &lt;p&gt;
 * Progress drawable can be specified via {@link #setDrawable(ProgressDrawable)} and can be accessed
 * via {@link #getDrawable()} which allows some customizations of the progress drawable's appearance.
 * There are also provided (delegated) some methods for direct access to the drawable like,
 * {@link #setProgressMode(int)} {@link #setProgress(int)} or {@link #startIndeterminate()} and {@link #stopIndeterminate()}.
 *
 * &lt;h3&gt;Tinting&lt;/h3&gt;
 * Tinting is supported via Xml attributes listed below:
 * &lt;ul&gt;
 * &lt;li&gt;{@link R.attr#uiProgressTint uiProgressTint}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiProgressTintMode uiProgressTintMode}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiIndeterminateTint uiIndeterminateTint}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiIndeterminateTintMode uiIndeterminateTintMode}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiProgressBackgroundTint uiProgressBackgroundTint}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiProgressBackgroundTintMode uiProgressBackgroundTintMode}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiBackgroundTint uiBackgroundTint}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiBackgroundTintMode uiBackgroundTintMode}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Note, that on {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP} and above SDK versions
 * can be also used Xml attributes listed above where in such case will be used the native tinting.&lt;/b&gt;
 * &lt;p&gt;
 * This widget also overrides all SDK methods used to tint its components like {@link #setBackgroundTintList(android.content.res.ColorStateList)}
 * or {@link #setBackgroundTintMode(android.graphics.PorterDuff.Mode)}, so these can be used regardless
 * the current version of SDK but invoking of these methods below {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP}
 * can be done only directly upon instance of this widget otherwise {@link NoSuchMethodException}
 * will be thrown.
 * &lt;p&gt;
 * For custom tint attributes there are also provided theirs java methods like {@link #setProgressTintList(ColorStateList)}
 * or {@link #setIndeterminateTintList(ColorStateList)}.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * See {@link ViewWidget},
 * {@link R.styleable#Ui_ProgressBar BaseProgressBar Attributes}
 *
 * @author Martin Albedinsky
 */
public abstract class BaseProgressBar&lt;D extends ProgressDrawable&gt; extends ViewWidget
		implements
		ProgressDrawable.AnimationCallback,
		ProgressDrawable.ExplodeAnimationCallback {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Listener which can receive callbacks about &lt;b&gt;started&lt;/b&gt; or &lt;b&gt;stopped&lt;/b&gt; animation session
	 * of progress drawable.
	 */
	public interface OnProgressAnimationListener {

		/**
		 * Invoked whenever a new animation session is started for the specified progress &lt;var&gt;drawable&lt;/var&gt;.
		 *
		 * @param progressBar A progress bar to which is the specified drawable attached to.
		 * @param drawable    The progress drawable for which has been requested new animation session
		 *                    by {@link ProgressDrawable#start()} and the drawable has been before that
		 *                    call in the idle mode.
		 */
		void onStarted(@NonNull BaseProgressBar progressBar, @NonNull ProgressDrawable drawable);

		/**
		 * Invoked whenever the current animation sessions is stopped for the specified progress
		 * &lt;var&gt;drawable&lt;/var&gt;.
		 *
		 * @param progressBar A progress bar to which is the specified drawable attached to.
		 * @param drawable    The progress drawable for which has been stopped its current animation
		 *                    sessions by {@link ProgressDrawable#stop()} or {@link ProgressDrawable#stopImmediate()}
		 *                    and the drawable has been before that call in the animation mode.
		 */
		void onStopped(@NonNull BaseProgressBar progressBar, @NonNull ProgressDrawable drawable);
	}

	/**
	 * Listener which can receive callbacks about &lt;b&gt;exploded&lt;/b&gt; and &lt;b&gt;imploded&lt;/b&gt; thickness of
	 * progress drawable.
	 */
	public interface OnProgressExplodeAnimationListener {

		/**
		 * Invoked whenever an explosion of the specified progress &lt;var&gt;drawable&lt;/var&gt; is finished.
		 *
		 * @param progressBar A progress bar to which is the specified drawable attached to.
		 * @param drawable    The progress drawable for which has been explosion of its thickness
		 *                    finished after {@link ProgressDrawable#explode()} has been called upon
		 *                    the drawable.
		 */
		void onExploded(@NonNull BaseProgressBar progressBar, @NonNull ProgressDrawable drawable);

		/**
		 * Invoked whenever an implosion of the specified progress &lt;var&gt;drawable&lt;/var&gt; is finished.
		 *
		 * @param progressBar A progress bar to which is the specified drawable attached to.
		 * @param drawable    The progress drawable for which has been implosion of its thickness
		 *                    finished after {@link ProgressDrawable#implode()} has been called upon
		 *                    the drawable.
		 */
		void onImploded(@NonNull BaseProgressBar progressBar, @NonNull ProgressDrawable drawable);
	}

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;BaseProgressBar&quot;;

	/**
	 * Flag copied from {@link ProgressDrawable#DETERMINATE} for better access.
	 */
	private static final int DETERMINATE = ProgressDrawable.DETERMINATE;

	/**
	 * Flag copied from {@link ProgressDrawable#INDETERMINATE} for better access.
	 */
	private static final int INDETERMINATE = ProgressDrawable.INDETERMINATE;

	/**
	 * Delay for posting of an accessibility events from this view.
	 */
	private static final long ACCESSIBILITY_EVENT_DELAY = 200;

	/**
	 * Flag indicating whether {@link #mRefreshProgressRunnable} has been posted or not.
	 */
	private static final int PFLAG_REFRESH_PROGRESS_POSTED = 0x00008000;

	/**
	 * Flag indicating whether an indeterminate animation should be stopped after the progress
	 * drawable has been imploded.
	 */
	private static final int PFLAG_STOP_INDETERMINATE_AFTER_IMPLOSION = 0x00010000;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Lock used for synchronized operations.
	 */
<span class="nc" id="L204">	private static final Object LOCK = new Object();</span>

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Drawable used to draw the progress.
	 */
	D mDrawable;

	/**
	 * Current mode of this progress bar determining the drawing behaviour of the progress drawable.
	 */
	int mMode;

	/**
	 * Progress drawable's dimension.
	 */
	private int mDrawableWidth, mDrawableHeight;

	/**
	 * Set of private flags specific for this widget.
	 */
<span class="nc" id="L228">	private int mPrivateFlags = PrivateFlags.PFLAG_ALLOWS_DEFAULT_SELECTION;</span>

	/**
	 * Maximum allowed value of progress which can be set to this progress bar.
	 */
<span class="nc" id="L233">	int mMax = ProgressDrawable.MAX_PROGRESS;</span>

	/**
	 * Id of the UI thread used to check if a specific method call is on UI thread or not.
	 */
	long mUiThreadId;

	/**
	 * Current progress value of this progress bar set by {@link #setProgress(int)}.
	 */
	private int mProgress;

	/**
	 * Animation callback delegate for the current ProgressDrawable.
	 */
	private OnProgressAnimationListener mProgressAnimationListener;

	/**
	 * Explode animation callback delegate for the current ProgressDrawable.
	 */
	private OnProgressExplodeAnimationListener mProgressExplodeAnimationListener;

	/**
	 * Data used when tinting components of this view.
	 */
	private TintInfo mTintInfo;

	/**
	 * Task used to refresh progress from the background thread.
	 */
	private RefreshProgressRunnable mRefreshProgressRunnable;

	/**
	 * Task used to post an accessibility event for the changed progress.
	 */
	private AccessibilityEventSender mAccessibilityEventSender;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Same as {@link #BaseProgressBar(android.content.Context, android.util.AttributeSet)}
	 * without attributes.
	 */
	BaseProgressBar(@NonNull Context context) {
<span class="nc" id="L279">		this(context, null);</span>
<span class="nc" id="L280">	}</span>

	/**
	 * Same as {@link #BaseProgressBar(android.content.Context, android.util.AttributeSet, int)}
	 * with &lt;code&gt;0&lt;/code&gt; as attribute for default style.
	 */
	BaseProgressBar(@NonNull Context context, @Nullable AttributeSet attrs) {
<span class="nc" id="L287">		this(context, attrs, 0);</span>
<span class="nc" id="L288">	}</span>

	/**
	 * Same as {@link #BaseProgressBar(android.content.Context, android.util.AttributeSet, int, int)}
	 * with {@code 0} as default style.
	 */
	BaseProgressBar(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) {
<span class="nc" id="L295">		super(context, attrs, defStyleAttr);</span>
<span class="nc" id="L296">		this.init(context, attrs, defStyleAttr, 0);</span>
<span class="nc" id="L297">	}</span>

	/**
	 * Creates a new instance of BaseProgressBar for the given &lt;var&gt;context&lt;/var&gt;.
	 *
	 * @param context      Context in which will be the new view presented.
	 * @param attrs        Set of Xml attributes used to configure the new instance of this view.
	 * @param defStyleAttr An attribute which contains a reference to a default style resource for
	 *                     this view within a theme of the given context.
	 * @param defStyleRes  Resource id of the default style for the new view.
	 */
	@TargetApi(Build.VERSION_CODES.LOLLIPOP)
	BaseProgressBar(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
<span class="nc" id="L310">		super(context, attrs, defStyleAttr, defStyleRes);</span>
<span class="nc" id="L311">		this.init(context, attrs, defStyleAttr, defStyleRes);</span>
<span class="nc" id="L312">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Called from one of constructors of this view to perform its initialization.
	 * &lt;p&gt;
	 * Initialization is done via parsing of the specified &lt;var&gt;attrs&lt;/var&gt; set and obtaining for
	 * this view specific data from it that can be used to configure this new view instance. The
	 * specified &lt;var&gt;defStyleAttr&lt;/var&gt; and &lt;var&gt;defStyleRes&lt;/var&gt; are used to obtain default data
	 * from the current theme provided by the specified &lt;var&gt;context&lt;/var&gt;.
	 */
	@SuppressLint(&quot;NewApi&quot;)
	private void init(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
<span class="nc" id="L328">		this.mUiThreadId = Thread.currentThread().getId();</span>
		// Use software layer that is required for proper drawing work of progress drawables.
<span class="nc bnc" id="L330" title="All 2 branches missed.">		if (ProgressDrawable.REQUIRES_SOFTWARE_LAYER) {</span>
<span class="nc" id="L331">			setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span>
		}
<span class="nc" id="L333">		onAttachDrawable();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (mDrawable == null) {</span>
<span class="nc" id="L335">			throw new IllegalArgumentException(&quot;No progress drawable has been attached.&quot;);</span>
		}
<span class="nc" id="L337">		final TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.Ui_ProgressBar, defStyleAttr, defStyleRes);</span>
<span class="nc" id="L338">		this.processTintValues(context, attributes);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">		for (int i = 0; i &lt; attributes.getIndexCount(); i++) {</span>
<span class="nc" id="L340">			final int index = attributes.getIndex(i);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">			if (index == R.styleable.Ui_ProgressBar_android_max) {</span>
<span class="nc" id="L342">				setMax(attributes.getInt(index, getMax()));</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_android_progress) {</span>
<span class="nc" id="L344">				setProgress(attributes.getInt(index, mProgress));</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiColorProgress) {</span>
<span class="nc" id="L346">				mDrawable.setColor(attributes.getColor(index, mDrawable.getColor()));</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiColorsProgress) {</span>
<span class="nc" id="L348">				final int colorsResId = attributes.getResourceId(index, -1);</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">				if (colorsResId &gt; 0 &amp;&amp; !isInEditMode()) {</span>
<span class="nc" id="L350">					mDrawable.setColors(context.getResources().getIntArray(colorsResId));</span>
				}
<span class="nc bnc" id="L352" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiMultiColored) {</span>
<span class="nc" id="L353">				mDrawable.setMultiColored(attributes.getBoolean(index, mDrawable.isMultiColored()));</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiColorProgressBackground) {</span>
<span class="nc" id="L355">				mDrawable.setBackgroundColor(attributes.getInt(index, Color.TRANSPARENT));</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_android_thickness) {</span>
<span class="nc" id="L357">				mDrawable.setThickness(attributes.getDimensionPixelSize(index, 0));</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiRounded) {</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">				mDrawable.setRounded(!isInEditMode() &amp;&amp; attributes.getBoolean(index, mDrawable.isRounded()));</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_ProgressBar_uiIndeterminateSpeed) {</span>
<span class="nc" id="L361">				mDrawable.setIndeterminateSpeed(attributes.getFloat(index, 1));</span>
			}
		}
<span class="nc" id="L364">		mDrawable.setInEditMode(isInEditMode());</span>
<span class="nc" id="L365">		this.applyProgressTint();</span>
<span class="nc" id="L366">		this.applyIndeterminateTint();</span>
<span class="nc" id="L367">		this.applyProgressBackgroundTint();</span>
<span class="nc" id="L368">	}</span>

	/**
	 * Called from the constructor to process tint values for this view.
	 *
	 * @param context    The context passed to constructor.
	 * @param typedArray TypedArray obtained for styleable attributes specific for this view.
	 */
	@SuppressWarnings(&quot;All&quot;)
	private void processTintValues(Context context, TypedArray typedArray) {
<span class="nc" id="L378">		this.ensureTintInfo();</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (typedArray.hasValue(R.styleable.Ui_ProgressBar_uiProgressTint)) {</span>
<span class="nc" id="L380">			mTintInfo.progressTintList = typedArray.getColorStateList(R.styleable.Ui_ProgressBar_uiProgressTint);</span>
		}
<span class="nc bnc" id="L382" title="All 2 branches missed.">		if (typedArray.hasValue(R.styleable.Ui_ProgressBar_uiIndeterminateTint)) {</span>
<span class="nc" id="L383">			mTintInfo.indeterminateTintList = typedArray.getColorStateList(R.styleable.Ui_ProgressBar_uiIndeterminateTint);</span>
		}
<span class="nc bnc" id="L385" title="All 2 branches missed.">		if (typedArray.hasValue(R.styleable.Ui_ProgressBar_uiProgressBackgroundTint)) {</span>
<span class="nc" id="L386">			mTintInfo.backgroundTintList = typedArray.getColorStateList(R.styleable.Ui_ProgressBar_uiProgressBackgroundTint);</span>
		}
<span class="nc" id="L388">		mTintInfo.progressTintMode = TintManager.parseTintMode(</span>
<span class="nc" id="L389">				typedArray.getInt(R.styleable.Ui_ProgressBar_uiProgressTintMode, 0),</span>
				PorterDuff.Mode.SRC_IN
		);
<span class="nc" id="L392">		mTintInfo.indeterminateTintMode = TintManager.parseTintMode(</span>
<span class="nc" id="L393">				typedArray.getInt(R.styleable.Ui_ProgressBar_uiIndeterminateTintMode, 0),</span>
				PorterDuff.Mode.SRC_IN
		);
<span class="nc" id="L396">		mTintInfo.backgroundTintMode = TintManager.parseTintMode(</span>
<span class="nc" id="L397">				typedArray.getInt(R.styleable.Ui_ProgressBar_uiProgressBackgroundTintMode, 0),</span>
				PorterDuff.Mode.SRC_IN
		);
		// If there is no tint mode specified within style/xml do not tint at all.
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (mTintInfo.backgroundTintMode == null) mTintInfo.backgroundTintList = null;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		if (mTintInfo.progressTintMode == null) mTintInfo.progressTintList = null;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">		if (mTintInfo.indeterminateTintMode == null) mTintInfo.indeterminateTintList = null;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		mTintInfo.hasBackgroundTintList = mTintInfo.backgroundTintList != null;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		mTintInfo.hasBackgroundTinMode = mTintInfo.backgroundTintMode != null;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">		mTintInfo.hasProgressTintList = mTintInfo.progressTintList != null;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">		mTintInfo.hasProgressTintMode = mTintInfo.progressTintMode != null;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		mTintInfo.hasIndeterminateTintList = mTintInfo.indeterminateTintList != null;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">		mTintInfo.hasIndeterminateTintMode = mTintInfo.indeterminateTintMode != null;</span>
<span class="nc" id="L410">	}</span>

	/**
	 * Ensures that the tint info object is initialized.
	 */
	private void ensureTintInfo() {
<span class="nc bnc" id="L416" title="All 2 branches missed.">		if (mTintInfo == null) this.mTintInfo = new TintInfo();</span>
<span class="nc" id="L417">	}</span>

	/**
	 * Invoked to attach progress drawable to this progress bar. This is invoked when this progress
	 * bar is being first time created before parsing of any values from AttributeSet.
	 */
	abstract void onAttachDrawable();

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityEvent(@NonNull AccessibilityEvent event) {
<span class="nc" id="L430">		super.onInitializeAccessibilityEvent(event);</span>
<span class="nc" id="L431">		event.setClassName(BaseProgressBar.class.getName());</span>
<span class="nc" id="L432">		event.setItemCount(mMax);</span>
<span class="nc" id="L433">		event.setCurrentItemIndex(mProgress);</span>
<span class="nc" id="L434">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityNodeInfo(@NonNull AccessibilityNodeInfo info) {
<span class="nc" id="L441">		super.onInitializeAccessibilityNodeInfo(info);</span>
<span class="nc" id="L442">		info.setClassName(BaseProgressBar.class.getName());</span>
<span class="nc" id="L443">	}</span>

	/**
	 * Starts an indeterminate animation session (if not running already) for the progress
	 * drawable with graphics explosion if requested. Use this method to start the indeterminate
	 * animation if you stopped it before by {@link #stopIndeterminate()} or
	 * {@link #stopIndeterminateImmediate()}.
	 */
	public void startIndeterminate() {
<span class="nc bnc" id="L452" title="All 2 branches missed.">		if (canStartIndeterminate()) mDrawable.start();</span>
<span class="nc" id="L453">	}</span>

	/**
	 * Checks whether we can start indeterminate animation on the current progress drawable or not.
	 *
	 * @return {@code True} if the drawable is available and it is not running currently any animation
	 * and the current mode supports indeterminate animation, {@code false} otherwise.
	 */
	private boolean canStartIndeterminate() {
<span class="nc bnc" id="L462" title="All 4 branches missed.">		return mDrawable != null &amp;&amp;</span>
				mMode != DETERMINATE &amp;&amp;
<span class="nc bnc" id="L464" title="All 4 branches missed.">				!mDrawable.isRunning() &amp;&amp;</span>
				(mPrivateFlags &amp; PrivateFlags.PFLAG_ATTACHED_TO_WINDOW) != 0;
	}

	/**
	 * Stops the current (if running) indeterminate animation session for the progress drawable.
	 *
	 * @see ProgressDrawable#stopImmediate()
	 */
	public void stopIndeterminateImmediate() {
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if (canStopIndeterminate()) {</span>
<span class="nc" id="L475">			mDrawable.stopImmediate();</span>
		}
<span class="nc" id="L477">	}</span>

	/**
	 * Like {@link #stopIndeterminateImmediate()}, but this will wait until the progress drawable
	 * finishes drawing of its indeterminate graphics and than stops its animation session.
	 *
	 * @see ProgressDrawable#stop()
	 */
	public void stopIndeterminate() {
<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (canStopIndeterminate()) mDrawable.stop();</span>
<span class="nc" id="L487">	}</span>

	/**
	 * Checks whether we can stop current indeterminate animation running on the current progress
	 * drawable or not.
	 *
	 * @return {@code True} if the drawable is available and it is running currently indeterminate
	 * animation and the current mode supports indeterminate animation, {@code false} otherwise.
	 */
	private boolean canStopIndeterminate() {
<span class="nc bnc" id="L497" title="All 6 branches missed.">		return mDrawable != null &amp;&amp; mMode != DETERMINATE &amp;&amp; mDrawable.isRunning();</span>
	}

	/**
	 * Delegate method for {@link ProgressDrawable#explode()}.
	 */
	public void explodeProgress() {
<span class="nc bnc" id="L504" title="All 2 branches missed.">		if (mDrawable != null) {</span>
<span class="nc" id="L505">			mDrawable.setExploded(false);</span>
<span class="nc" id="L506">			mDrawable.explode();</span>
		}
<span class="nc" id="L508">	}</span>

	/**
	 * Delegate method for {@link ProgressDrawable#implode()}.
	 */
	public void implodeProgress() {
<span class="nc bnc" id="L514" title="All 2 branches missed.">		if (mDrawable != null) {</span>
<span class="nc" id="L515">			mDrawable.setExploded(true);</span>
<span class="nc" id="L516">			mDrawable.implode();</span>
		}
<span class="nc" id="L518">	}</span>

	/**
	 * Delegate method for {@link ProgressDrawable#setExploded(boolean)}.
	 */
	public void setProgressExploded(boolean exploded) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">		if (mDrawable != null) mDrawable.setExploded(exploded);</span>
<span class="nc" id="L525">	}</span>

	/**
	 * Delegate method for {@link ProgressDrawable#isExploded()}.
	 */
	public boolean isProgressExploded() {
<span class="nc bnc" id="L531" title="All 4 branches missed.">		return mDrawable != null &amp;&amp; mDrawable.isExploded();</span>
	}

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.HONEYCOMB)
	public void jumpDrawablesToCurrentState() {
<span class="nc" id="L539">		super.jumpDrawablesToCurrentState();</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if (mDrawable != null) mDrawable.jumpToCurrentState();</span>
<span class="nc" id="L541">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.LOLLIPOP)
	public void drawableHotspotChanged(float x, float y) {
<span class="nc" id="L548">		super.drawableHotspotChanged(x, y);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">		if (mDrawable != null) mDrawable.setHotspot(x, y);</span>
<span class="nc" id="L550">	}</span>

	/**
	 */
	@Override
	public void onStarted(@NonNull ProgressDrawable drawable) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">		if (mProgressAnimationListener != null)</span>
<span class="nc" id="L557">			mProgressAnimationListener.onStarted(this, drawable);</span>
<span class="nc" id="L558">	}</span>

	/**
	 */
	@Override
	public void onStopped(@NonNull ProgressDrawable drawable) {
<span class="nc bnc" id="L564" title="All 2 branches missed.">		if (mProgressAnimationListener != null)</span>
<span class="nc" id="L565">			mProgressAnimationListener.onStopped(this, drawable);</span>
<span class="nc" id="L566">	}</span>

	/**
	 */
	@Override
	public void onExploded(@NonNull ProgressDrawable drawable) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">		if (mProgressExplodeAnimationListener != null)</span>
<span class="nc" id="L573">			mProgressExplodeAnimationListener.onExploded(this, drawable);</span>
<span class="nc" id="L574">	}</span>

	/**
	 */
	@Override
	public void onImploded(@NonNull ProgressDrawable drawable) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PFLAG_STOP_INDETERMINATE_AFTER_IMPLOSION) != 0) {</span>
<span class="nc" id="L581">			this.updatePrivateFlags(PFLAG_STOP_INDETERMINATE_AFTER_IMPLOSION, false);</span>
<span class="nc" id="L582">			drawable.stopImmediate();</span>
		}
<span class="nc bnc" id="L584" title="All 2 branches missed.">		if (mProgressExplodeAnimationListener != null) {</span>
<span class="nc" id="L585">			mProgressExplodeAnimationListener.onImploded(this, drawable);</span>
		}
<span class="nc" id="L587">	}</span>

	/**
	 * Registers a callback to be invoked whenever a new animation session is &lt;b&gt;started&lt;/b&gt; or
	 * the current one is &lt;b&gt;stopped&lt;/b&gt; for the progress drawable attached to this progress bar.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnProgressAnimationListener(@Nullable OnProgressAnimationListener listener) {
<span class="nc" id="L596">		this.mProgressAnimationListener = listener;</span>
<span class="nc" id="L597">	}</span>

	/**
	 * Registers a callback to be invoked whenever &lt;b&gt;explode&lt;/b&gt; or &lt;b&gt;implode&lt;/b&gt; animation is finished
	 * for the progress drawable attached to this progress bar.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnProgressExplodeAnimationListener(@Nullable OnProgressExplodeAnimationListener listener) {
<span class="nc" id="L606">		this.mProgressExplodeAnimationListener = listener;</span>
<span class="nc" id="L607">	}</span>

	/**
	 * Applies a tint to the progress graphics of the drawable, if specified. This call does not modify
	 * the current tint mode, which is {@link android.graphics.PorterDuff.Mode#SRC_IN} by default.
	 * &lt;p&gt;
	 * Subsequent calls to {@link #setDrawable(ProgressDrawable)} will automatically mutate the drawable
	 * and apply the specified tint and tint mode using {@link ProgressDrawable#setProgressTintList(android.content.res.ColorStateList)}.
	 *
	 * @param tint The tint to apply, may be {@code null} to clear the current tint.
	 * @see R.attr#uiProgressTint ui:uiProgressTint
	 * @see #getProgressTintList()
	 * @see ProgressDrawable#setProgressTintList(android.content.res.ColorStateList)
	 */
	public void setProgressTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L622">		this.ensureTintInfo();</span>
<span class="nc" id="L623">		mTintInfo.progressTintList = tint;</span>
<span class="nc" id="L624">		mTintInfo.hasProgressTintList = true;</span>
<span class="nc" id="L625">		this.applyProgressTint();</span>
<span class="nc" id="L626">	}</span>

	/**
	 * Returns the tint applied to the progress graphics of the progress drawable, if specified.
	 *
	 * @return The progress graphics tint.
	 * @see #setProgressTintList(android.content.res.ColorStateList)
	 */
	@Nullable
	public ColorStateList getProgressTintList() {
<span class="nc bnc" id="L636" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.progressTintList : null;</span>
	}

	/**
	 * Specifies the blending mode used to apply the tint specified by {@link #setProgressTintList(android.content.res.ColorStateList)}}
	 * to the progress graphics of the progress drawable. The default mode is {@link android.graphics.PorterDuff.Mode#SRC_IN}.
	 *
	 * @param tintMode The blending mode used to apply the tint, may be {@code null} to clear the
	 *                 current tint.
	 * @see R.attr#uiProgressTintMode ui:uiProgressTintMode
	 * @see #getProgressTintMode()
	 * @see ProgressDrawable#setProgressTintMode(android.graphics.PorterDuff.Mode)
	 */
	public void setProgressTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L650">		this.ensureTintInfo();</span>
<span class="nc" id="L651">		mTintInfo.progressTintMode = tintMode;</span>
<span class="nc" id="L652">		mTintInfo.hasProgressTintMode = true;</span>
<span class="nc" id="L653">		this.applyProgressTint();</span>
<span class="nc" id="L654">	}</span>

	/**
	 * Returns the blending mode used to apply the tint to the progress graphics of the progress
	 * drawable, if specified.
	 *
	 * @return The progress graphics blending mode used to apply the tint.
	 * @see #setProgressTintMode(android.graphics.PorterDuff.Mode)
	 */
	@Nullable
	public PorterDuff.Mode getProgressTintMode() {
<span class="nc bnc" id="L665" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.tintMode : null;</span>
	}

	/**
	 * Applies current tint from {@link #mTintInfo} to the progress graphics of the current progress
	 * drawable.
	 *
	 * @return {@code True} if the tint has been applied or cleared, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private boolean applyProgressTint() {
<span class="nc" id="L676">		this.applyProgressBackgroundTint();</span>
<span class="nc bnc" id="L677" title="All 8 branches missed.">		if (mTintInfo == null ||</span>
				(!mTintInfo.hasProgressTintList &amp;&amp; !mTintInfo.hasProgressTintMode) ||
				mDrawable == null) {
<span class="nc" id="L680">			return false;</span>
		}
<span class="nc" id="L682">		mDrawable = (D) mDrawable.mutate();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">		if (mTintInfo.hasProgressTintList) {</span>
<span class="nc" id="L684">			mDrawable.setProgressTintList(mTintInfo.progressTintList);</span>
		}
<span class="nc bnc" id="L686" title="All 2 branches missed.">		if (mTintInfo.hasProgressTintMode) {</span>
<span class="nc" id="L687">			mDrawable.setProgressTintMode(mTintInfo.progressTintMode);</span>
		}

<span class="nc bnc" id="L690" title="All 2 branches missed.">		if (mDrawable.isStateful()) {</span>
<span class="nc" id="L691">			mDrawable.setState(getDrawableState());</span>
		}
<span class="nc" id="L693">		return true;</span>
	}

	/**
	 * Applies a tint to the indeterminate graphics of the drawable, if specified. This call does not
	 * modify the current tint mode, which is {@link android.graphics.PorterDuff.Mode#SRC_IN} by default.
	 * &lt;p&gt;
	 * Subsequent calls to {@link #setDrawable(ProgressDrawable)} will automatically mutate the drawable
	 * and apply the specified tint and tint mode using {@link ProgressDrawable#setIndeterminateTintList(android.content.res.ColorStateList)}.
	 *
	 * @param tint The tint to apply, may be {@code null} to clear the current tint.
	 * @see R.attr#uiIndeterminateTint ui:uiIndeterminateTint
	 * @see #getIndeterminateTintList()
	 * @see ProgressDrawable#setIndeterminateTintList(android.content.res.ColorStateList)
	 */
	public void setIndeterminateTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L709">		this.ensureTintInfo();</span>
<span class="nc" id="L710">		mTintInfo.indeterminateTintList = tint;</span>
<span class="nc" id="L711">		mTintInfo.hasIndeterminateTintList = true;</span>
<span class="nc" id="L712">		this.applyIndeterminateTint();</span>
<span class="nc" id="L713">	}</span>

	/**
	 * Returns the tint applied to the indeterminate graphics of the progress drawable, if specified.
	 *
	 * @return The progress graphics tint.
	 * @see #setIndeterminateTintList(android.content.res.ColorStateList)
	 */
	@Nullable
	public ColorStateList getIndeterminateTintList() {
<span class="nc bnc" id="L723" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.indeterminateTintList : null;</span>
	}

	/**
	 * Specifies the blending mode used to apply the tint specified by {@link #setIndeterminateTintList(android.content.res.ColorStateList)}}
	 * to the indeterminate graphics of the progress drawable. The default mode is {@link android.graphics.PorterDuff.Mode#SRC_IN}.
	 *
	 * @param tintMode The blending mode used to apply the tint, may be {@code null} to clear the
	 *                 current tint.
	 * @see R.attr#uiIndeterminateTintMode ui:uiIndeterminateTintMode
	 * @see #getIndeterminateTintMode()
	 * @see ProgressDrawable#setIndeterminateTintMode(android.graphics.PorterDuff.Mode)
	 */
	public void setIndeterminateTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L737">		this.ensureTintInfo();</span>
<span class="nc" id="L738">		mTintInfo.indeterminateTintMode = tintMode;</span>
<span class="nc" id="L739">		mTintInfo.hasIndeterminateTintMode = true;</span>
<span class="nc" id="L740">		this.applyIndeterminateTint();</span>
<span class="nc" id="L741">	}</span>

	/**
	 * Returns the blending mode used to apply the tint to the indeterminate graphics of the progress
	 * drawable, if specified.
	 *
	 * @return The indeterminate graphics blending mode used to apply the tint.
	 * @see #setIndeterminateTintMode(android.graphics.PorterDuff.Mode)
	 */
	@Nullable
	public PorterDuff.Mode getIndeterminateTintMode() {
<span class="nc bnc" id="L752" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.indeterminateTintMode : null;</span>
	}

	/**
	 * Applies current tint from {@link #mTintInfo} to the indeterminate graphics of the current progress
	 * drawable.
	 *
	 * @return {@code True} if the tint has been applied or cleared, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private boolean applyIndeterminateTint() {
<span class="nc" id="L763">		this.applyProgressBackgroundTint();</span>
<span class="nc bnc" id="L764" title="All 8 branches missed.">		if (mTintInfo == null ||</span>
				(!mTintInfo.hasIndeterminateTintList &amp;&amp; !mTintInfo.hasIndeterminateTintMode) ||
				mDrawable == null) {
<span class="nc" id="L767">			return false;</span>
		}
<span class="nc" id="L769">		this.mDrawable = (D) mDrawable.mutate();</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (mTintInfo.hasIndeterminateTintList) {</span>
<span class="nc" id="L771">			mDrawable.setIndeterminateTintList(mTintInfo.indeterminateTintList);</span>
		}
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if (mTintInfo.hasIndeterminateTintMode) {</span>
<span class="nc" id="L774">			mDrawable.setIndeterminateTintMode(mTintInfo.indeterminateTintMode);</span>
		}

<span class="nc bnc" id="L777" title="All 2 branches missed.">		if (mDrawable.isStateful()) {</span>
<span class="nc" id="L778">			mDrawable.setState(getDrawableState());</span>
		}
<span class="nc" id="L780">		return true;</span>
	}

	/**
	 * Applies a tint to the background graphics of the drawable, if specified. This call does not
	 * modify the current tint mode, which is {@link android.graphics.PorterDuff.Mode#SRC_IN} by default.
	 * &lt;p&gt;
	 * Subsequent calls to {@link #setDrawable(ProgressDrawable)} will automatically mutate the drawable
	 * and apply the specified tint and tint mode using {@link ProgressDrawable#setBackgroundTintList(android.content.res.ColorStateList)}.
	 *
	 * @param tint The tint to apply, may be {@code null} to clear the current tint.
	 * @see R.attr#uiProgressBackgroundTint ui:uiProgressBackgroundTint
	 * @see #getProgressBackgroundTintList()
	 * @see ProgressDrawable#setBackgroundTintList(android.content.res.ColorStateList)
	 */
	public void setProgressBackgroundTintList(@Nullable ColorStateList tint) {
<span class="nc bnc" id="L796" title="All 2 branches missed.">		if (UiConfig.MATERIALIZED) {</span>
<span class="nc" id="L797">			super.setBackgroundTintList(tint);</span>
<span class="nc" id="L798">			return;</span>
		}
<span class="nc" id="L800">		this.ensureTintInfo();</span>
<span class="nc" id="L801">		mTintInfo.backgroundTintList = tint;</span>
<span class="nc" id="L802">		mTintInfo.hasBackgroundTintList = true;</span>
<span class="nc" id="L803">		this.applyProgressBackgroundTint();</span>
<span class="nc" id="L804">	}</span>

	/**
	 * Returns the tint applied to the background graphics of the progress drawable, if specified.
	 *
	 * @return The background graphics tint.
	 * @see #setProgressBackgroundTintList(android.content.res.ColorStateList)
	 */
	@Nullable
	public ColorStateList getProgressBackgroundTintList() {
<span class="nc bnc" id="L814" title="All 2 branches missed.">		if (UiConfig.MATERIALIZED) {</span>
<span class="nc" id="L815">			return super.getBackgroundTintList();</span>
		}
<span class="nc bnc" id="L817" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.backgroundTintList : null;</span>
	}

	/**
	 * Specifies the blending mode used to apply the tint specified by {@link #setProgressBackgroundTintList(android.content.res.ColorStateList)}}
	 * to the background graphics of the progress drawable. The default mode is {@link android.graphics.PorterDuff.Mode#SRC_IN}.
	 *
	 * @param tintMode The blending mode used to apply the tint, may be {@code null} to clear the
	 *                 current tint.
	 * @see R.attr#uiProgressBackgroundTintMode ui:uiProgressBackgroundTintMode
	 * @see #getProgressBackgroundTintMode()
	 * @see ProgressDrawable#setBackgroundTintMode(android.graphics.PorterDuff.Mode)
	 */
	public void setProgressBackgroundTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc bnc" id="L831" title="All 2 branches missed.">		if (UiConfig.MATERIALIZED) {</span>
<span class="nc" id="L832">			super.setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L833">			return;</span>
		}
<span class="nc" id="L835">		this.ensureTintInfo();</span>
<span class="nc" id="L836">		mTintInfo.backgroundTintMode = tintMode;</span>
<span class="nc" id="L837">		mTintInfo.hasBackgroundTinMode = true;</span>
<span class="nc" id="L838">		this.applyProgressBackgroundTint();</span>
<span class="nc" id="L839">	}</span>

	/**
	 * Returns the blending mode used to apply the tint to the background graphics of the progress
	 * drawable, if specified.
	 *
	 * @return The background graphics blending mode used to apply the tint.
	 * @see #setProgressBackgroundTintMode(android.graphics.PorterDuff.Mode)
	 */
	@Nullable
	public PorterDuff.Mode getProgressBackgroundTintMode() {
<span class="nc bnc" id="L850" title="All 2 branches missed.">		if (UiConfig.MATERIALIZED) {</span>
<span class="nc" id="L851">			return super.getBackgroundTintMode();</span>
		}
<span class="nc bnc" id="L853" title="All 2 branches missed.">		return mTintInfo != null ? mTintInfo.backgroundTintMode : null;</span>
	}

	/**
	 * Applies current tint from {@link #mTintInfo} to the progress background graphics of the current
	 * progress drawable.
	 *
	 * @return {@code True} if the tint has been applied or cleared, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private boolean applyProgressBackgroundTint() {
<span class="nc bnc" id="L864" title="All 8 branches missed.">		if (mTintInfo == null ||</span>
				(!mTintInfo.hasBackgroundTintList &amp;&amp; !mTintInfo.hasBackgroundTinMode) ||
				mDrawable == null) {
<span class="nc" id="L867">			return false;</span>
		}
<span class="nc" id="L869">		this.mDrawable = (D) mDrawable.mutate();</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">		if (mTintInfo.hasBackgroundTintList) {</span>
<span class="nc" id="L871">			mDrawable.setBackgroundTintList(mTintInfo.backgroundTintList);</span>
		}
<span class="nc bnc" id="L873" title="All 2 branches missed.">		if (mTintInfo.hasBackgroundTinMode) {</span>
<span class="nc" id="L874">			mDrawable.setBackgroundTintMode(mTintInfo.backgroundTintMode);</span>
		}
<span class="nc bnc" id="L876" title="All 2 branches missed.">		if (mDrawable.isStateful()) {</span>
<span class="nc" id="L877">			mDrawable.setState(getDrawableState());</span>
		}
<span class="nc" id="L879">		return true;</span>
	}

	/**
	 * Sets the drawable used to draw a progress or an indeterminate graphics of this progress bar.
	 * Whether this progress bar draws the progress or indeterminate graphics depends on its current
	 * mode specified by {@link #setProgressMode(int)}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that the specified drawable and its appearance can be updated directly by accessing
	 * it, using {@link #getDrawable()}, but there are some methods which are delegated by this progress
	 * bar to its attached drawable and should be called upon this progress bar like {@link #setProgress(int)}
	 * or {@link #setProgressMode(int)}. See {@link BaseProgressBar class} overview for more info.
	 *
	 * @param drawable The desired progress drawable. May be {@code null} to clear the current drawable.
	 */
	public void setDrawable(@Nullable D drawable) {
<span class="nc bnc" id="L895" title="All 2 branches missed.">		if (mDrawable != drawable) {</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">			if (mDrawable != null) {</span>
<span class="nc" id="L897">				mDrawable.setCallback(null);</span>
<span class="nc" id="L898">				mDrawable.setAnimationCallback(null);</span>
<span class="nc" id="L899">				mDrawable.setExplodeAnimationCallback(null);</span>
<span class="nc" id="L900">				unscheduleDrawable(mDrawable);</span>
			}
<span class="nc bnc" id="L902" title="All 2 branches missed.">			if (drawable != null) {</span>
<span class="nc" id="L903">				drawable.setCallback(this);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">				drawable.setVisible(getVisibility() == View.VISIBLE, false);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">				if (mDrawableWidth != drawable.getIntrinsicWidth() ||</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">						mDrawableHeight != drawable.getIntrinsicHeight()) {</span>
<span class="nc" id="L907">					this.mDrawableWidth = drawable.getIntrinsicWidth();</span>
<span class="nc" id="L908">					this.mDrawableHeight = drawable.getIntrinsicHeight();</span>
<span class="nc" id="L909">					requestLayout();</span>
				}
			} else {
<span class="nc" id="L912">				mDrawableWidth = mDrawableHeight = 0;</span>
<span class="nc" id="L913">				requestLayout();</span>
			}
<span class="nc bnc" id="L915" title="All 2 branches missed.">			if ((mDrawable = drawable) != null) {</span>
<span class="nc" id="L916">				onSetUpDrawable(mDrawable);</span>
			}
		}
<span class="nc" id="L919">	}</span>

	/**
	 * Called right after the new progress drawable has been attached/set to this progress bar to
	 * set up its initial parameters.
	 *
	 * @param drawable The attached progress drawable to set up.
	 */
	void onSetUpDrawable(@NonNull D drawable) {
<span class="nc" id="L928">		drawable.setMax(mMax);</span>
<span class="nc" id="L929">		drawable.setMode(mMode);</span>
<span class="nc" id="L930">		drawable.setProgress(mProgress);</span>
<span class="nc" id="L931">		drawable.setAnimationCallback(this);</span>
<span class="nc" id="L932">		drawable.setExplodeAnimationCallback(this);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">		if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
<span class="nc" id="L934">			drawable.setLayoutDirection(getLayoutDirection());</span>
		}
<span class="nc" id="L936">		this.applyProgressTint();</span>
<span class="nc" id="L937">		this.applyIndeterminateTint();</span>
<span class="nc" id="L938">	}</span>

	/**
	 * Returns the drawable used to draw a progress or an indeterminate graphics of this progress bar
	 * depends on its current mode.
	 *
	 * @return An instance of {@link ProgressDrawable} or {@code null} if the drawable has been
	 * removed by passing {@code null} to {@link #setDrawable(ProgressDrawable)}.
	 * @see #setDrawable(ProgressDrawable)
	 * @see #setProgressMode(int)
	 */
	@Nullable
	public D getDrawable() {
<span class="nc" id="L951">		return mDrawable;</span>
	}

	/**
	 * Delegate method for {@link ProgressDrawable#setMode(int)}.
	 *
	 * @param mode The desired progress mode.
	 * @see #getProgressMode()
	 */
	public void setProgressMode(int mode) {
<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (mMode != mode) changeMode(mode);</span>
<span class="nc" id="L962">	}</span>

	/**
	 * Returns the current progress mode of this progress bar.
	 *
	 * @return Current progress mode.
	 * @see #setProgressMode(int)
	 */
	public int getProgressMode() {
<span class="nc bnc" id="L971" title="All 2 branches missed.">		if (mDrawable != null) this.mMode = mDrawable.getMode();</span>
<span class="nc" id="L972">		return mMode;</span>
	}

	/**
	 * Restart the current mode. This will stop all running progress animations (if any) and starts
	 * them again.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that none &lt;b&gt;INDETERMINATE&lt;/b&gt; mode, this will also clear the current progress
	 * and will set it to {@code 0}.
	 */
	public void restartMode() {
<span class="nc bnc" id="L983" title="All 2 branches missed.">		if ((mPrivateFlags &amp; PrivateFlags.PFLAG_ATTACHED_TO_WINDOW) != 0) {</span>
<span class="nc" id="L984">			onRestartMode(mMode);</span>
		}
<span class="nc" id="L986">	}</span>

	/**
	 * Sets the current value of progress displayed by this progress bar. Does nothing if the current
	 * mode is &lt;b&gt;INDETERMINATE&lt;/b&gt;.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that it is allowed to call this method also from the background thread.
	 *
	 * @param progress The desired progress value. Should be from the range {@code [0, getMax()]}.
	 * @see android.R.attr#progress android:progress
	 * @see #getProgress()
	 * @see #getMax()
	 * @see #setProgressMode(int)
	 */
	@AnyThread
	public synchronized void setProgress(int progress) {
<span class="nc bnc" id="L1002" title="All 8 branches missed.">		if (mMode != INDETERMINATE &amp;&amp; mProgress != progress &amp;&amp; progress &gt;= 0 &amp;&amp; progress &lt;= mMax) {</span>
<span class="nc" id="L1003">			this.refreshProgress(android.R.id.progress, mProgress = progress);</span>
		}
<span class="nc" id="L1005">	}</span>

	/**
	 * Returns the current value of progress displayed by this progress bar.
	 *
	 * @return Current progress value from the range {@code [0, getMax()]} or {@code 0} if the
	 * current mode is &lt;b&gt;INDETERMINATE&lt;/b&gt;.
	 * @see #setProgress(int)
	 */
	public synchronized int getProgress() {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">		if (mDrawable != null) this.mProgress = mDrawable.getProgress();</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">		return mMode != INDETERMINATE ? mProgress : 0;</span>
	}

	/**
	 * Delegate method for {@link ProgressDrawable#setMax(int)}.
	 */
	public synchronized void setMax(int max) {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">		if (mMax != max) {</span>
<span class="nc" id="L1024">			this.mMax = max;</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">			if (mDrawable != null) {</span>
<span class="nc" id="L1026">				mDrawable.setMax(max);</span>
			}
<span class="nc" id="L1028">			this.refreshProgress(android.R.id.progress, mProgress);</span>
		}
<span class="nc" id="L1030">	}</span>

	/**
	 * Delegate method for {@link ProgressDrawable#getMax()}.
	 */
	public int getMax() {
<span class="nc" id="L1036">		return mMax;</span>
	}

	/**
	 */
	@Override
	public void setVisibility(int visibility) {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">		final boolean changed = visibility != getVisibility();</span>
<span class="nc" id="L1044">		super.setVisibility(visibility);</span>
<span class="nc bnc" id="L1045" title="All 4 branches missed.">		if (changed) handleVisibilityChange(visibility == VISIBLE);</span>
<span class="nc" id="L1046">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
	public void setLayoutDirection(int layoutDirection) {
<span class="nc" id="L1053">		super.setLayoutDirection(layoutDirection);</span>
<span class="nc bnc" id="L1054" title="All 4 branches missed.">		if (mDrawable != null &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
<span class="nc" id="L1055">			mDrawable.setLayoutDirection(getLayoutDirection());</span>
		}
<span class="nc" id="L1057">	}</span>

	/**
	 */
	@Override
	protected void onAttachedToWindow() {
<span class="nc" id="L1063">		super.onAttachedToWindow();</span>
<span class="nc" id="L1064">		this.updatePrivateFlags(PrivateFlags.PFLAG_ATTACHED_TO_WINDOW, true);</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">		if (getVisibility() == VISIBLE) {</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">			switch (mMode) {</span>
				case INDETERMINATE:
<span class="nc" id="L1068">					startIndeterminate();</span>
					break;
			}
		}
<span class="nc" id="L1072">	}</span>

	/**
	 */
	@Override
	protected void onDetachedFromWindow() {
<span class="nc" id="L1078">		stopIndeterminate();</span>
<span class="nc" id="L1079">		this.updatePrivateFlags(PrivateFlags.PFLAG_ATTACHED_TO_WINDOW, false);</span>
<span class="nc" id="L1080">		super.onDetachedFromWindow();</span>
<span class="nc" id="L1081">	}</span>

	/**
	 */
	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
<span class="nc" id="L1087">		super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span>
<span class="nc" id="L1088">		final int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span>
<span class="nc" id="L1089">		final int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span>
<span class="nc" id="L1090">		final int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span>
<span class="nc" id="L1091">		final int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span>
<span class="nc" id="L1092">		int width = mDrawable.getIntrinsicWidth();</span>
<span class="nc" id="L1093">		int height = mDrawable.getIntrinsicHeight();</span>

		// Take into count also padding.
<span class="nc" id="L1096">		width += getPaddingLeft() + getPaddingRight();</span>
<span class="nc" id="L1097">		height += getPaddingTop() + getPaddingBottom();</span>

<span class="nc bnc" id="L1099" title="All 3 branches missed.">		switch (widthMode) {</span>
			case MeasureSpec.AT_MOST:
<span class="nc" id="L1101">				width = Math.min(width, widthSize);</span>
<span class="nc" id="L1102">				break;</span>
			case MeasureSpec.EXACTLY:
<span class="nc" id="L1104">				width = widthSize;</span>
<span class="nc" id="L1105">				break;</span>
			case MeasureSpec.UNSPECIFIED:
			default:
				break;
		}

<span class="nc bnc" id="L1111" title="All 3 branches missed.">		switch (heightMode) {</span>
			case MeasureSpec.AT_MOST:
<span class="nc" id="L1113">				height = Math.min(height, heightSize);</span>
<span class="nc" id="L1114">				break;</span>
			case MeasureSpec.EXACTLY:
<span class="nc" id="L1116">				height = heightSize;</span>
<span class="nc" id="L1117">				break;</span>
			case MeasureSpec.UNSPECIFIED:
			default:
				break;
		}

		// Check also against minimum size.
<span class="nc" id="L1124">		setMeasuredDimension(</span>
<span class="nc" id="L1125">				Math.max(width, getSuggestedMinimumWidth()),</span>
<span class="nc" id="L1126">				Math.max(height, getSuggestedMinimumHeight())</span>
		);
<span class="nc" id="L1128">	}</span>

	/**
	 */
	@Override
	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
<span class="nc" id="L1134">		super.onLayout(changed, left, top, right, bottom);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">		if (mDrawable != null) {</span>
<span class="nc" id="L1136">			mDrawable.setBounds(0, 0, getMeasuredWidth(), getMeasuredHeight());</span>
		}
<span class="nc" id="L1138">	}</span>

	/**
	 */
	@Override
	protected boolean verifyDrawable(Drawable who) {
<span class="nc bnc" id="L1144" title="All 4 branches missed.">		return who == mDrawable || super.verifyDrawable(who);</span>
	}

	/**
	 */
	@Override
	protected void drawableStateChanged() {
<span class="nc" id="L1151">		super.drawableStateChanged();</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">		if (mDrawable != null) mDrawable.setState(getDrawableState());</span>
<span class="nc" id="L1153">	}</span>

	/**
	 */
	@Override
	protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
<span class="nc" id="L1159">		super.onVisibilityChanged(changedView, visibility);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">		if (mDrawable != null)</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">			handleVisibilityChange(visibility == VISIBLE &amp;&amp; getVisibility() == VISIBLE);</span>
<span class="nc" id="L1162">	}</span>

	/**
	 * Handles change in visibility of this view. This will stop all animations if the specified
	 * &lt;var&gt;visible&lt;/var&gt; flag is {@code false}, otherwise it will start indeterminate animations
	 * if the current mode is not &lt;b&gt;DETERMINATE&lt;/b&gt;.
	 *
	 * @param visible {@code True} if this progress bar is visible, {@code false} otherwise..
	 */
	void handleVisibilityChange(boolean visible) {
<span class="nc bnc" id="L1172" title="All 2 branches missed.">		if (mDrawable != null) {</span>
<span class="nc" id="L1173">			mDrawable.setVisible(visible, false);</span>
		}
<span class="nc bnc" id="L1175" title="All 2 branches missed.">		switch (mMode) {</span>
			case INDETERMINATE:
<span class="nc bnc" id="L1177" title="All 2 branches missed.">				if (visible) {</span>
<span class="nc" id="L1178">					startIndeterminate();</span>
				} else {
<span class="nc" id="L1180">					stopIndeterminateImmediate();</span>
				}
<span class="nc" id="L1182">				postInvalidate();</span>
				break;
		}
<span class="nc" id="L1185">	}</span>

	/**
	 */
	@Override
	protected void onDraw(Canvas canvas) {
<span class="nc" id="L1191">		super.onDraw(canvas);</span>
<span class="nc bnc" id="L1192" title="All 4 branches missed.">		if (mDrawable != null &amp;&amp; mDrawable.isVisible()) {</span>
<span class="nc" id="L1193">			mDrawable.draw(canvas);</span>
		}
<span class="nc" id="L1195">	}</span>

	/**
	 * Changes the current mode of this progress bar. This will invoke {@link #onPreModeChange(int)}
	 * to allow perform some actions before the mode will be changed and than {@link #onModeChange(int)}
	 * will be invoked.
	 *
	 * @param mode The desired mode to be changed.
	 */
	void changeMode(int mode) {
<span class="nc" id="L1205">		onPreModeChange(mode);</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">		if (mDrawable != null) {</span>
<span class="nc" id="L1207">			mDrawable.setMode(mode);</span>
		}
<span class="nc" id="L1209">		onModeChange(mMode = mode);</span>
<span class="nc" id="L1210">	}</span>

	/**
	 * Invoked from {@link #changeMode(int)} before the requested mode is changed.
	 *
	 * @param mode The new mode which will be changed.
	 */
	void onPreModeChange(int mode) {
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		switch (mode) {</span>
			case DETERMINATE:
<span class="nc" id="L1220">				stopIndeterminate();</span>
				break;
		}
<span class="nc" id="L1223">	}</span>

	/**
	 * Invoked from {@link #changeMode(int)} after the requested mode has been changed.
	 *
	 * @param mode The changed mode.
	 */
	void onModeChange(int mode) {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">		switch (mode) {</span>
			case INDETERMINATE:
<span class="nc" id="L1233">				startIndeterminate();</span>
				break;
		}
<span class="nc" id="L1236">	}</span>

	/**
	 * Invoked to restart the current mode.
	 *
	 * @param mode The current mode that should be restarted.
	 */
	void onRestartMode(int mode) {
<span class="nc bnc" id="L1244" title="All 4 branches missed.">		if (mDrawable != null &amp;&amp; mDrawable.isRunning()) {</span>
<span class="nc" id="L1245">			mDrawable.stopImmediate();</span>
		}
<span class="nc bnc" id="L1247" title="All 3 branches missed.">		switch (mode) {</span>
			case DETERMINATE:
<span class="nc" id="L1249">				setProgress(0);</span>
<span class="nc" id="L1250">				break;</span>
			case INDETERMINATE:
<span class="nc" id="L1252">				startIndeterminate();</span>
				break;
		}
<span class="nc" id="L1255">	}</span>

	/**
	 * Refreshes the current progress value displayed by this progress bar with respect to UI thread,
	 * so this can be also called from the background thread.
	 * &lt;p&gt;
	 * If called from the UI thread, {@link #onRefreshProgress(int, int, boolean)} will be called
	 * immediately, otherwise to refresh progress will be posted runnable.
	 *
	 * @param id       One of {@link android.R.id#progress} or {@link android.R.id#secondaryProgress}.
	 * @param progress The progress value to be refreshed.
	 */
	@AnyThread
	@SuppressWarnings(&quot;WrongThread&quot;)
	final synchronized void refreshProgress(int id, int progress) {
<span class="nc bnc" id="L1270" title="All 2 branches missed.">		if (mUiThreadId == Thread.currentThread().getId()) {</span>
<span class="nc" id="L1271">			onRefreshProgress(id, progress, true);</span>
<span class="nc" id="L1272">			return;</span>
		}
<span class="nc bnc" id="L1274" title="All 2 branches missed.">		if (mRefreshProgressRunnable == null) {</span>
<span class="nc" id="L1275">			this.mRefreshProgressRunnable = new RefreshProgressRunnable();</span>
		}
<span class="nc" id="L1277">		final RefreshData refreshData = RefreshData.obtain(id, progress);</span>
<span class="nc" id="L1278">		mRefreshProgressRunnable.refreshData.add(refreshData);</span>
<span class="nc bnc" id="L1279" title="All 4 branches missed.">		if ((mPrivateFlags &amp; PrivateFlags.PFLAG_ATTACHED_TO_WINDOW) != 0 &amp;&amp; (mPrivateFlags &amp; PFLAG_REFRESH_PROGRESS_POSTED) == 0) {</span>
<span class="nc" id="L1280">			post(mRefreshProgressRunnable);</span>
<span class="nc" id="L1281">			this.updatePrivateFlags(PFLAG_REFRESH_PROGRESS_POSTED, true);</span>
		}
<span class="nc" id="L1283">	}</span>

	/**
	 * Invoked directly from {@link #refreshProgress(int, int)} if such a method has been called
	 * from the UI thread, otherwise this is invoked from the posted refresh runnable.
	 *
	 * @param id       One of {@link android.R.id#progress} or {@link android.R.id#secondaryProgress}.
	 * @param progress The progress value to be refreshed.
	 * @param notify   {@code True} if this call should be dispatched also as accessibility event,
	 *                 {@code false} otherwise.
	 */
	synchronized void onRefreshProgress(int id, int progress, boolean notify) {
<span class="nc bnc" id="L1295" title="All 2 branches missed.">		if (id == android.R.id.progress) {</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">			if (mDrawable != null) {</span>
<span class="nc" id="L1297">				mDrawable.setProgress(progress);</span>
			} else {
<span class="nc" id="L1299">				invalidate();</span>
			}
<span class="nc bnc" id="L1301" title="All 2 branches missed.">			if (notify) {</span>
<span class="nc" id="L1302">				scheduleAccessibilityEventSender();</span>
			}
		}
<span class="nc" id="L1305">	}</span>

	/**
	 * Schedules an accessibility event for the changed/selected progress value.
	 */
	private void scheduleAccessibilityEventSender() {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">		if (mAccessibilityEventSender == null) {</span>
<span class="nc" id="L1312">			mAccessibilityEventSender = new AccessibilityEventSender();</span>
		} else {
<span class="nc" id="L1314">			removeCallbacks(mAccessibilityEventSender);</span>
		}
<span class="nc" id="L1316">		postDelayed(mAccessibilityEventSender, ACCESSIBILITY_EVENT_DELAY);</span>
<span class="nc" id="L1317">	}</span>

	/**
	 */
	@NonNull
	@Override
	protected Parcelable onSaveInstanceState() {
<span class="nc" id="L1324">		final SavedState savedState = new SavedState(super.onSaveInstanceState());</span>
<span class="nc" id="L1325">		savedState.mode = mMode;</span>
<span class="nc" id="L1326">		savedState.progress = mProgress;</span>
<span class="nc" id="L1327">		return savedState;</span>
	}

	/**
	 */
	@Override
	protected void onRestoreInstanceState(Parcelable state) {
<span class="nc bnc" id="L1334" title="All 2 branches missed.">		if (!(state instanceof SavedState)) {</span>
<span class="nc" id="L1335">			super.onRestoreInstanceState(state);</span>
<span class="nc" id="L1336">			return;</span>
		}
<span class="nc" id="L1338">		final SavedState savedState = (SavedState) state;</span>
<span class="nc" id="L1339">		super.onRestoreInstanceState(savedState.getSuperState());</span>
<span class="nc" id="L1340">		changeMode(savedState.mode);</span>
<span class="nc" id="L1341">		setProgress(savedState.progress);</span>
<span class="nc" id="L1342">	}</span>

	/**
	 * Updates the current private flags.
	 *
	 * @param flag Value of the desired flag to add/remove to/from the current private flags.
	 * @param add  Boolean flag indicating whether to add or remove the specified &lt;var&gt;flag&lt;/var&gt;.
	 */
	@SuppressWarnings(&quot;unused&quot;)
	private void updatePrivateFlags(int flag, boolean add) {
<span class="nc bnc" id="L1352" title="All 2 branches missed.">		if (add) this.mPrivateFlags |= flag;</span>
<span class="nc" id="L1353">		else this.mPrivateFlags &amp;= ~flag;</span>
<span class="nc" id="L1354">	}</span>

	/**
	 * Returns a boolean flag indicating whether the specified &lt;var&gt;flag&lt;/var&gt; is contained within
	 * the current private flags or not.
	 *
	 * @param flag Value of the flag to check.
	 * @return {@code True} if the requested flag is contained, {@code false} otherwise.
	 */
	@SuppressWarnings(&quot;unused&quot;)
	private boolean hasPrivateFlag(int flag) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">		return (mPrivateFlags &amp; flag) != 0;</span>
	}

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * A {@link WidgetSavedState} implementation used to ensure that the state of {@link BaseProgressBar}
	 * is properly saved.
	 *
	 * @author Martin Albedinsky
	 */
	public static class SavedState extends WidgetSavedState {

		/**
		 * Creator used to create an instance or array of instances of SavedState from {@link android.os.Parcel}.
		 */
<span class="nc" id="L1383">		public static final Creator&lt;SavedState&gt; CREATOR = new Creator&lt;SavedState&gt;() {</span>
			/**
			 */
			@Override
			public SavedState createFromParcel(@NonNull Parcel source) {
<span class="nc" id="L1388">				return new SavedState(source);</span>
			}

			/**
			 */
			@Override
			public SavedState[] newArray(int size) {
<span class="nc" id="L1395">				return new SavedState[size];</span>
			}
		};

		/**
		 */
		int mode, progress;

		/**
		 * Creates a new instance of SavedState with the given &lt;var&gt;superState&lt;/var&gt; to allow chaining
		 * of saved states in {@link #onSaveInstanceState()} and also in {@link #onRestoreInstanceState(android.os.Parcelable)}.
		 *
		 * @param superState The super state obtained from {@code super.onSaveInstanceState()} within
		 *                   {@code onSaveInstanceState()}.
		 */
		protected SavedState(@NonNull Parcelable superState) {
<span class="nc" id="L1411">			super(superState);</span>
<span class="nc" id="L1412">		}</span>

		/**
		 * Called from {@link #CREATOR} to create an instance of SavedState form the given parcel
		 * &lt;var&gt;source&lt;/var&gt;.
		 *
		 * @param source Parcel with data for the new instance.
		 */
		protected SavedState(@NonNull Parcel source) {
<span class="nc" id="L1421">			super(source);</span>
<span class="nc" id="L1422">			this.mode = source.readInt();</span>
<span class="nc" id="L1423">			this.progress = source.readInt();</span>
<span class="nc" id="L1424">		}</span>

		/**
		 */
		@Override
		public void writeToParcel(@NonNull Parcel dest, int flags) {
<span class="nc" id="L1430">			super.writeToParcel(dest, flags);</span>
<span class="nc" id="L1431">			dest.writeInt(mode);</span>
<span class="nc" id="L1432">			dest.writeInt(progress);</span>
<span class="nc" id="L1433">		}</span>
	}

	/**
	 * This class holds all data necessary to tint all components of this view.
	 */
<span class="nc" id="L1439">	private static final class TintInfo extends Widget.BackgroundTintInfo {</span>

		/**
		 * Color state list used to tint a specific states of the &lt;b&gt;progress&lt;/b&gt; graphics of the
		 * progress drawable.
		 */
		ColorStateList progressTintList;

		/**
		 * Flag indicating whether the {@link #progressTintList} has been set or not.
		 */
		boolean hasProgressTintList;

		/**
		 * Blending mode used to apply tint to the &lt;b&gt;progress&lt;/b&gt; graphics of the progress drawable.
		 */
		PorterDuff.Mode progressTintMode;

		/**
		 * Flag indicating whether the {@link #progressTintMode} has been set or not.
		 */
		boolean hasProgressTintMode;

		/**
		 * Color state list used to tint a specific states of the &lt;b&gt;indeterminate&lt;/b&gt; graphics of the
		 * progress drawable.
		 */
		ColorStateList indeterminateTintList;

		/**
		 * Flag indicating whether the {@link #indeterminateTintList} has been set or not.
		 */
		boolean hasIndeterminateTintList;

		/**
		 * Blending mode used to apply tint to the &lt;b&gt;indeterminate&lt;/b&gt; graphics of the progress drawable.
		 */
		PorterDuff.Mode indeterminateTintMode;

		/**
		 * Flag indicating whether the {@link #indeterminateTintMode} has been set or not.
		 */
		boolean hasIndeterminateTintMode;
	}

	/**
	 * Class holding all data necessary to properly refresh progress value from the background thread.
	 */
<span class="nc" id="L1487">	private static final class RefreshData {</span>

		/**
		 * Pool of RefreshData objects for better performance.
		 */
<span class="nc" id="L1492">		static final Pools.SynchronizedPool&lt;RefreshData&gt; POOL = new Pools.SynchronizedPool&lt;&gt;(25);</span>

		/**
		 * Id of progress to refresh.
		 */
		int id;

		/**
		 * Progress value to be refreshed.
		 */
		int progress;

		/**
		 * Obtains an instance of RefreshData from the pool or creates a new instance if the pool
		 * is currently empty.
		 *
		 * @param id       The id of progress for which to create the new data. One of {@link android.R.id#progress}
		 *                 or {@link android.R.id#secondaryProgress}.
		 * @param progress Value of progress to refresh.
		 * @return Acquired or new instance of RefreshData object with the specified data.
		 */
		static RefreshData obtain(int id, int progress) {
<span class="nc" id="L1514">			RefreshData data = POOL.acquire();</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">			if (data == null) {</span>
<span class="nc" id="L1516">				data = new RefreshData();</span>
			}
<span class="nc" id="L1518">			data.id = id;</span>
<span class="nc" id="L1519">			data.progress = progress;</span>
<span class="nc" id="L1520">			return data;</span>
		}

		/**
		 * Recycles this refresh data object by releasing it from the current refresh data pool.
		 */
		void recycle() {
<span class="nc" id="L1527">			POOL.release(this);</span>
<span class="nc" id="L1528">		}</span>
	}

	/**
	 * Task used to refresh current progress value from the background thread.
	 */
<span class="nc" id="L1534">	private final class RefreshProgressRunnable implements Runnable {</span>

		/**
		 * List of refresh data to be processed to properly refresh progress.
		 */
<span class="nc" id="L1539">		final List&lt;RefreshData&gt; refreshData = new ArrayList&lt;&gt;();</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L1545">			synchronized (LOCK) {</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">				if (!refreshData.isEmpty()) {</span>
<span class="nc" id="L1547">					final int count = refreshData.size();</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">					for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1549">						final RefreshData data = refreshData.get(i);</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">						if (data != null) {</span>
<span class="nc" id="L1551">							onRefreshProgress(data.id, data.progress, true);</span>
<span class="nc" id="L1552">							data.recycle();</span>
						}
					}
<span class="nc" id="L1555">					refreshData.clear();</span>
				}
<span class="nc" id="L1557">				updatePrivateFlags(PFLAG_REFRESH_PROGRESS_POSTED, false);</span>
<span class="nc" id="L1558">			}</span>
<span class="nc" id="L1559">		}</span>
	}

	/**
	 * Task used to post an accessibility event for the changed progress.
	 */
<span class="nc" id="L1565">	private class AccessibilityEventSender implements Runnable {</span>

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L1571">			sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);</span>
<span class="nc" id="L1572">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>