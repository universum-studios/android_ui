<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ViewPagerWidget.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.widget</a> &gt; <span class="el_source">ViewPagerWidget.java</span></div><h1>ViewPagerWidget.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License
 * you may obtain at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can redistribute, modify or publish any part of the code written within this file but as it
 * is described in the License, the software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.widget;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.TypedArray;
import android.graphics.Color;
import android.graphics.PorterDuff;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.annotation.AttrRes;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.StyleRes;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.animation.Interpolator;
import android.widget.Scroller;

import java.lang.reflect.Field;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.graphics.drawable.TintDrawable;
import universum.studios.android.ui.interpolator.ScrollerInterpolator;

/**
 * Extended version of {@link android.support.v4.view.ViewPager}. This updated ViewPager supports
 * tinting for the Android versions below {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP}
 * and other useful features described below including &lt;b&gt;pulling&lt;/b&gt; feature.
 *
 * &lt;h3&gt;Tinting&lt;/h3&gt;
 * Tinting is supported via Xml attributes listed below:
 * &lt;ul&gt;
 * &lt;li&gt;{@link R.attr#uiBackgroundTint uiBackgroundTint}&lt;/li&gt;
 * &lt;li&gt;{@link R.attr#uiBackgroundTintMode uiBackgroundTintMode}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Note, that on {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP} and above SDK versions
 * can be also used Xml attributes listed above where in such case will be used the native tinting.&lt;/b&gt;
 * &lt;p&gt;
 * This widget group also overrides all SDK methods used to tint its components like {@link #setBackgroundTintList(android.content.res.ColorStateList)}
 * or {@link #setBackgroundTintMode(android.graphics.PorterDuff.Mode)}, so these can be used regardless
 * the current version of SDK but invoking of these methods below {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP}
 * can be done only directly upon instance of this widget group otherwise {@link NoSuchMethodException}
 * will be thrown.
 *
 * &lt;h3&gt;Sliding&lt;/h3&gt;
 * This updated view group allows updating of its current position along &lt;b&gt;x&lt;/b&gt; and &lt;b&gt;y&lt;/b&gt; axis
 * by changing &lt;b&gt;fraction&lt;/b&gt; of these properties depending on its current size using the new animation
 * framework introduced in {@link android.os.Build.VERSION_CODES#HONEYCOMB HONEYCOMB} via
 * {@link android.animation.ObjectAnimator ObjectAnimator}s API.
 * &lt;p&gt;
 * Changing of fraction of X or Y is supported via these two methods:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #setFractionX(float)}&lt;/li&gt;
 * &lt;li&gt;{@link #setFractionY(float)}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * For example if an instance of this view group class needs to be slided to the right by its whole
 * width, an Xml file with ObjectAnimator would look like this:
 * &lt;pre&gt;
 *  &amp;lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 *                  android:propertyName=&quot;fractionX&quot;
 *                  android:valueFrom=&quot;0.0&quot;
 *                  android:valueTo=&quot;1.0&quot;
 *                  android:duration=&quot;300&quot;/&amp;gt;
 * &lt;/pre&gt;
 * This can be especially useful for fragment transitions framework, where this view group would be
 * used as a root for a view hierarchy of a specific fragment.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * See {@link ViewPager},
 * {@link R.styleable#Ui_ViewPager ViewPagerWidget Attributes}
 *
 * &lt;h3&gt;Default style attribute&lt;/h3&gt;
 * {@link R.attr#uiViewPagerStyle uiViewPagerStyle}
 *
 * @author Martin Albedinsky
 */
public class ViewPagerWidget extends ViewPager implements WidgetGroup {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	private static final String TAG = &quot;ViewPagerWidget&quot;;

	/**
	 * Flag indicating whether the swiping of pages on touch is enabled or not.
	 */
	private static final int PFLAG_PAGE_SWIPING_ENABLED = 0x00000001 &lt;&lt; 16;

	/**
	 * Flag indicating whether the swiping of multiple pages on fling at once is enabled or not.
	 */
	private static final int PFLAG_PAGE_FLING_SWIPING_ENABLED = 0x00000001 &lt;&lt; 17;

	/**
	 * Flag indicating whether scroll duration for pages scrolling should be computed as relative
	 * depends on the count of pages to be scrolled or just fixed.
	 */
	private static final int PFLAG_PAGE_SCROLL_RELATIVE_DURATION_ENABLED = 0x00000001 &lt;&lt; 18;

	/**
	 * Name of the scroller field within the super ViewPager used to attach custom scroller to this
	 * ViewPager implementation.
	 */
	private static final String SCROLLER_FIELD_NAME = &quot;mScroller&quot;;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Interpolator used for scrolling operations of this view.
	 */
<span class="nc" id="L151">	private static final Interpolator SCROLLER_INTERPOLATOR = new ScrollerInterpolator();</span>

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Decorator used to extend API of this widget group by functionality otherwise not supported or
	 * not available due to current API level.
	 */
	private Decorator mDecorator;

	/**
	 * Index of the currently selected page.
	 */
	private int mCurrentPage;

	/**
	 * Duration for transition used to scroll between pages. If &lt;b&gt;negative&lt;/b&gt;, the default duration
	 * will be used.
	 */
<span class="nc" id="L172">	private int mPageScrollDuration = -1;</span>

	/**
	 * Helper used to track velocity of fling to determine whether to initiate swipe of page or not.
	 */
	private VelocityTracker mVelocityTracker;

	/**
	 * Minimum sensitivity to initiate swipe of page on fling.
	 */
<span class="nc" id="L182">	private float mPageFlingSwipingSensitivity = 6000;</span>

	/**
	 * Adapter with data set for this view pager.
	 */
	private PagerAdapter mAdapter;

	/**
	 * Custom scroller set to this view pager to provide custom scrolling logic.
	 */
	private Scroller mCustomScroller;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Same as {@link #ViewPagerWidget(android.content.Context, android.util.AttributeSet)} without
	 * attributes.
	 */
	public ViewPagerWidget(@NonNull Context context) {
<span class="nc" id="L203">		this(context, null);</span>
<span class="nc" id="L204">	}</span>

	/**
	 * Same as {@link #ViewPagerWidget(android.content.Context, android.util.AttributeSet, int)}
	 * with {@link R.attr#uiViewPagerStyle} as attribute for default style.
	 */
	public ViewPagerWidget(@NonNull Context context, @Nullable AttributeSet attrs) {
<span class="nc" id="L211">		this(context, attrs, R.attr.uiViewPagerStyle);</span>
<span class="nc" id="L212">	}</span>

	/**
	 * Same as {@link #ViewPagerWidget(android.content.Context, android.util.AttributeSet, int, int)}
	 * with {@code 0} as default style.
	 */
	public ViewPagerWidget(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) {
<span class="nc" id="L219">		this(context, attrs, defStyleAttr, 0);</span>
<span class="nc" id="L220">	}</span>

	/**
	 * Creates a new instance of ViewPagerWidget for the given &lt;var&gt;context&lt;/var&gt;.
	 *
	 * @param context      Context in which will be the new view presented.
	 * @param attrs        Set of Xml attributes used to configure the new instance of this view.
	 * @param defStyleAttr An attribute which contains a reference to a default style resource for
	 *                     this view within a theme of the given context.
	 * @param defStyleRes  Resource id of the default style for the new view.
	 */
	public ViewPagerWidget(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
<span class="nc" id="L232">		super(context, attrs);</span>
<span class="nc" id="L233">		this.init(context, attrs, defStyleAttr, defStyleRes);</span>
<span class="nc" id="L234">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Called from one of constructors of this view to perform its initialization.
	 * &lt;p&gt;
	 * Initialization is done via parsing of the specified &lt;var&gt;attrs&lt;/var&gt; set and obtaining for
	 * this view specific data from it that can be used to configure this new view instance. The
	 * specified &lt;var&gt;defStyleAttr&lt;/var&gt; and &lt;var&gt;defStyleRes&lt;/var&gt; are used to obtain default data
	 * from the current theme provided by the specified &lt;var&gt;context&lt;/var&gt;.
	 */
	private void init(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
<span class="nc" id="L249">		this.ensureDecorator();</span>
<span class="nc" id="L250">		mDecorator.processAttributes(context, attrs, defStyleAttr, defStyleRes);</span>

<span class="nc" id="L252">		final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.Ui_ViewPager, defStyleAttr, defStyleRes);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (typedArray != null) {</span>
<span class="nc" id="L254">			final int n = typedArray.getIndexCount();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">			for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L256">				final int index = typedArray.getIndex(i);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">				if (index == R.styleable.Ui_ViewPager_android_background) {</span>
<span class="nc" id="L258">					int resID = typedArray.getResourceId(index, -1);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">					if (resID != -1) {</span>
<span class="nc" id="L260">						setBackgroundResource(resID);</span>
					} else {
<span class="nc" id="L262">						setBackgroundColor(typedArray.getColor(0, Color.TRANSPARENT));</span>
					}
<span class="nc bnc" id="L264" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageMargin) {</span>
<span class="nc" id="L265">					setPageMargin(typedArray.getDimensionPixelSize(index, 0));</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageMarginDrawable) {</span>
<span class="nc" id="L267">					setPageMarginDrawable(typedArray.getDrawable(index));</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageSwipingEnabled) {</span>
<span class="nc" id="L269">					mDecorator.updatePrivateFlags(PFLAG_PAGE_SWIPING_ENABLED, typedArray.getBoolean(index, true));</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageFlingSwipingEnabled) {</span>
<span class="nc" id="L271">					mDecorator.updatePrivateFlags(PFLAG_PAGE_FLING_SWIPING_ENABLED, typedArray.getBoolean(index, false));</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageFlingSwipingSensitivity) {</span>
<span class="nc" id="L273">					this.mPageFlingSwipingSensitivity = Math.max(0, typedArray.getFloat(index, mPageFlingSwipingSensitivity));</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiCurrentPage) {</span>
<span class="nc" id="L275">					this.mCurrentPage = typedArray.getInteger(index, 0);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiOffScreenPageLimit) {</span>
<span class="nc" id="L277">					setOffscreenPageLimit(typedArray.getInt(index, getOffscreenPageLimit()));</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageScrollDuration) {</span>
<span class="nc" id="L279">					this.mPageScrollDuration = typedArray.getInteger(index, mPageScrollDuration);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">				} else if (index == R.styleable.Ui_ViewPager_uiPageScrollRelativeDurationEnabled) {</span>
<span class="nc" id="L281">					mDecorator.updatePrivateFlags(PFLAG_PAGE_SCROLL_RELATIVE_DURATION_ENABLED, typedArray.getBoolean(index, false));</span>
				}
			}
<span class="nc" id="L284">			typedArray.recycle();</span>
		}
		// Override default scroller so we can use custom durations for scroll if requested.
<span class="nc" id="L287">		setScroller(new WidgetScroller(context, SCROLLER_INTERPOLATOR));</span>
<span class="nc" id="L288">	}</span>

	/**
	 * Ensures that the decorator for this view is initialized.
	 */
	private void ensureDecorator() {
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (mDecorator == null) this.mDecorator = new Decorator(this);</span>
<span class="nc" id="L295">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityEvent(@NonNull AccessibilityEvent event) {
<span class="nc" id="L302">		super.onInitializeAccessibilityEvent(event);</span>
<span class="nc" id="L303">		event.setClassName(ViewPagerWidget.class.getName());</span>
<span class="nc" id="L304">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityNodeInfo(@NonNull AccessibilityNodeInfo info) {
<span class="nc" id="L311">		super.onInitializeAccessibilityNodeInfo(info);</span>
<span class="nc" id="L312">		info.setClassName(ViewPagerWidget.class.getName());</span>
<span class="nc" id="L313">	}</span>

	/**
	 */
	@Override
	@SuppressWarnings(&quot;deprecation&quot;)
	public void setBackgroundDrawable(Drawable background) {
<span class="nc" id="L320">		super.setBackgroundDrawable(background);</span>
<span class="nc" id="L321">		this.ensureDecorator();</span>
<span class="nc" id="L322">		mDecorator.applyBackgroundTint();</span>
<span class="nc" id="L323">	}</span>

	/**
	 * &lt;b&gt;Note, that on pre {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android versions
	 * this method will return an instance of {@link TintDrawable TintDrawable} if tint has been applied
	 * via {@link #setBackgroundTintList(ColorStateList)}.&lt;/b&gt;
	 * &lt;p&gt;
	 * The original wrapped drawable can be obtained via {@link TintDrawable#getDrawable()}.
	 */
	@Override
	public Drawable getBackground() {
<span class="nc" id="L334">		return super.getBackground();</span>
	}

	/**
	 */
	@Override
	public void setBackgroundTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L341">		this.ensureDecorator();</span>
<span class="nc" id="L342">		mDecorator.setBackgroundTintList(tint);</span>
<span class="nc" id="L343">	}</span>

	/**
	 */
	@Nullable
	@Override
	public ColorStateList getBackgroundTintList() {
<span class="nc" id="L350">		this.ensureDecorator();</span>
<span class="nc" id="L351">		return mDecorator.getBackgroundTintList();</span>
	}

	/**
	 */
	@Override
	public void setBackgroundTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L358">		this.ensureDecorator();</span>
<span class="nc" id="L359">		mDecorator.setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L360">	}</span>

	/**
	 */
	@Nullable
	@Override
	public PorterDuff.Mode getBackgroundTintMode() {
<span class="nc" id="L367">		this.ensureDecorator();</span>
<span class="nc" id="L368">		return mDecorator.getBackgroundTintMode();</span>
	}

	/**
	 */
	@Override
	public void setFractionX(float fraction) {
<span class="nc" id="L375">		this.ensureDecorator();</span>
<span class="nc" id="L376">		mDecorator.setFractionX(fraction);</span>
<span class="nc" id="L377">	}</span>

	/**
	 */
	@Override
	public float getFractionX() {
<span class="nc" id="L383">		this.ensureDecorator();</span>
<span class="nc" id="L384">		return mDecorator.getFractionX();</span>
	}

	/**
	 */
	@Override
	public void setFractionY(float fraction) {
<span class="nc" id="L391">		this.ensureDecorator();</span>
<span class="nc" id="L392">		mDecorator.setFractionY(fraction);</span>
<span class="nc" id="L393">	}</span>

	/**
	 */
	@Override
	public float getFractionY() {
<span class="nc" id="L399">		this.ensureDecorator();</span>
<span class="nc" id="L400">		return mDecorator.getFractionY();</span>
	}

	/**
	 */
	@Override
	public void setAdapter(PagerAdapter adapter) {
<span class="nc" id="L407">		super.setAdapter(mAdapter = adapter);</span>
<span class="nc" id="L408">	}</span>

	/**
	 */
	@Override
	public void setCurrentItem(int item) {
<span class="nc bnc" id="L414" title="All 2 branches missed.">		if (mPageScrollDuration &gt;= 0) {</span>
<span class="nc" id="L415">			setCurrentItem(item, calculatePageScrollDuration(item));</span>
<span class="nc" id="L416">			return;</span>
		}
<span class="nc" id="L418">		this.resetPageScrollDuration();</span>
<span class="nc" id="L419">		super.setCurrentItem(mCurrentPage = item);</span>
<span class="nc" id="L420">	}</span>

	/**
	 */
	@Override
	public void setCurrentItem(int item, boolean smoothScroll) {
<span class="nc bnc" id="L426" title="All 4 branches missed.">		if (mPageScrollDuration &gt;= 0 &amp;&amp; smoothScroll) {</span>
<span class="nc" id="L427">			setCurrentItem(item, calculatePageScrollDuration(item));</span>
<span class="nc" id="L428">			return;</span>
		}
<span class="nc" id="L430">		super.setCurrentItem(mCurrentPage = item, smoothScroll);</span>
<span class="nc" id="L431">	}</span>

	/**
	 * Same as {@link #setCurrentItem(int)}, but this will use the specified &lt;var&gt;duration&lt;/var&gt; for
	 * scroll. &lt;b&gt;Note&lt;/b&gt;, that this duration will be used only for this particular call, if you
	 * want to use a specific duration for all {@link #setCurrentItem(int)} related calls, set your
	 * desired duration by {@link #setPageScrollDuration(int)}.
	 *
	 * @param item     A position of page to scroll to.
	 * @param duration The desired scroll duration used to scroll to the specified page in milliseconds.
	 */
	public void setCurrentItem(int item, int duration) {
<span class="nc" id="L443">		this.usePageScrollDuration(duration);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">		super.setCurrentItem(mCurrentPage = item, duration &gt; 0);</span>
<span class="nc" id="L445">		this.resetPageScrollDuration();</span>
<span class="nc" id="L446">	}</span>

	/**
	 * Sets the scroller for this view pager used to apply and animate scroll to the pages of this
	 * pager.
	 *
	 * @param scroller The desired scroller to be used by this pager.
	 */
	public void setScroller(@NonNull Scroller scroller) {
<span class="nc" id="L455">		this.setSuperScroller(mCustomScroller = scroller);</span>
<span class="nc" id="L456">	}</span>

	/**
	 * Sets a custom scroller to the super of this view pager.
	 *
	 * @param scroller The scroller that should be set to the super ViewPager.
	 */
	private void setSuperScroller(Scroller scroller) {
<span class="nc" id="L464">		final Class parentClass = ViewPagerWidget.class.getSuperclass();</span>
		try {
<span class="nc" id="L466">			final Field scrollerField = parentClass.getDeclaredField(SCROLLER_FIELD_NAME);</span>
<span class="nc" id="L467">			scrollerField.setAccessible(true);</span>
<span class="nc" id="L468">			scrollerField.set(this, scroller);</span>
<span class="nc" id="L469">		} catch (Exception e) {</span>
<span class="nc" id="L470">			Log.e(TAG, &quot;Failed to attach custom scroller to the super ViewPager.&quot;, e);</span>
<span class="nc" id="L471">		}</span>
<span class="nc" id="L472">	}</span>

	/**
	 * Sets a flag indicating whether the swiping of pages on a user's touch/drag is enabled or not.
	 * This enables/disables only interaction for the user, calls to {@link #setCurrentItem(int)} and
	 * similar methods will still be working.
	 *
	 * @param enabled {@code True} if page swiping should be enabled, {@code false} otherwise.
	 * @see R.attr#uiPageSwipingEnabled ui:uiPageSwipingEnabled
	 * @see #isPageFlingSwipingEnabled()
	 */
	public void setPageSwipingEnabled(boolean enabled) {
<span class="nc" id="L484">		this.ensureDecorator();</span>
<span class="nc" id="L485">		mDecorator.updatePrivateFlags(PFLAG_PAGE_SWIPING_ENABLED, enabled);</span>
<span class="nc" id="L486">	}</span>

	/**
	 * Returns a flag indicating whether the swiping of pages is enabled for a user or not.
	 *
	 * @return {@code True} if page swiping is enabled, {@code false} otherwise.
	 * @see #setPageSwipingEnabled(boolean)
	 */
	public boolean isPageSwipingEnabled() {
<span class="nc" id="L495">		this.ensureDecorator();</span>
<span class="nc" id="L496">		return mDecorator.hasPrivateFlag(PFLAG_PAGE_SWIPING_ENABLED);</span>
	}

	/**
	 * Sets a flag indicating whether the swiping of multiple pages on a user's fling is enabled or
	 * not. Enabling this feature means, that the user can by fling scroll multiple pages at once.
	 * How many pages will be scrolled at fling depends on the velocity of a specific fling. Sensitivity
	 * for the fling can be set by {@link #setPageFlingSwipingSensitivity(float)}.
	 *
	 * @param enabled {@code True} if page swiping on fling should be enabled, {@code false} otherwise.
	 * @see R.attr#uiPageFlingSwipingEnabled ui:uiPageFlingSwipingEnabled
	 * @see #isPageFlingSwipingEnabled()
	 */
	public void setPageFlingSwipingEnabled(boolean enabled) {
<span class="nc" id="L510">		this.ensureDecorator();</span>
<span class="nc" id="L511">		mDecorator.updatePrivateFlags(PFLAG_PAGE_FLING_SWIPING_ENABLED, enabled);</span>
<span class="nc" id="L512">	}</span>

	/**
	 * Returns a flag indicating whether the swiping of multiple pages on fling is enabled or not.
	 *
	 * @return {@code True} if page swiping on fling is enabled, {@code false} otherwise.
	 * @see #setPageFlingSwipingEnabled(boolean)
	 */
	public boolean isPageFlingSwipingEnabled() {
<span class="nc" id="L521">		this.ensureDecorator();</span>
<span class="nc" id="L522">		return mDecorator.hasPrivateFlag(PFLAG_PAGE_FLING_SWIPING_ENABLED);</span>
	}

	/**
	 * Sets a sensitivity for the velocity of a user's fling used to determine whether to handle a
	 * particular fling to swipe multiple pages at once or not.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that velocity of fling is computed in {@link UiConfig#VELOCITY_UNITS}.
	 *
	 * @param sensitivity The desired sensitivity. The bigger sensitivity is, the less pages will
	 *                    be scrolled at once and in reverse.
	 * @see R.attr#uiPageFlingSwipingSensitivity ui:uiPageFlingSwipingSensitivity
	 * @see #getPageFlingSwipingSensitivity()
	 * @see #setPageFlingSwipingEnabled(boolean)
	 */
	public void setPageFlingSwipingSensitivity(float sensitivity) {
<span class="nc" id="L538">		this.mPageFlingSwipingSensitivity = Math.max(0, sensitivity);</span>
<span class="nc" id="L539">	}</span>

	/**
	 * Returns the current sensitivity for the fling velocity used to determine whether to handle
	 * a user's fling or not.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;6000&lt;/b&gt;
	 *
	 * @return Swiping sensitivity.
	 * @see #setPageFlingSwipingSensitivity(float)
	 */
	public float getPageFlingSwipingSensitivity() {
<span class="nc" id="L551">		return mPageFlingSwipingSensitivity;</span>
	}

	/**
	 * Sets the duration for scroll used whenever {@link #setCurrentItem(int)} or similar methods
	 * are called upon this view pager.
	 *
	 * @param duration The desired scroll duration in milliseconds. Pass here {@code -1} to clear
	 *                 the current one, so the default one will be used.
	 * @see #getPageScrollDuration()
	 */
	public void setPageScrollDuration(int duration) {
<span class="nc" id="L563">		this.mPageScrollDuration = duration;</span>
<span class="nc" id="L564">	}</span>

	/**
	 * Returns the current duration used for scrolling of pages of this pager.
	 *
	 * @return Scroll duration in milliseconds.
	 * @see #setPageScrollDuration(int)
	 */
	public int getPageScrollDuration() {
<span class="nc" id="L573">		return mPageScrollDuration;</span>
	}

	/**
	 * Sets a flag indicating whether the duration of page scroll should be computed as a relative
	 * one depends on the count of pages to be scrolled, or as a fixed one regardless how many pages
	 * will be scrolled.
	 * &lt;p&gt;
	 * If the relative duration is enabled, the scroll duration requested by {@link #setPageScrollDuration(int)}
	 * is used as a base, so a duration for the current page scroll is computed like so:
	 * &lt;b&gt;{@code Math.abs(getCurrentItem() - position) * pageScrollDuration}&lt;/b&gt;
	 *
	 * @param enabled {@code True} if relative duration of page scroll should be enabled, {@code false}
	 *                otherwise.
	 * @see #isPageScrollRelativeDurationEnabled()
	 */
	public void setPageScrollRelativeDurationEnabled(boolean enabled) {
<span class="nc" id="L590">		this.ensureDecorator();</span>
<span class="nc" id="L591">		mDecorator.updatePrivateFlags(PFLAG_PAGE_SCROLL_RELATIVE_DURATION_ENABLED, enabled);</span>
<span class="nc" id="L592">	}</span>

	/**
	 * Returns a flag indicating whether the duration of pages scroll is computed as a relative one
	 * or not.
	 *
	 * @return {@code True} if duration of page scroll is computed as relative one, {@code false} as
	 * fixed one.
	 * @see #setPageScrollRelativeDurationEnabled(boolean)
	 */
	public boolean isPageScrollRelativeDurationEnabled() {
<span class="nc" id="L603">		this.ensureDecorator();</span>
<span class="nc" id="L604">		return mDecorator.hasPrivateFlag(PFLAG_PAGE_SCROLL_RELATIVE_DURATION_ENABLED);</span>
	}

	/**
	 */
	@Override
	public void setHideSoftKeyboardOnTouchEnabled(boolean enabled) {
<span class="nc" id="L611">		this.ensureDecorator();</span>
<span class="nc" id="L612">		mDecorator.setHideSoftKeyboardOnTouchEnabled(enabled);</span>
<span class="nc" id="L613">	}</span>

	/**
	 */
	@Override
	public boolean isHideSoftKeyboardOnTouchEnabled() {
<span class="nc" id="L619">		this.ensureDecorator();</span>
<span class="nc" id="L620">		return mDecorator.isHideSoftKeyboardOnTouchEnabled();</span>
	}

	/**
	 */
	@Override
	protected void onAttachedToWindow() {
<span class="nc" id="L627">		super.onAttachedToWindow();</span>
<span class="nc" id="L628">		this.ensureDecorator();</span>
<span class="nc" id="L629">		mDecorator.onAttachedToWindow();</span>
<span class="nc" id="L630">		setCurrentItem(mCurrentPage);</span>
<span class="nc" id="L631">	}</span>

	/**
	 */
	@Override
	public boolean isAttachedToWindow() {
<span class="nc" id="L637">		this.ensureDecorator();</span>
<span class="nc bnc" id="L638" title="All 4 branches missed.">		return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; super.isAttachedToWindow()) ||</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">				mDecorator.hasPrivateFlag(PrivateFlags.PFLAG_ATTACHED_TO_WINDOW);</span>
	}

	/**
	 */
	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
<span class="nc" id="L646">		super.onSizeChanged(w, h, oldw, oldh);</span>
<span class="nc" id="L647">		this.ensureDecorator();</span>
<span class="nc" id="L648">		mDecorator.onSizeChanged(w, h, oldw, oldh);</span>
<span class="nc" id="L649">	}</span>

	/**
	 */
	@NonNull
	@Override
	public WidgetSizeAnimator animateSize() {
<span class="nc" id="L656">		this.ensureDecorator();</span>
<span class="nc" id="L657">		return mDecorator.animateSize();</span>
	}

	/**
	 */
	@Override
	public boolean onInterceptTouchEvent(MotionEvent event) {
<span class="nc" id="L664">		this.ensureDecorator();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">		if (!mDecorator.hasPrivateFlag(PFLAG_PAGE_SWIPING_ENABLED)) {</span>
<span class="nc" id="L666">			return false;</span>
		}
<span class="nc bnc" id="L668" title="All 2 branches missed.">		if (mDecorator.onInterceptTouchEvent(event)) {</span>
<span class="nc" id="L669">			this.requestParentDisallowInterceptTouchEvent(true);</span>
<span class="nc" id="L670">			return true;</span>
		}
<span class="nc" id="L672">		return super.onInterceptTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	public boolean onTouchEvent(@NonNull MotionEvent event) {
<span class="nc" id="L679">		this.ensureDecorator();</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (!mDecorator.hasPrivateFlag(PFLAG_PAGE_SWIPING_ENABLED)) {</span>
<span class="nc" id="L681">			mDecorator.hideSoftKeyboardOnTouch();</span>
<span class="nc" id="L682">			return false;</span>
		}
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (mDecorator.onTouchEvent(event)) {</span>
<span class="nc" id="L685">			this.requestParentDisallowInterceptTouchEvent(true);</span>
<span class="nc" id="L686">			return true;</span>
		}
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if (mDecorator.hasPrivateFlag(PFLAG_PAGE_FLING_SWIPING_ENABLED)) {</span>
<span class="nc" id="L689">			this.ensureVelocityTracker();</span>
<span class="nc" id="L690">			mVelocityTracker.addMovement(event);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">			switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span>
				case MotionEvent.ACTION_UP:
				case MotionEvent.ACTION_CANCEL:
<span class="nc" id="L694">					mVelocityTracker.computeCurrentVelocity(UiConfig.VELOCITY_UNITS);</span>
<span class="nc" id="L695">					final float xVelocity = mVelocityTracker.getXVelocity();</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">					if (Math.abs(xVelocity) &gt; mPageFlingSwipingSensitivity) {</span>
<span class="nc" id="L697">						super.onTouchEvent(event);</span>
<span class="nc" id="L698">						this.handleFling(xVelocity);</span>
<span class="nc" id="L699">						return true;</span>
					}
			}
		}
<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (super.onTouchEvent(event)) {</span>
<span class="nc" id="L704">			return true;</span>
		}
<span class="nc" id="L706">		mDecorator.hideSoftKeyboardOnTouch();</span>
<span class="nc" id="L707">		return false;</span>
	}

	/**
	 * Ensures that the {@link #mVelocityTracker} is initialized.
	 */
	private void ensureVelocityTracker() {
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (mVelocityTracker == null) this.mVelocityTracker = VelocityTracker.obtain();</span>
<span class="nc" id="L715">	}</span>

	/**
	 * Handles fling event performed by a user with the specified &lt;var&gt;velocity&lt;/var&gt;. This will
	 * compute how many pages should be scrolled and than will call {@link #setCurrentItem(int)}
	 * for the computed page position.
	 *
	 * @param velocity The velocity with which has been fling performed.
	 */
	private void handleFling(float velocity) {
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (mAdapter == null) {</span>
<span class="nc" id="L726">			return;</span>
		}
<span class="nc" id="L728">		int scrollPages = Math.round(Math.abs(velocity) / mPageFlingSwipingSensitivity);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">		if (velocity &gt; 0) {</span>
<span class="nc" id="L730">			setCurrentItem(Math.max(0, getCurrentItem() - scrollPages));</span>
		} else {
<span class="nc" id="L732">			setCurrentItem(Math.min(mAdapter.getCount() - 1, getCurrentItem() + scrollPages));</span>
		}
<span class="nc" id="L734">	}</span>

	/**
	 * Updates the scroll duration for the current scroller (if instance of {@link WidgetScroller}),
	 * so this duration will be used when {@link WidgetScroller#startScroll(int, int, int, int, int)}
	 * will be next time called upon this scroller.
	 *
	 * @param duration The desired scroll duration in milliseconds. Pass here {@code -1} to clear
	 *                 the current one, so the default one will be used.
	 */
	private void usePageScrollDuration(int duration) {
<span class="nc bnc" id="L745" title="All 2 branches missed.">		if (mCustomScroller instanceof WidgetScroller) {</span>
<span class="nc" id="L746">			((WidgetScroller) mCustomScroller).setScrollDuration(duration);</span>
		}
<span class="nc" id="L748">	}</span>

	/**
	 * Resets the current scroll duration for pages.
	 */
	private void resetPageScrollDuration() {
<span class="nc" id="L754">		usePageScrollDuration(-1);</span>
<span class="nc" id="L755">	}</span>

	/**
	 * Calculates scroll duration for page at the specified &lt;var&gt;position&lt;/var&gt;. The calculated
	 * duration will depends on if the relative duration is enabled or not via
	 * {@link #setPageScrollRelativeDurationEnabled(boolean)}.
	 *
	 * @param position The position of page for which to calculate scroll duration.
	 * @return Calculated scroll duration in milliseconds.
	 */
	private int calculatePageScrollDuration(int position) {
<span class="nc" id="L766">		this.ensureDecorator();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">		if (mDecorator.hasPrivateFlag(PFLAG_PAGE_SCROLL_RELATIVE_DURATION_ENABLED)) {</span>
<span class="nc" id="L768">			return Math.abs(getCurrentItem() - position) * mPageScrollDuration;</span>
		}
<span class="nc" id="L770">		return mPageScrollDuration;</span>
	}

	/**
	 * Requests the current parent to disallow intercepting of touch event by {@link ViewParent#requestDisallowInterceptTouchEvent(boolean)}.
	 *
	 * @param disallow {@code True} to disallow, {@code false} otherwise.
	 */
	private void requestParentDisallowInterceptTouchEvent(boolean disallow) {
<span class="nc" id="L779">		final ViewParent parent = getParent();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">		if (parent != null) {</span>
<span class="nc" id="L781">			parent.requestDisallowInterceptTouchEvent(disallow);</span>
		}
<span class="nc" id="L783">	}</span>

	/**
	 */
	@Override
	protected void onDetachedFromWindow() {
<span class="nc" id="L789">		super.onDetachedFromWindow();</span>
<span class="nc" id="L790">		this.ensureDecorator();</span>
<span class="nc" id="L791">		mDecorator.onDetachedFromWindow();</span>
<span class="nc" id="L792">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * Decorator implementation for this widget group.
	 */
	private final class Decorator extends WidgetGroupDecorator&lt;ViewPagerWidget&gt; {

		/**
		 * See {@link WidgetGroupDecorator#WidgetGroupDecorator(ViewGroup)}.
		 */
<span class="nc" id="L806">		Decorator(ViewPagerWidget widgetGroup) {</span>
<span class="nc" id="L807">			super(widgetGroup, R.styleable.Ui_ViewPager);</span>
<span class="nc" id="L808">			updatePrivateFlags(PFLAG_PAGE_SWIPING_ENABLED, true);</span>
<span class="nc" id="L809">		}</span>

		/**
		 */
		@Override
		@SuppressWarnings(&quot;ResourceType&quot;)
		void onProcessTintAttributes(Context context, TypedArray tintAttributes, int tintColor) {
<span class="nc bnc" id="L816" title="All 2 branches missed.">			if (UiConfig.MATERIALIZED) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">				if (tintAttributes.hasValue(R.styleable.Ui_ViewPager_uiBackgroundTint)) {</span>
<span class="nc" id="L818">					setBackgroundTintList(tintAttributes.getColorStateList(R.styleable.Ui_ViewPager_uiBackgroundTint));</span>
				}
<span class="nc bnc" id="L820" title="All 2 branches missed.">				if (tintAttributes.hasValue(R.styleable.Ui_ViewPager_uiBackgroundTintMode)) {</span>
<span class="nc" id="L821">					setBackgroundTintMode(TintManager.parseTintMode(</span>
<span class="nc" id="L822">							tintAttributes.getInt(R.styleable.Ui_ViewPager_uiBackgroundTintMode, 0),</span>
							PorterDuff.Mode.SRC_IN
					));
				}
			} else {
<span class="nc bnc" id="L827" title="All 2 branches missed.">				if (tintAttributes.hasValue(R.styleable.Ui_ViewPager_uiBackgroundTint)) {</span>
<span class="nc" id="L828">					mTintInfo.backgroundTintList = tintAttributes.getColorStateList(R.styleable.Ui_ViewPager_uiBackgroundTint);</span>
				}
<span class="nc" id="L830">				mTintInfo.backgroundTintMode = TintManager.parseTintMode(</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">						tintAttributes.getInt(R.styleable.Ui_ViewPager_uiBackgroundTintMode, 0),</span>
						mTintInfo.backgroundTintList != null ? PorterDuff.Mode.SRC_IN : null
				);
			}
<span class="nc" id="L835">		}</span>

		/**
		 */
		@Override
		@SuppressWarnings(&quot;deprecation&quot;)
		void superSetBackgroundDrawable(Drawable drawable) {
<span class="nc" id="L842">			ViewPagerWidget.super.setBackgroundDrawable(drawable);</span>
<span class="nc" id="L843">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		void superSetBackgroundTintList(ColorStateList tint) {
<span class="nc" id="L850">			ViewPagerWidget.super.setBackgroundTintList(tint);</span>
<span class="nc" id="L851">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		ColorStateList superGetBackgroundTintList() {
<span class="nc" id="L858">			return ViewPagerWidget.super.getBackgroundTintList();</span>
		}

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		void superSetBackgroundTintMode(PorterDuff.Mode tintMode) {
<span class="nc" id="L866">			ViewPagerWidget.super.setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L867">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		PorterDuff.Mode superGetBackgroundTintMode() {
<span class="nc" id="L874">			return ViewPagerWidget.super.getBackgroundTintMode();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>