<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.ui.widget</a> &gt; <span class="el_source">CalendarView.java</span></div><h1>CalendarView.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License
 * you may obtain at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can redistribute, modify or publish any part of the code written within this file but as it
 * is described in the License, the software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.ui.widget;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.PointF;
import android.graphics.PorterDuff;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.annotation.AttrRes;
import android.support.annotation.FloatRange;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.LinearSmoothScroller;
import android.support.v7.widget.RecyclerView;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;

import java.util.Calendar;
import java.util.Date;
import java.util.Locale;

import universum.studios.android.ui.R;
import universum.studios.android.ui.UiConfig;
import universum.studios.android.ui.graphics.drawable.TintDrawable;

/**
 * A {@link RecyclerView} implementation designed to present data set of months. Calendar view uses
 * by default {@link MonthView} widget as item view for its default adapter. The date (months) range
 * that should be presented by the calendar view can be specified through its adapter via
 * {@link CalendarAdapter#setMinMaxDate(long, long)}, where if you want to be presented &quot;infinite&quot;
 * amount of months, specify {@code 0} as &lt;var&gt;maxDateInMillis&lt;/var&gt; attribute. The calendar adapter
 * can be accessed via {@link #getCalendarAdapter()}. If needed custom implementation of {@link CalendarAdapter}
 * can be specified via {@link #setCalendarAdapter(Adapter)} in such case {@link CalendarDataSet}
 * helper class can be used to simplify months data set management.
 * &lt;p&gt;
 * Initial selected date can be specified via {@link #setSelectedDate(java.util.Date)} or
 * {@link #setSelectedDate(long)} and the current selected date can be obtained via {@link #getSelectedDate()}
 * or {@link #getSelectedDateInMillis()}.
 *
 * &lt;h3&gt;Callbacks&lt;/h3&gt;
 * Use {@link OnDateSelectionListener} to listen for callback about selected date. This listener can
 * be registered via {@link #setOnDateSelectionListener(OnDateSelectionListener)} and its callback
 * will be fired whenever a user selects its desired date (a specific number within the currently visible month view).
 * &lt;p&gt;
 * If you want to listen for changes in month or year that are caused by scrolling of the calendar
 * view, use {@link OnMonthChangeListener} and {@link OnYearChangeListener}. These listeners can be
 * registered via {@link #setOnMonthChangeListener(OnMonthChangeListener)} and
 * {@link #setOnYearChangeListener(OnYearChangeListener)}.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * {@link R.styleable#Ui_CalendarView CalendarView Attributes}
 *
 * &lt;h3&gt;Default style attribute&lt;/h3&gt;
 * {@link R.attr#uiCalendarViewStyle uiCalendarViewStyle}
 *
 * @author Martin Albedinsky
 */
public class CalendarView extends RecyclerView implements Widget {

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Listener that can receive callback about selected date within {@link CalendarView}.
	 *
	 * @author Martin Albedinsky
	 */
	public interface OnDateSelectionListener {

		/**
		 * Invoked whenever the specified &lt;var&gt;dateInMillis&lt;/var&gt; has been selected within the given
		 * &lt;var&gt;calendarView&lt;/var&gt;.
		 *
		 * @param calendarView The calendar view where the date has been selected.
		 * @param dateInMillis The selected date in milliseconds. Contains &lt;b&gt;{@link Calendar#YEAR},
		 *                     {@link Calendar#MONTH}&lt;/b&gt;, and &lt;b&gt;{@link Calendar#DAY_OF_MONTH}&lt;/b&gt; data.
		 */
		void onDateSelected(@NonNull CalendarView calendarView, long dateInMillis);

		/**
		 * Invoked whenever the current selected date in the given &lt;var&gt;calendarView&lt;/var&gt; has been
		 * cleared.
		 *
		 * @param calendarView The calendar view with no selected date.
		 */
		void onNoDateSelected(@NonNull CalendarView calendarView);
	}

	/**
	 * Extension of {@link MonthView.OnDaySelectionListener} used by {@link CalendarView} to listen
	 * for selected day for a specific month within the calendar view's adapter's data set.
	 *
	 * @author Martin Albedinsky
	 */
	public interface OnMonthDaySelectionListener {

		/**
		 * Invoked whenever the specified &lt;var&gt;day&lt;/var&gt; has been selected in the given &lt;var&gt;monthView&lt;/var&gt;
		 * at the adapter &lt;var&gt;position&lt;/var&gt;.
		 *
		 * @param monthView    The month view where the day has been selected.
		 * @param day          The selected day. Will be from the range {@code [1, 31]}.
		 * @param dateInMillis A date in milliseconds that is currently selected within the given month view.
		 * @param position     The adapter position of the month view within the current calendar data set.
		 * @see MonthView.OnDaySelectionListener#onDaySelected(MonthView, int, long)
		 */
		void onMonthDaySelected(@NonNull MonthView monthView, @IntRange(from = 1, to = 31) int day, long dateInMillis, int position);
	}

	/**
	 * Listener that can receive callback about changed month by scroll within {@link CalendarView}.
	 *
	 * @author Martin Albedinsky
	 */
	public interface OnMonthChangeListener {

		/**
		 * Invoked whenever the specified &lt;var&gt;month&lt;/var&gt; (its view) has been scrolled within the
		 * given &lt;var&gt;calendarView&lt;/var&gt;.
		 *
		 * @param calendarView The calendar view where the month has been scrolled.
		 * @param month        The month number of which view has been scrolled.
		 * @param offset       Offset of the scrolled month view from its 'idle' position. Value is
		 *                     from the range {@code [0.0, 1.0)} where {@code 0.0} indicates that
		 *                     the month view is completely scrolled to the left (it is not visible
		 *                     for a user) and {@code 1.0} indicates that the month view is completely
		 *                     scrolled at its 'idle' position (it is fully visible for a user).
		 */
		void onMonthScrolled(@NonNull CalendarView calendarView, @IntRange(from = Calendar.JANUARY, to = Calendar.DECEMBER) int month, @FloatRange(from = 0.0f, to = 1.0f) float offset);

		/**
		 * Invoked whenever the specified &lt;var&gt;month&lt;/var&gt; has been changed within the given
		 * &lt;var&gt;calendarView&lt;/var&gt; due to change in the scroll.
		 *
		 * @param calendarView The calendar view where the month has been changed.
		 * @param month        The changed month number from the range [{@link Calendar#JANUARY}, {@link Calendar#DECEMBER}].
		 */
		void onMonthChanged(@NonNull CalendarView calendarView, @IntRange(from = Calendar.JANUARY, to = Calendar.DECEMBER) int month);
	}

	/**
	 * Listener that can receive callback about changed year by scroll within {@link CalendarView}.
	 *
	 * @author Martin Albedinsky
	 */
	public interface OnYearChangeListener {

		/**
		 * Invoked whenever the specified &lt;var&gt;year&lt;/var&gt; has been changed within the given
		 * &lt;var&gt;calendarView&lt;/var&gt; due to change in the scroll.
		 *
		 * @param calendarView The calendar view where the year has been changed.
		 * @param year         The changed year number.
		 */
		void onYearChanged(@NonNull CalendarView calendarView, int year);
	}

	/**
	 * Interface for adapter that provides data set of months for {@link CalendarView}.
	 *
	 * @author Martin Albedinsky
	 */
	public interface CalendarAdapter {

		/**
		 * Registers a callback to be invoked whenever a specific day is selected within a {@link MonthView}
		 * at a specific position.
		 *
		 * @param listener Listener callback. May be {@code null} to clear the current one.
		 */
		void setOnMonthDaySelectionListener(@Nullable OnMonthDaySelectionListener listener);

		/**
		 * Changes the minimum + maximum date to determine min boundary for month and the count of
		 * months provided by this adapter.
		 *
		 * @param minDateInMillis Minimum date used to determine the bottom date boundary, so the first month
		 *                        provided by this adapter.
		 * @param maxDateInMillis Maximum date used to determine the count of months provided by this adapter,
		 *                        so the last month.
		 * @return {@code True} if boundaries has been updated, {@code false} otherwise.
		 */

		/**
		 * Sets a date boundaries for months data set of this adapter. These dates are used to resolve
		 * when the months data set should start and how large (in count of months) should be.
		 *
		 * @param minDateInMillis The desired minimum date in milliseconds.
		 * @param maxDateInMillis The desired maximum date in milliseconds.
		 * @see #getDateMinInMillis()
		 * @see #getDateMaxInMillis()
		 */
		void setMinMaxDate(long minDateInMillis, long maxDateInMillis);

		/**
		 * Returns the minimum date specified via {@link #setMinMaxDate(long, long)} used to resolve
		 * start of months data set.
		 *
		 * @return Minimum date in milliseconds.
		 */
		long getDateMinInMillis();

		/**
		 * Returns the maximum date specified via {@link #setMinMaxDate(long, long)} used to limit
		 * count of months available.
		 *
		 * @return Maximum date in milliseconds.
		 */
		long getDateMaxInMillis();

		/**
		 * Sets a date that should be selected in months data set of this adapter.
		 *
		 * @param dateInMillis The desired date in milliseconds that will be used to resolve in which
		 *                     month to select the desired day.
		 */
		void setSelectedDate(@Nullable Long dateInMillis);

		/**
		 * Calculates a position of a month for the given &lt;var&gt;year&lt;/var&gt; and &lt;var&gt;month&lt;/var&gt;.
		 *
		 * @param year  The desired year number.
		 * @param month The desired month number from the range [{@link Calendar#JANUARY}, {@link Calendar#DECEMBER}].
		 * @return Computed position of the requested month within the current data set.
		 */
		int calculateMonthPosition(int year, @IntRange(from = Calendar.JANUARY, to = Calendar.DECEMBER) int month);

		/**
		 * Calculates the position of a month with the specified &lt;var&gt;dateInMillis&lt;/var&gt;.
		 *
		 * @param dateInMillis The date in milliseconds of month of which position to calculate.
		 * @return The calculated month position.
		 */
		int calculateMonthPosition(long dateInMillis);

		/**
		 * Returns the date for a month from this adapter's data set at the specified &lt;var&gt;position&lt;/var&gt;.
		 *
		 * @param position Position of the month for which to return its associated date.
		 * @return Month's date in milliseconds.
		 */
		long getMonthDate(int position);

		/**
		 * Sets a locale used to display proper names for calendar fields (month name and names of days in week).
		 *
		 * @param locale The desired locale.
		 * @see #getLocale()
		 */
		void setLocale(@NonNull Locale locale);

		/**
		 * Returns the current locale used by this adapter to display proper calendar field names.
		 *
		 * @return Current locale or {@link Locale#getDefault()} as default.
		 * @see #setLocale(Locale)
		 */
		@NonNull
		Locale getLocale();

		/**
		 * Called to save the current state of this adapter.
		 *
		 * @return Saved state of this adapter or an &lt;b&gt;empty&lt;/b&gt; state if this adapter does not need to
		 * save its state.
		 */
		@NonNull
		Parcelable saveInstanceState();

		/**
		 * Called to restore a previous state, saved by {@link #saveInstanceState()}, of this adapter.
		 *
		 * @param savedState Should be the same state as obtained via {@link #saveInstanceState()} before.
		 */
		void restoreInstanceState(@NonNull Parcelable savedState);
	}

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	private static final String TAG = &quot;CalendarView&quot;;

	/**
	 * Flag indicating whether this view is pressed or not.
	 */
	private static final int PFLAG_PRESSED = 0x00000001 &lt;&lt; 16;

	/**
	 * Number of months within one year.
	 */
	private static final int MONTHS_IN_YEAR = 12;

	/**
	 * Constant used to indicate that an integer field has no value specified.
	 */
	private static final int NO_VALUE = -1;

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Runnable used to change the current position at which is this view scrolled.
	 */
<span class="nc" id="L346">	private final ScrollToPosition SCROLL_TO_POSITION = new ScrollToPosition();</span>

	/**
	 * Runnable used to change the current position at which is this view scrolled smoothly.
	 */
<span class="nc" id="L351">	private final SmoothScrollToPosition SMOOTH_SCROLL_TO_POSITION = new SmoothScrollToPosition();</span>

	/**
	 * Helper that implements listeners of which callbacks calendar view want to receive and process.
	 */
<span class="nc" id="L356">	private final CallbacksHandler CALLBACKS_HANDLER = new CallbacksHandler();</span>

	/**
	 * Orientation of this calendar view used as orientation for its {@link LinearLayoutManager}.
	 */
<span class="nc" id="L361">	private int mOrientation = HORIZONTAL;</span>

	/**
	 * Speed in milliseconds per inch used to calculate duration of smooth scroll.
	 */
	private float mScrollSpeedPerInch;

	/**
	 * Minimum velocity used when overriding fling velocity in {@link #fling(int, int)} method.
	 */
	private float mFlingMinVelocity;

	/**
	 * Minimum velocity used when overriding fling velocity in {@link #fling(int, int)} method.
	 */
<span class="nc" id="L376">	private float mFlingMaxVelocity = Float.MAX_VALUE;</span>

	/**
	 * Linear layout manager set to this calendar view (if any).
	 */
	LinearLayoutManager mLinearLayoutManager;

	/**
	 * Calendar instance used to compute date elements (year, month, ...).
	 */
	Calendar mCalendar;

	/**
	 * Year on that is this CalendarView currently scrolled.
	 */
<span class="nc" id="L391">	int mScrolledYear = NO_VALUE;</span>

	/**
	 * Month on that is this CalendarView currently scrolled.
	 */
<span class="nc" id="L396">	int mScrolledMonth = NO_VALUE;</span>

	/**
	 * Decorator used to extend API of this widget by functionality otherwise not supported or not
	 * available due to current API level.
	 */
	private Decorator mDecorator;

	/**
	 * Adapter which provides data set of months for this CalendarView.
	 */
	private CalendarAdapter mAdapter;

	/**
	 * Mock month view used to compute size of this view.
	 */
	private MonthView mMockMonthView;

	/**
	 * Callback to be invoked whenever a day has been selected.
	 */
	private OnDateSelectionListener mDateSelectionListener;

	/**
	 * Callback to be invoked whenever a month has been changed due to change in the scroll.
	 */
	private OnMonthChangeListener mMonthChangeListener;

	/**
	 * Callback to be invoked whenever a year has been changed due to change in the scroll.
	 */
	private OnYearChangeListener mYearChangeListener;

	/**
	 * Date on that is this CalendarView currently scrolled.
	 */
	private long mDateVisible;

	/**
	 * Date that is currently selected within this CalendarView.
	 */
	private Long mDateSelected;

	/**
	 * Position of month view where {@link #mDateSelected} has been selected either by a user or
	 * via {@link #setSelectedDate(long)}.
	 */
<span class="nc" id="L443">	private int mSelectedDateMonthPosition = NO_POSITION;</span>

	/**
	 * Animator used to animate size of this view.
	 */
	private WidgetSizeAnimator mSizeAnimator;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Same as {@link #CalendarView(android.content.Context, android.util.AttributeSet)} without
	 * attributes.
	 */
	public CalendarView(@NonNull Context context) {
<span class="nc" id="L459">		this(context, null);</span>
<span class="nc" id="L460">	}</span>

	/**
	 * Same as {@link #CalendarView(android.content.Context, android.util.AttributeSet, int)} with
	 * {@link R.attr#uiCalendarViewStyle uiCalendarViewStyle} as attribute for default style.
	 */
	public CalendarView(@NonNull Context context, @Nullable AttributeSet attrs) {
<span class="nc" id="L467">		this(context, attrs, R.attr.uiCalendarViewStyle);</span>
<span class="nc" id="L468">	}</span>

	/**
	 * Creates a new instance of CalendarView for the given &lt;var&gt;context&lt;/var&gt;.
	 *
	 * @param context      Context in which will be the new view presented.
	 * @param attrs        Set of Xml attributes used to configure the new instance of this view.
	 * @param defStyleAttr An attribute which contains a reference to a default style resource for
	 *                     this view within a theme of the given context.
	 */
	public CalendarView(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) {
<span class="nc" id="L479">		super(context, attrs, defStyleAttr);</span>
<span class="nc" id="L480">		this.ensureDecorator();</span>
<span class="nc" id="L481">		this.mDecorator.processAttributes(context, attrs, defStyleAttr, 0);</span>
<span class="nc" id="L482">		this.mCalendar = Calendar.getInstance();</span>
<span class="nc" id="L483">		super.addOnScrollListener(CALLBACKS_HANDLER);</span>

<span class="nc" id="L485">		final Resources resources = context.getResources();</span>
<span class="nc" id="L486">		final float density = resources.getDisplayMetrics().density;</span>
<span class="nc" id="L487">		final TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.Ui_CalendarView, defStyleAttr, 0);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">		for (int i = 0; i &lt; attributes.getIndexCount(); i++) {</span>
<span class="nc" id="L489">			final int index = attributes.getIndex(i);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">			if (index == R.styleable.Ui_CalendarView_android_orientation) {</span>
<span class="nc" id="L491">				this.mOrientation = attributes.getInt(index, mOrientation);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_CalendarView_uiScrollSpeedPerInch) {</span>
<span class="nc" id="L493">				this.mScrollSpeedPerInch = attributes.getFloat(index, mScrollSpeedPerInch);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_CalendarView_uiFlingMinVelocity) {</span>
<span class="nc" id="L495">				this.mFlingMinVelocity = attributes.getFloat(index, mFlingMinVelocity) * density;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_CalendarView_uiFlingMaxVelocity) {</span>
<span class="nc" id="L497">				this.mFlingMaxVelocity = attributes.getFloat(index, mFlingMaxVelocity) * density;</span>
			}
		}
<span class="nc" id="L500">		attributes.recycle();</span>
<span class="nc" id="L501">		setLayoutManager(new LayoutManagerImpl(context, mOrientation, mScrollSpeedPerInch));</span>
<span class="nc" id="L502">		setCalendarAdapter(new SimpleCalendarAdapter(context, new CalendarDataSet()));</span>
<span class="nc" id="L503">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Ensures that the decorator for this view is initialized.
	 */
	private void ensureDecorator() {
<span class="nc bnc" id="L513" title="All 2 branches missed.">		if (mDecorator == null) this.mDecorator = new Decorator(this);</span>
<span class="nc" id="L514">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityEvent(@NonNull AccessibilityEvent event) {
<span class="nc" id="L521">		super.onInitializeAccessibilityEvent(event);</span>
<span class="nc" id="L522">		event.setClassName(CalendarView.class.getName());</span>
<span class="nc" id="L523">	}</span>

	/**
	 */
	@Override
	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
	public void onInitializeAccessibilityNodeInfo(@NonNull AccessibilityNodeInfo info) {
<span class="nc" id="L530">		super.onInitializeAccessibilityNodeInfo(info);</span>
<span class="nc" id="L531">		info.setClassName(CalendarView.class.getName());</span>
<span class="nc" id="L532">	}</span>

	/**
	 * Sets an orientation in which should be month views layout within this calendar view. This
	 * is the same as calling {@link #setLayoutManager(LayoutManager)} with instance of {@link LinearLayoutManager}
	 * and the specified orientation.
	 *
	 * @param orientation The desired orientation. Should be one of {@link #HORIZONTAL} or {@link #VERTICAL}.
	 * @see android.R.attr#orientation android:orientation
	 * @see LinearLayoutManager#LinearLayoutManager(Context, int, boolean)
	 * @see #getOrientation()
	 */
	public void setOrientation(int orientation) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">		if (mOrientation != orientation) {</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">			switch (orientation) {</span>
				case HORIZONTAL:
				case VERTICAL:
<span class="nc" id="L549">					setLayoutManager(new LayoutManagerImpl(getContext(), orientation, mScrollSpeedPerInch));</span>
					break;
			}
		}
<span class="nc" id="L553">	}</span>

	/**
	 * Returns the current orientation of this calendar view.
	 *
	 * @return Current orientation as specified for the layout manager (if instance of {@link LinearLayoutManager})
	 * or {@code -1} if this calendar view does not have layout manger type of LinearLayoutManager
	 * specified.
	 * @see #setOrientation(int)
	 */
	public int getOrientation() {
<span class="nc" id="L564">		return mOrientation;</span>
	}

	/**
	 */
	@Override
	public void setLayoutManager(LayoutManager layout) {
<span class="nc" id="L571">		super.setLayoutManager(layout);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">		if (layout instanceof LinearLayoutManager) {</span>
<span class="nc" id="L573">			this.mLinearLayoutManager = (LinearLayoutManager) layout;</span>
<span class="nc" id="L574">			this.mOrientation = mLinearLayoutManager.getOrientation();</span>
		} else {
<span class="nc" id="L576">			this.mLinearLayoutManager = null;</span>
<span class="nc" id="L577">			this.mOrientation = NO_VALUE;</span>
		}
<span class="nc" id="L579">	}</span>

	/**
	 * Registers a callback to be invoked whenever a date is selected within this CalendarView.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnDateSelectionListener(@Nullable OnDateSelectionListener listener) {
<span class="nc" id="L587">		this.mDateSelectionListener = listener;</span>
<span class="nc" id="L588">	}</span>

	/**
	 * Registers a callback to be invoked whenever a month is changed due to change in scroll of
	 * this CalendarView.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnMonthChangeListener(@Nullable OnMonthChangeListener listener) {
<span class="nc" id="L597">		this.mMonthChangeListener = listener;</span>
<span class="nc" id="L598">	}</span>

	/**
	 * Registers a callback to be invoked whenever a year is changed due to change in scroll of
	 * this CalendarView.
	 *
	 * @param listener Listener callback. May be {@code null} to clear the current one.
	 */
	public void setOnYearChangeListener(@Nullable OnYearChangeListener listener) {
<span class="nc" id="L607">		this.mYearChangeListener = listener;</span>
<span class="nc" id="L608">	}</span>

	/**
	 * Returns the calendar instance used by this calendar view for date related calculations.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that changing locale via {@link #setLocale(Locale)} also changes calendar instance.
	 *
	 * @return Calendar instance of this calendar view.
	 */
	@NonNull
	public final Calendar getCalendar() {
<span class="nc" id="L619">		return mCalendar;</span>
	}

	/**
	 * Like {@link #getCalendar()} but here returned calendar will contain time data for the current
	 * selected date (if any).
	 *
	 * @return Calendar instance with selected date (if selected).
	 */
	@NonNull
	public final Calendar getCalendarWithSelectedDate() {
<span class="nc bnc" id="L630" title="All 2 branches missed.">		if (mDateSelected != null) {</span>
<span class="nc" id="L631">			mCalendar.setTimeInMillis(mDateSelected);</span>
		}
<span class="nc" id="L633">		return mCalendar;</span>
	}

	/**
	 * Sets a locale used to display proper names for calendar fields (month name and names of days in week).
	 *
	 * @param locale The desired locale.
	 * @see #getLocale()
	 */
	public void setLocale(@NonNull Locale locale) {
<span class="nc" id="L643">		this.mCalendar = Calendar.getInstance(locale);</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">		if (mAdapter != null) {</span>
<span class="nc" id="L645">			mAdapter.setLocale(locale);</span>
		}
<span class="nc" id="L647">	}</span>

	/**
	 * Returns the current locale used to obtain proper names of calendar fields.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that this also changes the current adapter's locale via {@link CalendarAdapter#setLocale(Locale)}.
	 *
	 * @return This CalendarView's locale or {@link java.util.Locale#getDefault()} by default.
	 * @see #setLocale(Locale)
	 */
	@NonNull
	public Locale getLocale() {
<span class="nc bnc" id="L659" title="All 2 branches missed.">		return mAdapter != null ? mAdapter.getLocale() : Locale.getDefault();</span>
	}

	/**
	 * Same as {@link #setSelectedDate(long)} for {@link Date} object.
	 *
	 * @param date The desired date to be selected. May be {@code null} to clear the current one.
	 * @see #getSelectedDate()
	 */
	public void setSelectedDate(@Nullable Date date) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">		if (date != null) {</span>
<span class="nc" id="L670">			setSelectedDate(date.getTime());</span>
		} else {
<span class="nc" id="L672">			this.handleSelectedDateUpdate(null, -1);</span>
		}
<span class="nc" id="L674">	}</span>

	/**
	 * Sets a date that should be selected in this calendar view (in one of its month views).
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that setting selected date also changes the current visible date (month) to the
	 * selected one. See {@link #setVisibleDate(long)} for more information.
	 *
	 * @param dateInMillis The desired date to be selected in milliseconds.
	 */
	public void setSelectedDate(long dateInMillis) {
<span class="nc bnc" id="L685" title="All 4 branches missed.">		if (mDateSelected == null || mDateSelected != dateInMillis) {</span>
<span class="nc" id="L686">			this.handleSelectedDateUpdate(dateInMillis, NO_VALUE);</span>
<span class="nc" id="L687">			this.updateCurrentPosition(mScrolledYear, mScrolledMonth);</span>
		}
<span class="nc" id="L689">	}</span>

	/**
	 * Handles update in the current selected date (if any) and notifies any registered listeners
	 * about this change.
	 * &lt;p&gt;
	 * Depending on the specified &lt;var&gt;dateInMillis&lt;/var&gt; ({@code null} or {@code not null}) this
	 * method will also update visible date to the selected one and also the current visible month
	 * position accordingly.
	 *
	 * @param dateInMillis         The new selected date in milliseconds. May be {@code null} to clear the
	 *                             current one.
	 * @param monthAdapterPosition Position of the MonthView from the current adapter in which has
	 *                             been the date selected. May be {@link #NO_VALUE} to calculate the
	 *                             position using the adapter's {@link CalendarAdapter#calculateMonthPosition(int, int)}
	 *                             if the date has been selected via code and not by a user.
	 */
	final void handleSelectedDateUpdate(Long dateInMillis, int monthAdapterPosition) {
<span class="nc" id="L707">		this.mDateSelected = dateInMillis;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">		if (mDateSelected != null) {</span>
<span class="nc" id="L709">			mCalendar.clear();</span>
<span class="nc" id="L710">			mCalendar.setTimeInMillis(mDateSelected);</span>
<span class="nc" id="L711">			final int year = mCalendar.get(Calendar.YEAR);</span>
<span class="nc" id="L712">			final int month = mCalendar.get(Calendar.MONTH);</span>
<span class="nc" id="L713">			this.handleVisibleDateUpdate(year, month);</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">			if (monthAdapterPosition == NO_POSITION &amp;&amp; mAdapter != null) {</span>
<span class="nc" id="L715">				this.mSelectedDateMonthPosition = mAdapter.calculateMonthPosition(mDateSelected);</span>
<span class="nc" id="L716">				this.updateCurrentPosition(year, month);</span>
			}
<span class="nc" id="L718">		} else {</span>
<span class="nc" id="L719">			this.mSelectedDateMonthPosition = NO_POSITION;</span>
		}
<span class="nc bnc" id="L721" title="All 2 branches missed.">		if (mAdapter != null) {</span>
<span class="nc" id="L722">			mAdapter.setSelectedDate(mDateSelected);</span>
		}
<span class="nc" id="L724">		this.notifySelectedDateChange();</span>
<span class="nc" id="L725">	}</span>

	/**
	 * Notifies the current OnDateSelectionListener, that the current selected date ({@link #mDateSelected})
	 * has been changed.
	 */
	private void notifySelectedDateChange() {
<span class="nc bnc" id="L732" title="All 2 branches missed.">		if (mDateSelectionListener != null) {</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">			if (mDateSelected != null) mDateSelectionListener.onDateSelected(this, mDateSelected);</span>
<span class="nc" id="L734">			else mDateSelectionListener.onNoDateSelected(this);</span>
		}
<span class="nc" id="L736">	}</span>

	/**
	 * Same as {@link #getSelectedDateInMillis()} for {@link Date} object.
	 *
	 * @return The current selected date.
	 */
	@Nullable
	public Date getSelectedDate() {
<span class="nc bnc" id="L745" title="All 2 branches missed.">		return mDateSelected != null ? new Date(mDateSelected) : null;</span>
	}

	/**
	 * Returns the current selected date that has been selected by a user or via {@link #setSelectedDate(long)}.
	 * &lt;p&gt;
	 * The returned date (if any) will contain data for &lt;b&gt;{@link Calendar#YEAR}, {@link Calendar#MONTH}&lt;/b&gt;,
	 * and &lt;b&gt;{@link Calendar#DAY_OF_MONTH}&lt;/b&gt;.
	 *
	 * @return The current selected date in milliseconds or {@code null} if there has not been selected
	 * any date yet.
	 */
	@Nullable
	public Long getSelectedDateInMillis() {
<span class="nc" id="L759">		return mDateSelected;</span>
	}

	/**
	 * Same as {@link #setVisibleDate(long)} for {@link Date} object.
	 *
	 * @param date The desired visible date.
	 * @see #getVisibleDate()
	 */
	public void setVisibleDate(@NonNull Date date) {
<span class="nc" id="L769">		setVisibleDate(date.getTime());</span>
<span class="nc" id="L770">	}</span>

	/**
	 * Sets a date on which should be this calendar view at this time scrolled. This basically defines
	 * a month in a desired year that should be visible to a user so he/she can pick his/hers desired
	 * date.
	 *
	 * @param dateInMillis The desired visible date in milliseconds.
	 * @see #getVisibleDateInMillis()
	 */
	public void setVisibleDate(long dateInMillis) {
<span class="nc bnc" id="L781" title="All 2 branches missed.">		if (mDateVisible != dateInMillis) {</span>
<span class="nc" id="L782">			mCalendar.clear();</span>
<span class="nc" id="L783">			mCalendar.setTimeInMillis(dateInMillis);</span>
<span class="nc" id="L784">			this.handleVisibleDateUpdate(mCalendar.get(Calendar.YEAR), mCalendar.get(Calendar.MONTH));</span>
<span class="nc" id="L785">			this.updateCurrentPosition(mScrolledYear, mScrolledMonth);</span>
		}
<span class="nc" id="L787">	}</span>

	/**
	 * Handles the update in the currently visible date.
	 * &lt;p&gt;
	 * This should be called whenever there has been change in scroll of this calendar view as the
	 * currently visible MonthView represents/shows a different date (month + year).
	 *
	 * @param year  Year number at which is this calendar view at this time scrolled.
	 * @param month Month number at which is this calendar view at this time scrolled
	 */
	private void handleVisibleDateUpdate(int year, int month) {
<span class="nc" id="L799">		this.mCalendar.clear();</span>
<span class="nc" id="L800">		this.mCalendar.set(Calendar.YEAR, mScrolledYear = year);</span>
<span class="nc" id="L801">		this.mCalendar.set(Calendar.MONTH, mScrolledMonth = month);</span>
<span class="nc" id="L802">		this.mCalendar.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L803">		this.mDateVisible = mCalendar.getTimeInMillis();</span>
<span class="nc" id="L804">	}</span>

	/**
	 * Updates the current visible position of this calendar view according to the specified &lt;var&gt;year&lt;/var&gt;
	 * and &lt;var&gt;month&lt;/var&gt;.
	 *
	 * @param year  The year number used to calculate position to update to.
	 * @param month The month number used to calculate position to update to.
	 */
	private void updateCurrentPosition(int year, int month) {
<span class="nc" id="L814">		final int currentMonthPosition = getCurrentMonthAdapterPosition();</span>
<span class="nc" id="L815">		final int position = mAdapter.calculateMonthPosition(year, month);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">		if (position != currentMonthPosition) {</span>
<span class="nc" id="L817">			SCROLL_TO_POSITION.position = position;</span>
<span class="nc" id="L818">			post(SCROLL_TO_POSITION);</span>
		}
<span class="nc" id="L820">	}</span>

	/**
	 * Returns the position within adapter of the currently visible month view.
	 *
	 * @return Month adapter position or {@link #NO_POSITION} if it is not possible to determine
	 * such position.
	 */
	private int getCurrentMonthAdapterPosition() {
<span class="nc bnc" id="L829" title="All 2 branches missed.">		return mLinearLayoutManager != null ?</span>
<span class="nc" id="L830">				mLinearLayoutManager.findFirstVisibleItemPosition() :</span>
				NO_POSITION;
	}

	/**
	 * Same as {@link #getVisibleDateInMillis()} for {@link Date} object.
	 *
	 * @return Currently visible date.
	 * @see #setVisibleDate(Date)
	 */
	@NonNull
	public Date getVisibleDate() {
<span class="nc" id="L842">		return new Date(mDateVisible);</span>
	}

	/**
	 * Returns the date (year + month) on which is this calendar view at this time scrolled.
	 *
	 * @return Currently visible date in milliseconds.
	 * @see #setVisibleDate(long)
	 */
	public long getVisibleDateInMillis() {
<span class="nc" id="L852">		return mDateVisible;</span>
	}

	/**
	 * Sets an adapter that will provide data set of months for this calendar view.
	 *
	 * @param adapter The desired adapter.
	 * @param &lt;A&gt;     Type of the desired adapter.
	 * @see #getCalendarAdapter()
	 */
	public &lt;A extends RecyclerView.Adapter &amp; CalendarAdapter&gt; void setCalendarAdapter(@NonNull A adapter) {
<span class="nc bnc" id="L863" title="All 2 branches missed.">		if (mAdapter != null) {</span>
<span class="nc" id="L864">			mAdapter.setOnMonthDaySelectionListener(null);</span>
		}
<span class="nc" id="L866">		this.mAdapter = adapter;</span>
<span class="nc" id="L867">		this.mAdapter.setOnMonthDaySelectionListener(CALLBACKS_HANDLER);</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">		if (mDateSelected != null &amp;&amp; mSelectedDateMonthPosition == NO_POSITION) {</span>
<span class="nc" id="L869">			this.mSelectedDateMonthPosition = mAdapter.calculateMonthPosition(mDateSelected);</span>
<span class="nc" id="L870">			this.mAdapter.setSelectedDate(mDateSelected);</span>
		}
<span class="nc" id="L872">		super.setAdapter(adapter);</span>
<span class="nc" id="L873">	}</span>

	/**
	 * Returns the adapter that provides data set of months for this calendar view.
	 *
	 * @param &lt;A&gt; Type of the requested adapter. Should be the same type as specified via
	 *            {@link #setCalendarAdapter(Adapter)}
	 * @return The current adapter. Default is {@link SimpleCalendarAdapter}.
	 * @see #setCalendarAdapter(Adapter)
	 */
	@NonNull
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;A extends RecyclerView.Adapter &amp; CalendarAdapter&gt; A getCalendarAdapter() {
<span class="nc" id="L886">		return (A) mAdapter;</span>
	}

	/**
	 */
	@Override
	public final void setAdapter(Adapter adapter) {
<span class="nc" id="L893">		Log.e(TAG, &quot;Use CalendarView.setCalendarAdapter(A extends RecyclerView.Adapter &amp; CalendarAdapter) instead.&quot;);</span>
<span class="nc" id="L894">	}</span>

	/**
	 */
	@Override
	public final Adapter getAdapter() {
<span class="nc" id="L900">		return super.getAdapter();</span>
	}

	/**
	 */
	@Override
	@SuppressWarnings(&quot;deprecation&quot;)
	public void setBackgroundDrawable(Drawable background) {
<span class="nc" id="L908">		super.setBackgroundDrawable(background);</span>
<span class="nc" id="L909">		this.ensureDecorator();</span>
<span class="nc" id="L910">		mDecorator.applyBackgroundTint();</span>
<span class="nc" id="L911">	}</span>

	/**
	 * &lt;b&gt;Note, that on pre {@link android.os.Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android versions
	 * this method will return an instance of {@link TintDrawable TintDrawable} if tint has been applied
	 * via {@link #setBackgroundTintList(ColorStateList)}.&lt;/b&gt;
	 * &lt;p&gt;
	 * The original wrapped drawable can be obtained via {@link TintDrawable#getDrawable()}.
	 */
	@Override
	public Drawable getBackground() {
<span class="nc" id="L922">		return super.getBackground();</span>
	}

	/**
	 */
	@Override
	public void setBackgroundTintList(@Nullable ColorStateList tint) {
<span class="nc" id="L929">		this.ensureDecorator();</span>
<span class="nc" id="L930">		mDecorator.setBackgroundTintList(tint);</span>
<span class="nc" id="L931">	}</span>

	/**
	 */
	@Nullable
	@Override
	public ColorStateList getBackgroundTintList() {
<span class="nc" id="L938">		this.ensureDecorator();</span>
<span class="nc" id="L939">		return mDecorator.getBackgroundTintList();</span>
	}

	/**
	 */
	@Override
	public void setBackgroundTintMode(@Nullable PorterDuff.Mode tintMode) {
<span class="nc" id="L946">		this.ensureDecorator();</span>
<span class="nc" id="L947">		mDecorator.setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L948">	}</span>

	/**
	 */
	@Nullable
	@Override
	public PorterDuff.Mode getBackgroundTintMode() {
<span class="nc" id="L955">		this.ensureDecorator();</span>
<span class="nc" id="L956">		return mDecorator.getBackgroundTintMode();</span>
	}

	/**
	 */
	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
<span class="nc" id="L963">		this.ensureMockMonthView();</span>
		// Size of CalendarView will depend on size of a single MonthView with largest (in drawing area)
		// numbers data set.
<span class="nc" id="L966">		mMockMonthView.measure(widthMeasureSpec, heightMeasureSpec);</span>
<span class="nc" id="L967">		setMeasuredDimension(</span>
<span class="nc" id="L968">				mMockMonthView.getMeasuredWidth(),</span>
<span class="nc" id="L969">				mMockMonthView.getMeasuredHeight()</span>
		);
<span class="nc" id="L971">	}</span>

	/**
	 * Ensures that the mock MonthView is initialized.
	 */
	private void ensureMockMonthView() {
<span class="nc bnc" id="L977" title="All 2 branches missed.">		if (mMockMonthView == null) {</span>
<span class="nc" id="L978">			this.mMockMonthView = new MonthView(getContext());</span>
			// Set mock date so month view can measure its size.
<span class="nc" id="L980">			mMockMonthView.setDate(new Date(System.currentTimeMillis()));</span>
		}
<span class="nc" id="L982">	}</span>

	/**
	 */
	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
<span class="nc" id="L988">		super.onSizeChanged(w, h, oldw, oldh);</span>
<span class="nc" id="L989">		this.ensureDecorator();</span>
<span class="nc" id="L990">		mDecorator.onSizeChanged(w, h, oldw, oldh);</span>
<span class="nc" id="L991">	}</span>

	/**
	 */
	@NonNull
	@Override
	public WidgetSizeAnimator animateSize() {
<span class="nc bnc" id="L998" title="All 2 branches missed.">		return (mSizeAnimator != null) ? mSizeAnimator : (mSizeAnimator = new WidgetSizeAnimator(this));</span>
	}

	/**
	 */
	@Override
	public boolean onTouchEvent(@NonNull MotionEvent event) {
<span class="nc" id="L1005">		this.ensureDecorator();</span>
<span class="nc bnc" id="L1006" title="All 3 branches missed.">		switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {</span>
			case MotionEvent.ACTION_DOWN:
<span class="nc" id="L1008">				mDecorator.updatePrivateFlags(PFLAG_PRESSED, true);</span>
<span class="nc" id="L1009">				break;</span>
			case MotionEvent.ACTION_CANCEL:
			case MotionEvent.ACTION_UP:
<span class="nc" id="L1012">				mDecorator.updatePrivateFlags(PFLAG_PRESSED, false);</span>
				break;
		}
<span class="nc" id="L1015">		return super.onTouchEvent(event);</span>
	}

	/**
	 */
	@Override
	public boolean fling(int velocityX, int velocityY) {
<span class="nc" id="L1022">		return super.fling(overrideFlingVelocity(velocityX), overrideFlingVelocity(velocityY));</span>
	}

	/**
	 * Overrides the given &lt;var&gt;velocity&lt;/var&gt; according to the {@link #mFlingMinVelocity} and
	 * {@link #mFlingMaxVelocity} values.
	 *
	 * @param velocity The velocity to correct.
	 * @return Corrected velocity in the range [{@link #mMinFlingVelocity}, {@link #mMaxFlingVelocity}].
	 */
	private int overrideFlingVelocity(int velocity) {
<span class="nc bnc" id="L1033" title="All 4 branches missed.">		return velocity != 0 ?</span>
<span class="nc" id="L1034">				(int) (velocity &lt; 0 ? Math.max(-mFlingMaxVelocity, velocity) : Math.min(mFlingMaxVelocity, velocity)) :</span>
				0;
	}

	/**
	 * Scrolls smoothly to the previous month if this calendar view is not already scrolled at its
	 * first month available.
	 *
	 * @return {@code True} if the smooth scroll has been performed, {@code false} if last month
	 * available is already visible.
	 * @see #canScrollToPreviousMonth()
	 * @see #smoothScrollToNextMonth()
	 */
	public boolean smoothScrollToPreviousMonth() {
<span class="nc" id="L1048">		final int currentMonthPosition = getCurrentMonthAdapterPosition();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">		if (currentMonthPosition &gt; 0) {</span>
<span class="nc" id="L1050">			smoothScrollToPosition(currentMonthPosition - 1);</span>
<span class="nc" id="L1051">			return true;</span>
		}
<span class="nc" id="L1053">		return false;</span>
	}

	/**
	 * Checks whether this calendar view can be scrolled to its previous month or not.
	 *
	 * @return {@code True} if the calendar view is not scrolled at its first month from the current
	 * data set and invocation of {@link #smoothScrollToPreviousMonth()} will return {@code true},
	 * {@code false} otherwise.
	 */
	public boolean canScrollToPreviousMonth() {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">		return getCurrentMonthAdapterPosition() &gt; 0;</span>
	}

	/**
	 * Scrolls smoothly to the next month if this calendar view is not already scrolled at its
	 * last month available.
	 *
	 * @return {@code True} if the smooth scroll has been performed, {@code false} if first month
	 * available is already visible.
	 * @see #canScrollToNextMonth()
	 * @see #smoothScrollToPreviousMonth()
	 */
	public boolean smoothScrollToNextMonth() {
<span class="nc" id="L1077">		final int currentMonthPosition = getCurrentMonthAdapterPosition();</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">		if (currentMonthPosition &lt; (getAdapter().getItemCount() - 1)) {</span>
<span class="nc" id="L1079">			smoothScrollToPosition(currentMonthPosition + 1);</span>
<span class="nc" id="L1080">			return true;</span>
		}
<span class="nc" id="L1082">		return false;</span>
	}

	/**
	 * Checks whether this calendar view can be scrolled to its next month or not.
	 *
	 * @return {@code True} if the calendar view is not scrolled at its last month from the current
	 * data set and invocation of {@link #smoothScrollToNextMonth()} will return {@code true},
	 * {@code false} otherwise.
	 */
	public boolean canScrollToNextMonth() {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">		return getCurrentMonthAdapterPosition() &lt; (getAdapter().getItemCount() - 1);</span>
	}

	/**
	 * Notifies the current OnMonthChangeListener, that scroll of the specified &lt;var&gt;month&lt;/var&gt; has
	 * been changed.
	 *
	 * @param month          Number of month with changed scroll.
	 * @param positionOffset Current position offset of the month's view according to this parent
	 *                       calendar view visible bounds.
	 */
	void notifyMonthScrolled(int month, float positionOffset) {
<span class="nc bnc" id="L1105" title="All 2 branches missed.">		if (mMonthChangeListener != null)</span>
<span class="nc" id="L1106">			mMonthChangeListener.onMonthScrolled(this, month, positionOffset);</span>
<span class="nc" id="L1107">	}</span>

	/**
	 * Notifies the current OnMonthChangeListener, that the specified &lt;var&gt;month&lt;/var&gt; has been changed.
	 *
	 * @param month Number of changed month.
	 */
	void notifyMonthChanged(int month) {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">		if (mMonthChangeListener != null) mMonthChangeListener.onMonthChanged(this, month);</span>
<span class="nc" id="L1116">	}</span>

	/**
	 * Notifies the current OnYearChangeListener, that the specified &lt;var&gt;year&lt;/var&gt; has been changed.
	 *
	 * @param year The changed year number.
	 */
	void notifyYearChanged(int year) {
<span class="nc bnc" id="L1124" title="All 2 branches missed.">		if (mYearChangeListener != null) mYearChangeListener.onYearChanged(this, year);</span>
<span class="nc" id="L1125">	}</span>

	/**
	 */
	@Override
	public Parcelable onSaveInstanceState() {
<span class="nc" id="L1131">		final SavedState savedState = new SavedState(super.onSaveInstanceState());</span>
<span class="nc" id="L1132">		savedState.dateVisible = mDateVisible;</span>
<span class="nc" id="L1133">		savedState.dateSelected = mDateSelected;</span>
<span class="nc" id="L1134">		savedState.selectedDayMonthPosition = mSelectedDateMonthPosition;</span>
<span class="nc" id="L1135">		savedState.locale = getLocale();</span>
<span class="nc" id="L1136">		savedState.adapterState = mAdapter.saveInstanceState();</span>
<span class="nc" id="L1137">		return savedState;</span>
	}

	/**
	 */
	@Override
	public void onRestoreInstanceState(Parcelable state) {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">		if (!(state instanceof SavedState)) {</span>
<span class="nc" id="L1145">			super.onRestoreInstanceState(state);</span>
<span class="nc" id="L1146">			return;</span>
		}
<span class="nc" id="L1148">		final SavedState savedState = (SavedState) state;</span>
<span class="nc" id="L1149">		super.onRestoreInstanceState(savedState.getSuperState());</span>
<span class="nc" id="L1150">		this.mDateSelected = savedState.dateSelected;</span>
<span class="nc" id="L1151">		this.mDateVisible = savedState.dateVisible;</span>
<span class="nc" id="L1152">		this.mCalendar = Calendar.getInstance(savedState.locale);</span>
<span class="nc" id="L1153">		this.mCalendar.clear();</span>
<span class="nc" id="L1154">		this.mCalendar.setTimeInMillis(mDateVisible);</span>
<span class="nc" id="L1155">		this.mScrolledYear = mCalendar.get(Calendar.YEAR);</span>
<span class="nc" id="L1156">		this.mScrolledMonth = mCalendar.get(Calendar.MONTH);</span>
<span class="nc" id="L1157">		this.mSelectedDateMonthPosition = savedState.selectedDayMonthPosition;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if (mAdapter != null) {</span>
<span class="nc" id="L1159">			mAdapter.setLocale(savedState.locale);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">			if (savedState.adapterState != null) {</span>
<span class="nc" id="L1161">				mAdapter.restoreInstanceState(savedState.adapterState);</span>
			}
		}
<span class="nc" id="L1164">		updateCurrentPosition(mScrolledYear, mScrolledMonth);</span>
<span class="nc" id="L1165">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */

	/**
	 * A {@link CalendarAdapter} implementation that provides simple data set of months for CalendarView.
	 * This adapter implementation creates instances of {@link MonthView} as its item views and uses
	 * {@link CalendarDataSet} helper to properly provide data set of months.
	 *
	 * @author Martin Albedinsky
	 */
	public static class SimpleCalendarAdapter extends RecyclerView.Adapter implements CalendarAdapter {

		/**
		 * Context within which is this adapter used.
		 */
		protected final Context context;

		/**
		 * Layout inflater used to inflate item views of this adapter.
		 */
		protected final LayoutInflater layoutInflater;

		/**
		 * Helper object used to provide proper set of months by this adapter.
		 */
		final CalendarDataSet dataSet;

		/**
		 * Locale used primary to present text data.
		 */
<span class="nc" id="L1198">		Locale locale = Locale.getDefault();</span>

		/**
		 * Listener used to listen for selected day within a {@link MonthView} at a specific position.
		 */
		OnMonthDaySelectionListener monthDaySelectionListener;

		/**
		 * Date that is currently selected. May be {@code null} if no date is selected.
		 */
		Long selectedDate;

		/**
		 * Day number from the range {@code [1, 31]} of the selected date.
		 */
<span class="nc" id="L1213">		int selectedDay = NO_VALUE;</span>

		/**
		 * Position of a month from the current data set where the current selected date has been
		 * selected.
		 */
<span class="nc" id="L1219">		int selectedDayMonthPosition = NO_POSITION;</span>

		/**
		 * The recycler view to which is this adapter attached (if any).
		 */
		RecyclerView recyclerView;

		/**
		 * Creates a new instance of SimpleCalendarAdapter to provide data set of months.
		 *
		 * @param context Context in which will be the new adapter used. This context will be used
		 *                when creating item views for the adapter.
		 * @param dataSet Calendar data set used to provide set of months for the desired min + max
		 *                date boundaries.
		 */
<span class="nc" id="L1234">		public SimpleCalendarAdapter(@NonNull Context context, @NonNull CalendarDataSet dataSet) {</span>
<span class="nc" id="L1235">			this.context = context;</span>
<span class="nc" id="L1236">			this.layoutInflater = LayoutInflater.from(context);</span>
<span class="nc" id="L1237">			this.dataSet = dataSet;</span>
<span class="nc" id="L1238">		}</span>

		/**
		 */
		@Override
		public void setOnMonthDaySelectionListener(@Nullable OnMonthDaySelectionListener listener) {
<span class="nc" id="L1244">			this.monthDaySelectionListener = listener;</span>
<span class="nc" id="L1245">		}</span>

		/**
		 */
		@Override
		public void setMinMaxDate(long minDateInMillis, long maxDateInMillis) {
<span class="nc bnc" id="L1251" title="All 2 branches missed.">			if (dataSet.setMinMaxDate(minDateInMillis, maxDateInMillis)) notifyDataSetChanged();</span>
<span class="nc" id="L1252">		}</span>

		/**
		 */
		@Override
		public long getDateMinInMillis() {
<span class="nc" id="L1258">			return dataSet.dateMin;</span>
		}

		/**
		 */
		@Override
		public long getDateMaxInMillis() {
<span class="nc" id="L1265">			return dataSet.dateMax;</span>
		}

		/**
		 */
		@Override
		public int getItemCount() {
<span class="nc" id="L1272">			return dataSet.getSize();</span>
		}

		/**
		 */
		@Override
		public void setSelectedDate(@Nullable Long dateInMillis) {
<span class="nc bnc" id="L1279" title="All 8 branches missed.">			if ((selectedDate == null &amp;&amp; dateInMillis == null) || (selectedDate != null &amp;&amp; selectedDate.equals(dateInMillis))) {</span>
<span class="nc" id="L1280">				return;</span>
			}
<span class="nc" id="L1282">			this.selectedDate = dateInMillis;</span>
<span class="nc" id="L1283">			this.selectedDay = NO_VALUE;</span>
<span class="nc" id="L1284">			this.selectedDayMonthPosition = NO_POSITION;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">			if (dateInMillis != null) {</span>
<span class="nc" id="L1286">				dataSet.calendar.clear();</span>
<span class="nc" id="L1287">				dataSet.calendar.setTimeInMillis(dateInMillis);</span>
<span class="nc" id="L1288">				this.selectedDay = dataSet.calendar.get(Calendar.DAY_OF_MONTH);</span>
<span class="nc" id="L1289">				this.selectedDayMonthPosition = dataSet.calculateMonthPosition(dateInMillis);</span>
			}
<span class="nc bnc" id="L1291" title="All 4 branches missed.">			if (recyclerView == null || !recyclerView.isComputingLayout()) {</span>
<span class="nc" id="L1292">				notifyDataSetChanged();</span>
			}
<span class="nc" id="L1294">		}</span>

		/**
		 */
		@Override
		public int calculateMonthPosition(long dateInMillis) {
<span class="nc" id="L1300">			return dataSet.calculateMonthPosition(dateInMillis);</span>
		}

		/**
		 */
		@Override
		public int calculateMonthPosition(int year, int month) {
<span class="nc" id="L1307">			return dataSet.calculateMonthPosition(year, month);</span>
		}

		/**
		 */
		@Override
		public long getMonthDate(int position) {
<span class="nc" id="L1314">			return dataSet.getMonthDate(position);</span>
		}

		/**
		 */
		@Override
		public void setLocale(@NonNull Locale locale) {
<span class="nc bnc" id="L1321" title="All 2 branches missed.">			if (!this.locale.equals(locale)) {</span>
<span class="nc" id="L1322">				this.locale = locale;</span>
<span class="nc" id="L1323">				this.dataSet.setCalendar(Calendar.getInstance(locale));</span>
<span class="nc bnc" id="L1324" title="All 4 branches missed.">				if (recyclerView == null || !recyclerView.isComputingLayout()) {</span>
<span class="nc" id="L1325">					notifyDataSetChanged();</span>
				}
			}
<span class="nc" id="L1328">		}</span>

		/**
		 */
		@NonNull
		@Override
		public Locale getLocale() {
<span class="nc" id="L1335">			return locale;</span>
		}

		/**
		 */
		@Override
		public void onAttachedToRecyclerView(RecyclerView recyclerView) {
<span class="nc" id="L1342">			super.onAttachedToRecyclerView(recyclerView);</span>
<span class="nc" id="L1343">			this.recyclerView = recyclerView;</span>
<span class="nc" id="L1344">		}</span>

		/**
		 */
		@Override
		public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
<span class="nc" id="L1350">			return new ItemHolder(new MonthView(context));</span>
		}

		/**
		 */
		@Override
		public void onBindViewHolder(ViewHolder holder, int position) {
<span class="nc" id="L1357">			onBindViewHolder(holder, position, dataSet.getMonthDate(position));</span>
<span class="nc" id="L1358">		}</span>

		/**
		 * Invoked from {@link #onBindViewHolder(ViewHolder, int)} with the given &lt;var&gt;dateInMillis&lt;/var&gt;
		 * that is associated with the {@link MonthView} at the &lt;var&gt;position&lt;/var&gt; according to the
		 * current data set size.
		 *
		 * @param holder       View holder to bind.
		 * @param position     The position for which to perform binding.
		 * @param dateInMillis Date in milliseconds obtained for the month position via
		 *                     {@link CalendarDataSet#getMonthDate(int)}.
		 */
		@SuppressWarnings(&quot;ResourceType&quot;)
		protected void onBindViewHolder(@NonNull ViewHolder holder, int position, long dateInMillis) {
<span class="nc" id="L1372">			final MonthView monthView = (MonthView) holder.itemView;</span>
<span class="nc" id="L1373">			monthView.setLocale(locale);</span>
<span class="nc" id="L1374">			monthView.setDate(dateInMillis);</span>
<span class="nc bnc" id="L1375" title="All 4 branches missed.">			if (selectedDayMonthPosition == position &amp;&amp; selectedDay != NO_VALUE) {</span>
<span class="nc" id="L1376">				monthView.setSelection(selectedDay);</span>
			} else {
<span class="nc" id="L1378">				monthView.setSelection(0);</span>
			}
<span class="nc" id="L1380">		}</span>

		/**
		 */
		@NonNull
		@Override
		public Parcelable saveInstanceState() {
<span class="nc" id="L1387">			final SimpleCalendarAdapter.SavedState state = new SimpleCalendarAdapter.SavedState(SavedState.EMPTY_STATE);</span>
<span class="nc" id="L1388">			state.dataSet = dataSet;</span>
<span class="nc" id="L1389">			state.selectedDate = selectedDate;</span>
<span class="nc" id="L1390">			state.selectedDay = selectedDay;</span>
<span class="nc" id="L1391">			state.selectedDayMonthPosition = selectedDayMonthPosition;</span>
<span class="nc" id="L1392">			return state;</span>
		}

		/**
		 */
		@Override
		public void restoreInstanceState(@NonNull Parcelable savedState) {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">			if (!(savedState instanceof SimpleCalendarAdapter.SavedState)) {</span>
<span class="nc" id="L1400">				return;</span>
			}
<span class="nc" id="L1402">			final SimpleCalendarAdapter.SavedState state = (SimpleCalendarAdapter.SavedState) savedState;</span>
<span class="nc" id="L1403">			this.dataSet.set(state.dataSet);</span>
<span class="nc" id="L1404">			this.selectedDate = state.selectedDate;</span>
<span class="nc" id="L1405">			this.selectedDay = state.selectedDay;</span>
<span class="nc" id="L1406">			this.selectedDayMonthPosition = state.selectedDayMonthPosition;</span>
<span class="nc" id="L1407">			notifyDataSetChanged();</span>
<span class="nc" id="L1408">		}</span>

		/**
		 */
		@Override
		public void onDetachedFromRecyclerView(RecyclerView recyclerView) {
<span class="nc" id="L1414">			super.onDetachedFromRecyclerView(recyclerView);</span>
<span class="nc" id="L1415">			this.recyclerView = null;</span>
<span class="nc" id="L1416">		}</span>

		/**
		 * A {@link ViewHolder} implementation for month item view.
		 */
		final class ItemHolder extends ViewHolder implements MonthView.OnDaySelectionListener {

			/**
			 * Creates a new instance of ItemHolder for the specified &lt;var&gt;monthView&lt;/var&gt;.
			 */
<span class="nc" id="L1426">			ItemHolder(MonthView monthView) {</span>
<span class="nc" id="L1427">				super(monthView);</span>
<span class="nc" id="L1428">				monthView.setOnDaySelectionListener(this);</span>
<span class="nc" id="L1429">			}</span>

			/**
			 */
			@Override
			public void onDaySelected(@NonNull MonthView monthView, @IntRange(from = 1, to = 31) int day, long dateInMillis) {
<span class="nc bnc" id="L1435" title="All 2 branches missed.">				if (monthDaySelectionListener != null) monthDaySelectionListener.onMonthDaySelected(</span>
						monthView,
						day,
<span class="nc" id="L1438">						dateInMillis, getAdapterPosition()</span>
				);
<span class="nc" id="L1440">			}</span>
		}

		/**
		 * A {@link WidgetSavedState} implementation used to ensure that the state of {@link SimpleCalendarAdapter}
		 * is properly saved.
		 */
		static final class SavedState extends WidgetSavedState {

			/**
			 * Creator used to create an instance or array of instances of SavedState from {@link android.os.Parcel}.
			 */
<span class="nc" id="L1452">			public static final Creator&lt;SimpleCalendarAdapter.SavedState&gt; CREATOR = new Creator&lt;SimpleCalendarAdapter.SavedState&gt;() {</span>
				/**
				 */
				@Override
				public SimpleCalendarAdapter.SavedState createFromParcel(@NonNull Parcel source) {
<span class="nc" id="L1457">					return new SimpleCalendarAdapter.SavedState(source);</span>
				}

				/**
				 */
				@Override
				public SimpleCalendarAdapter.SavedState[] newArray(int size) {
<span class="nc" id="L1464">					return new SimpleCalendarAdapter.SavedState[size];</span>
				}
			};

			/**
			 */
			CalendarDataSet dataSet;

			/**
			 */
			Long selectedDate;

			/**
			 */
			int selectedDay, selectedDayMonthPosition;

			/**
			 * Creates a new instance of SavedState with the given &lt;var&gt;superState&lt;/var&gt; to allow chaining
			 * of saved states in {@link #onSaveInstanceState()} and also in {@link #onRestoreInstanceState(android.os.Parcelable)}.
			 *
			 * @param superState The super state obtained from {@code super.onSaveInstanceState()} within
			 *                   {@code onSaveInstanceState()}.
			 */
			protected SavedState(@NonNull Parcelable superState) {
<span class="nc" id="L1488">				super(superState);</span>
<span class="nc" id="L1489">			}</span>

			/**
			 * Called from {@link #CREATOR} to create an instance of SavedState form the given parcel
			 * &lt;var&gt;source&lt;/var&gt;.
			 *
			 * @param source Parcel with data for the new instance.
			 */
			protected SavedState(@NonNull Parcel source) {
<span class="nc" id="L1498">				super(source);</span>
<span class="nc" id="L1499">				this.dataSet = source.readParcelable(UiConfig.class.getClassLoader());</span>
<span class="nc" id="L1500">				this.selectedDate = (Long) source.readValue(Long.class.getClassLoader());</span>
<span class="nc" id="L1501">				this.selectedDay = source.readInt();</span>
<span class="nc" id="L1502">				this.selectedDayMonthPosition = source.readInt();</span>
<span class="nc" id="L1503">			}</span>

			/**
			 */
			@Override
			public void writeToParcel(@NonNull Parcel dest, int flags) {
<span class="nc" id="L1509">				dest.writeParcelable(dataSet, flags);</span>
<span class="nc" id="L1510">				dest.writeValue(selectedDate);</span>
<span class="nc" id="L1511">				dest.writeInt(selectedDay);</span>
<span class="nc" id="L1512">				dest.writeInt(selectedDayMonthPosition);</span>
<span class="nc" id="L1513">			}</span>
		}
	}

	/**
	 * Helper class that may be used to simplify management of months data set provided by implementation
	 * of {@link CalendarAdapter}. Data set instance uses instance of {@link Calendar} to properly
	 * calculate as size of the data set that can be obtained via {@link #getSize()} also the proper
	 * positions for a specific &lt;b&gt;year + month&lt;/b&gt; pairs that can be requested via {@link #calculateMonthPosition(int, int)}
	 * or for a particular &lt;b&gt;date&lt;/b&gt; via {@link #calculateMonthPosition(long)}. Data set boundaries
	 * (starting date and count of months) may be specified via {@link #setMinMaxDate(long, long)}.
	 *
	 * @author Martin Albedinsky
	 */
	public static final class CalendarDataSet implements Parcelable {

		/**
		 * Creator used to create an instance or array of instances of CalendarDataSet from {@link android.os.Parcel}.
		 */
<span class="nc" id="L1532">		public static final Creator&lt;CalendarDataSet&gt; CREATOR = new Creator&lt;CalendarDataSet&gt;() {</span>
			/**
			 */
			@Override
			public CalendarDataSet createFromParcel(Parcel source) {
<span class="nc" id="L1537">				return new CalendarDataSet(source);</span>
			}

			/**
			 */
			@Override
			public CalendarDataSet[] newArray(int size) {
<span class="nc" id="L1544">				return new CalendarDataSet[size];</span>
			}
		};

		/**
		 * Calendar to be used by this data set to compute count of months to be provided depending
		 * on the specified &lt;b&gt;min&lt;/b&gt; and &lt;b&gt;max&lt;/b&gt; date boundaries via {@link #setMinMaxDate(long, long)}.
		 */
		Calendar calendar;

		/**
		 * Minimum date used to limit size of this data set and also to resolve its beginning.
		 */
		long dateMin;

		/**
		 * Maximum date used to limit size of this data set.
		 */
		long dateMax;

		/**
		 * Number of year at which this data set starts.
		 */
		int startingYear;

		/**
		 * Number of month at which this data set starts. This is basically first month in data set.
		 */
		int startingMonth;

		/**
		 * Count of months (items) currently provided by this data set.
		 */
<span class="nc" id="L1577">		int months = Integer.MAX_VALUE;</span>

		/**
		 * Creates a new instance of CalendarDataSet.
		 */
<span class="nc" id="L1582">		public CalendarDataSet() {</span>
<span class="nc" id="L1583">			this.calendar = Calendar.getInstance();</span>
<span class="nc" id="L1584">			this.startingYear = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L1585">			this.startingMonth = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L1586">		}</span>

		/**
		 * Called from {@link #CREATOR} to create an instance of CalendarDataSet form the given parcel
		 * &lt;var&gt;source&lt;/var&gt;.
		 *
		 * @param source Parcel with data for the new instance.
		 */
<span class="nc" id="L1594">		CalendarDataSet(Parcel source) {</span>
<span class="nc" id="L1595">			this.calendar = (Calendar) source.readSerializable();</span>
<span class="nc" id="L1596">			this.dateMin = source.readLong();</span>
<span class="nc" id="L1597">			this.dateMax = source.readLong();</span>
<span class="nc" id="L1598">			this.startingYear = source.readInt();</span>
<span class="nc" id="L1599">			this.startingMonth = source.readInt();</span>
<span class="nc" id="L1600">			this.months = source.readInt();</span>
<span class="nc" id="L1601">		}</span>

		/**
		 */
		@Override
		public void writeToParcel(Parcel dest, int flags) {
<span class="nc" id="L1607">			dest.writeSerializable(calendar);</span>
<span class="nc" id="L1608">			dest.writeLong(dateMin);</span>
<span class="nc" id="L1609">			dest.writeLong(dateMax);</span>
<span class="nc" id="L1610">			dest.writeInt(startingYear);</span>
<span class="nc" id="L1611">			dest.writeInt(startingMonth);</span>
<span class="nc" id="L1612">			dest.writeInt(months);</span>
<span class="nc" id="L1613">		}</span>

		/**
		 */
		@Override
		public int describeContents() {
<span class="nc" id="L1619">			return 0;</span>
		}

		/**
		 * Sets all data of this data set from the specified one.
		 *
		 * @param dataSet The data set from which to set up this data set instance.
		 */
		public void set(@NonNull CalendarDataSet dataSet) {
<span class="nc" id="L1628">			this.calendar = dataSet.calendar;</span>
<span class="nc" id="L1629">			this.dateMin = dataSet.dateMin;</span>
<span class="nc" id="L1630">			this.dateMax = dataSet.dateMax;</span>
<span class="nc" id="L1631">			this.startingYear = dataSet.startingYear;</span>
<span class="nc" id="L1632">			this.startingMonth = dataSet.startingMonth;</span>
<span class="nc" id="L1633">			this.months = dataSet.months;</span>
<span class="nc" id="L1634">		}</span>

		/**
		 * Sets a calendar used by this data set properly calculate count of months according to
		 * specified data boundaries via {@link #setMinMaxDate(long, long)} and also to calculate
		 * position of a month for a specific &lt;b&gt;year + month&lt;/b&gt; pair via {@link #calculateMonthPosition(int, int)}.
		 *
		 * @param calendar The desired calendar instance. May be {@code null} to use default one.
		 * @see #getCalendar()
		 */
		public void setCalendar(@Nullable Calendar calendar) {
<span class="nc bnc" id="L1645" title="All 2 branches missed.">			this.calendar = calendar != null ? calendar : Calendar.getInstance();</span>
<span class="nc" id="L1646">		}</span>

		/**
		 * Returns the calendar used by this data set for its size calculations and also for month
		 * positions calculations.
		 *
		 * @return This data set's calendar. Default is {@link Calendar#getInstance()}.
		 * @see #setCalendar(Calendar)
		 */
		@NonNull
		public Calendar getCalendar() {
<span class="nc" id="L1657">			return calendar;</span>
		}

		/**
		 * Sets a minimum and maximum dates that are used to resolve from which date to start this
		 * data set and how large (in count of months) it should be.
		 *
		 * @param minDateInMillis The desired minimum date in milliseconds that determines the
		 *                        start of data set.
		 * @param maxDateInMillis The desired maximum date in milliseconds. May be {@code 0} to
		 *                        request &quot;infinite&quot; data set of months starting from the minimum date.
		 * @return {@code True} if data of this data set has changed, {@code false} otherwise.
		 * @see #getDateMin()
		 * @see #getDateMax()
		 */
		public boolean setMinMaxDate(long minDateInMillis, long maxDateInMillis) {
<span class="nc bnc" id="L1673" title="All 4 branches missed.">			if (minDateInMillis &lt; maxDateInMillis || maxDateInMillis == 0) {</span>
<span class="nc bnc" id="L1674" title="All 4 branches missed.">				if (dateMin != minDateInMillis || maxDateInMillis != dateMax) {</span>
					// Update bottom boundary.
<span class="nc" id="L1676">					calendar.clear();</span>
<span class="nc" id="L1677">					calendar.setTimeInMillis(dateMin = minDateInMillis);</span>
<span class="nc" id="L1678">					this.startingYear = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L1679">					this.startingMonth = calendar.get(Calendar.MONTH);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">					if ((dateMax = maxDateInMillis) != 0) {</span>
<span class="nc" id="L1681">						calendar.clear();</span>
<span class="nc" id="L1682">						calendar.setTimeInMillis(dateMax);</span>
<span class="nc" id="L1683">						this.months = (calendar.get(Calendar.YEAR) - startingYear) * MONTHS_IN_YEAR + calendar.get(Calendar.MONTH) - startingMonth + 1;</span>
					} else {
<span class="nc" id="L1685">						this.months = Integer.MAX_VALUE;</span>
					}
<span class="nc" id="L1687">					return true;</span>
				}
			}
<span class="nc" id="L1690">			return false;</span>
		}

		/**
		 * Returns the minimum date that limits size (count of months) of this data set.
		 *
		 * @return Minimum date in milliseconds.
		 * @see #getDateMax()
		 * @see #setMinMaxDate(long, long)
		 */
		public long getDateMin() {
<span class="nc" id="L1701">			return dateMin;</span>
		}

		/**
		 * Returns the maximum date that limits size (count of months) of this data set.
		 *
		 * @return Maximum date in milliseconds. May be {@code 0} if the current data set is &quot;infinite&quot;.
		 * @see #getDateMin()
		 * @see #setMinMaxDate(long, long)
		 */
		public long getDateMax() {
<span class="nc" id="L1712">			return dateMax;</span>
		}

		/**
		 * Returns the size of this data set.
		 *
		 * @return Count of months provided by this data set calculated according to the &lt;b&gt;min + max&lt;/b&gt;
		 * date boundaries specified via {@link #setMinMaxDate(long, long)}.
		 * @see #getDateMin()
		 * @see #getDateMax()
		 */
		public int getSize() {
<span class="nc" id="L1724">			return months;</span>
		}

		/**
		 * Same as {@link #calculateMonthPosition(int, int)} for the specified &lt;var&gt;dateInMillis&lt;/var&gt;
		 * from which will be extracted {@link Calendar#YEAR} and {@link Calendar#MONTH} values using
		 * {@link Calendar}.
		 *
		 * @param dateInMillis The desired date in milliseconds. Should contain year and month data.
		 * @return Computed month position.
		 */
		public int calculateMonthPosition(long dateInMillis) {
<span class="nc" id="L1736">			calendar.clear();</span>
<span class="nc" id="L1737">			calendar.setTimeInMillis(dateInMillis);</span>
<span class="nc" id="L1738">			return calculateMonthPosition(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH));</span>
		}

		/**
		 * Calculates a position of month for the given &lt;var&gt;year&lt;/var&gt; and &lt;var&gt;month&lt;/var&gt;.
		 *
		 * @param year  The year number of month for which to calculate position.
		 * @param month The month number for which to calculate position.
		 * @return Computed position of the requested month within the current data set that is in
		 * size of {@link #getSize()}.
		 */
		public int calculateMonthPosition(int year, int month) {
<span class="nc" id="L1750">			return (year - startingYear) * MONTHS_IN_YEAR + (month - startingMonth);</span>
		}

		/**
		 * Returns the date for a month at the requested &lt;var&gt;position&lt;/var&gt; calculated according
		 * to the &lt;b&gt;min + max&lt;/b&gt; date boundaries specified via {@link #setMinMaxDate(long, long)}.
		 *
		 * @param position The position of month for which to obtain the date.
		 * @return Calculated date with {@link Calendar#YEAR} and {@link Calendar#MONTH} data in milliseconds.
		 */
		public long getMonthDate(int position) {
			// Each position represents new month from the start date.
<span class="nc" id="L1762">			calendar.clear();</span>
<span class="nc" id="L1763">			calendar.set(Calendar.YEAR, startingYear + (startingMonth + position) / MONTHS_IN_YEAR);</span>
<span class="nc" id="L1764">			calendar.set(Calendar.MONTH, (startingMonth + position) % MONTHS_IN_YEAR);</span>
<span class="nc" id="L1765">			return calendar.getTimeInMillis();</span>
		}
	}

	/**
	 * A {@link WidgetSavedState} implementation used to ensure that the state of {@link CalendarView}
	 * is properly saved.
	 *
	 * @author Martin Albedinsky
	 */
	public static class SavedState extends WidgetSavedState {

		/**
		 * Creator used to create an instance or array of instances of SavedState from {@link android.os.Parcel}.
		 */
<span class="nc" id="L1780">		public static final Creator&lt;SavedState&gt; CREATOR = new Creator&lt;SavedState&gt;() {</span>
			/**
			 */
			@Override
			public SavedState createFromParcel(@NonNull Parcel source) {
<span class="nc" id="L1785">				return new SavedState(source);</span>
			}

			/**
			 */
			@Override
			public SavedState[] newArray(int size) {
<span class="nc" id="L1792">				return new SavedState[size];</span>
			}
		};

		/**
		 */
		int selectedDayMonthPosition;

		/**
		 */
		long dateVisible;

		/**
		 */
		Long dateSelected;

		/**
		 */
		Locale locale;

		/**
		 */
		Parcelable adapterState;

		/**
		 * Creates a new instance of SavedState with the given &lt;var&gt;superState&lt;/var&gt; to allow chaining
		 * of saved states in {@link #onSaveInstanceState()} and also in {@link #onRestoreInstanceState(android.os.Parcelable)}.
		 *
		 * @param superState The super state obtained from {@code super.onSaveInstanceState()} within
		 *                   {@code onSaveInstanceState()}.
		 */
		protected SavedState(@NonNull Parcelable superState) {
<span class="nc" id="L1824">			super(superState);</span>
<span class="nc" id="L1825">		}</span>

		/**
		 * Called from {@link #CREATOR} to create an instance of SavedState form the given parcel
		 * &lt;var&gt;source&lt;/var&gt;.
		 *
		 * @param source Parcel with data for the new instance.
		 */
		protected SavedState(@NonNull Parcel source) {
<span class="nc" id="L1834">			super(source);</span>
<span class="nc" id="L1835">			this.dateVisible = source.readLong();</span>
<span class="nc" id="L1836">			this.dateSelected = (Long) source.readValue(Long.class.getClassLoader());</span>
<span class="nc" id="L1837">			this.selectedDayMonthPosition = source.readInt();</span>
<span class="nc" id="L1838">			this.locale = (Locale) source.readSerializable();</span>
<span class="nc" id="L1839">			this.adapterState = source.readParcelable(UiConfig.class.getClassLoader());</span>
<span class="nc" id="L1840">		}</span>

		/**
		 */
		@Override
		public void writeToParcel(@NonNull Parcel dest, int flags) {
<span class="nc" id="L1846">			super.writeToParcel(dest, flags);</span>
<span class="nc" id="L1847">			dest.writeLong(dateVisible);</span>
<span class="nc" id="L1848">			dest.writeValue(dateSelected);</span>
<span class="nc" id="L1849">			dest.writeInt(selectedDayMonthPosition);</span>
<span class="nc" id="L1850">			dest.writeSerializable(locale);</span>
<span class="nc" id="L1851">			dest.writeParcelable(adapterState, flags);</span>
<span class="nc" id="L1852">		}</span>
	}

	/**
	 * Implementation of all listeners of which callbacks CalendarView want to receive.
	 */
<span class="nc" id="L1858">	private final class CallbacksHandler extends OnScrollListener implements OnMonthDaySelectionListener {</span>

		/**
		 * The child view that is at this time being scrolled.
		 */
		View scrolledChild;

		/**
		 * Position that is at this time being scrolled.
		 */
<span class="nc" id="L1868">		int scrolledPosition = NO_POSITION;</span>

		/**
		 * Current scroll state.
		 */
		int state;

		/**
		 */
		@Override
		public void onScrollStateChanged(RecyclerView view, int scrollState) {
<span class="nc" id="L1879">			this.state = scrollState;</span>
<span class="nc" id="L1880">			ensureDecorator();</span>
<span class="nc bnc" id="L1881" title="All 4 branches missed.">			if (mDecorator.hasPrivateFlag(PFLAG_PRESSED) || mLinearLayoutManager == null) {</span>
<span class="nc" id="L1882">				return;</span>
			}
<span class="nc bnc" id="L1884" title="All 3 branches missed.">			switch (state) {</span>
				case SCROLL_STATE_DRAGGING:
				case SCROLL_STATE_SETTLING:
<span class="nc" id="L1887">					break;</span>
				case SCROLL_STATE_IDLE:
<span class="nc bnc" id="L1889" title="All 2 branches missed.">					if (scrolledChild != null) {</span>
<span class="nc" id="L1890">						int scrollToPosition = getChildAdapterPosition(scrolledChild);</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">						switch (mLinearLayoutManager.getOrientation()) {</span>
							case LinearLayoutManager.VERTICAL:
<span class="nc" id="L1893">								final int childTop = scrolledChild.getTop();</span>
<span class="nc" id="L1894">								final int childHeight = scrolledChild.getHeight();</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">								if (Math.abs(childTop) &gt;= childHeight / 2) {</span>
									// Scroll to the next month view.
<span class="nc" id="L1897">									scrollToPosition++;</span>
								}
								break;
							default:
<span class="nc" id="L1901">								final int childLeft = scrolledChild.getLeft();</span>
<span class="nc" id="L1902">								final int childWidth = scrolledChild.getWidth();</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">								if (Math.abs(childLeft) &gt;= childWidth / 2) {</span>
									// Scroll to the next month view.
<span class="nc" id="L1905">									scrollToPosition++;</span>
								}
								break;
						}
<span class="nc" id="L1909">						SMOOTH_SCROLL_TO_POSITION.position = scrollToPosition;</span>
<span class="nc" id="L1910">						post(SMOOTH_SCROLL_TO_POSITION);</span>
<span class="nc" id="L1911">						this.handleMonthScroll(scrollToPosition);</span>
					}
					break;
			}
<span class="nc" id="L1915">		}</span>

		/**
		 */
		@Override
		public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
<span class="nc bnc" id="L1921" title="All 2 branches missed.">			if (mLinearLayoutManager != null) {</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">				switch (state) {</span>
					case SCROLL_STATE_DRAGGING:
					case SCROLL_STATE_SETTLING:
<span class="nc" id="L1925">						final int firstVisibleItemPosition = mLinearLayoutManager.findFirstVisibleItemPosition();</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">						if (firstVisibleItemPosition != scrolledPosition) {</span>
<span class="nc" id="L1927">							this.scrolledChild = mLinearLayoutManager.findViewByPosition(scrolledPosition = firstVisibleItemPosition);</span>
						}
<span class="nc bnc" id="L1929" title="All 2 branches missed.">						if (scrolledChild != null) {</span>
<span class="nc" id="L1930">							notifyMonthScrolled(</span>
<span class="nc" id="L1931">									getChildAdapterPosition(scrolledChild),</span>
<span class="nc" id="L1932">									Math.abs(scrolledChild.getLeft()) / (float) scrolledChild.getWidth()</span>
							);
						}
						break;
				}
			}
<span class="nc" id="L1938">		}</span>

		/**
		 * Handles change in the scroll of calendar view. This will fire {@link #notifyMonthChanged(int)}
		 * or {@link #notifyYearChanged(int)} whether the current scrolled year or month data
		 * has changed.
		 *
		 * @param monthPosition Position of month to which has been calendar view scrolled.
		 */
		void handleMonthScroll(int monthPosition) {
<span class="nc" id="L1948">			final long monthDate = mAdapter.getMonthDate(monthPosition);</span>
<span class="nc" id="L1949">			mCalendar.clear();</span>
<span class="nc" id="L1950">			mCalendar.setTimeInMillis(monthDate);</span>
<span class="nc" id="L1951">			final int month = mCalendar.get(Calendar.MONTH);</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">			if (mScrolledMonth == month) {</span>
<span class="nc" id="L1953">				return;</span>
			}
<span class="nc" id="L1955">			final int year = mCalendar.get(Calendar.YEAR);</span>
			// Notify changes.
<span class="nc bnc" id="L1957" title="All 2 branches missed.">			if (mScrolledYear != year) {</span>
<span class="nc" id="L1958">				handleVisibleDateUpdate(year, month);</span>
<span class="nc" id="L1959">				notifyMonthChanged(month);</span>
<span class="nc" id="L1960">				notifyYearChanged(year);</span>
			} else {
<span class="nc" id="L1962">				handleVisibleDateUpdate(year, month);</span>
<span class="nc" id="L1963">				notifyMonthChanged(month);</span>
			}
<span class="nc" id="L1965">		}</span>

		/**
		 */
		@Override
		public void onMonthDaySelected(@NonNull MonthView monthView, @IntRange(from = 1, to = 31) int day, long dateInMillis, int position) {
<span class="nc" id="L1971">			handleSelectedDateUpdate(dateInMillis, position);</span>
<span class="nc" id="L1972">		}</span>
	}

	/**
	 * Runnable used to execute {@link #smoothScrollToPosition(int)} method (delayed if needed).
	 */
<span class="nc" id="L1978">	private final class SmoothScrollToPosition implements Runnable {</span>

		/**
		 * Position to scroll smoothly to.
		 */
		int position;

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L1989">			smoothScrollToPosition(position);</span>
<span class="nc" id="L1990">		}</span>
	}

	/**
	 * Runnable used to execute {@link #scrollToPosition(int)} method (delayed if needed).
	 */
<span class="nc" id="L1996">	private final class ScrollToPosition implements Runnable {</span>

		/**
		 * Position to scroll to.
		 */
		int position;

		/**
		 */
		@Override
		public void run() {
<span class="nc" id="L2007">			scrollToPosition(position);</span>
<span class="nc" id="L2008">		}</span>
	}

	/**
	 * A {@link LinearLayoutManager} implementation that uses custom {@link SmoothScroller} implementation
	 * to customize smooth scrolling feature.
	 */
	private static final class LayoutManagerImpl extends LinearLayoutManager {

		/**
		 * Scrolling speed in milliseconds per inch.
		 */
		float scrollSpeedPerInch;

		/**
		 * Scroller used to perform smooth scroll requests.
		 */
		SmoothScroller scroller;

		/**
		 * Same as {@link #LayoutManagerImpl(Context, int, float)} with default scroll speed of
		 * {@code 50.0} per inch.
		 */
		LayoutManagerImpl(Context context, int orientation) {
<span class="nc" id="L2032">			this(context, orientation, 50.0f);</span>
<span class="nc" id="L2033">		}</span>

		/**
		 * Creates a new instance of LayoutManagerImpl with the specified &lt;var&gt;orientation&lt;/var&gt;.
		 *
		 * @param context            Context in which will be the new layout manager used.
		 * @param orientation        Orientation in which should manager layout views.
		 * @param scrollSpeedPerInch Speed in milliseconds per inch used to calculate scrolling speed
		 *                           per pixel.
		 */
		LayoutManagerImpl(Context context, int orientation, float scrollSpeedPerInch) {
<span class="nc" id="L2044">			super(context, orientation, false);</span>
<span class="nc" id="L2045">			this.scrollSpeedPerInch = scrollSpeedPerInch;</span>
<span class="nc" id="L2046">		}</span>

		/**
		 */
		@Override
		public void smoothScrollToPosition(RecyclerView recyclerView, State state, int position) {
<span class="nc bnc" id="L2052" title="All 2 branches missed.">			if (scroller == null) {</span>
<span class="nc" id="L2053">				this.scroller = new LinearSmoothScroller(recyclerView.getContext()) {</span>

					/**
					 */
					@Override
					public PointF computeScrollVectorForPosition(int targetPosition) {
<span class="nc" id="L2059">						return LayoutManagerImpl.this.computeScrollVectorForPosition(targetPosition);</span>
					}

					/**
					 */
					@Override
					protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) {
<span class="nc" id="L2066">						return scrollSpeedPerInch / displayMetrics.densityDpi;</span>
					}

					/**
					 */
					@Override
					protected int calculateTimeForScrolling(int dx) {
<span class="nc bnc" id="L2073" title="All 2 branches missed.">						return dx != 0 ? Math.max(super.calculateTimeForScrolling(dx), 50) : 0;</span>
					}
				};
			}
<span class="nc" id="L2077">			scroller.setTargetPosition(position);</span>
<span class="nc" id="L2078">			startSmoothScroll(scroller);</span>
<span class="nc" id="L2079">		}</span>
	}

	/**
	 * Decorator implementation for this widget.
	 */
	private final class Decorator extends WidgetDecorator&lt;CalendarView&gt; {

		/**
		 * See {@link WidgetDecorator#WidgetDecorator(View, int[])}.
		 */
<span class="nc" id="L2090">		Decorator(CalendarView widget) {</span>
<span class="nc" id="L2091">			super(widget, R.styleable.Ui_CalendarView);</span>
<span class="nc" id="L2092">		}</span>

		/**
		 */
		@Override
		void onProcessTintAttributes(Context context, TypedArray tintAttributes, int tintColor) {
			// Ignored.
<span class="nc" id="L2099">		}</span>

		/**
		 */
		@Override
		@SuppressWarnings(&quot;deprecation&quot;)
		void superSetBackgroundDrawable(Drawable drawable) {
<span class="nc" id="L2106">			CalendarView.super.setBackgroundDrawable(drawable);</span>
<span class="nc" id="L2107">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		void superSetBackgroundTintList(ColorStateList tint) {
<span class="nc" id="L2114">			CalendarView.super.setBackgroundTintList(tint);</span>
<span class="nc" id="L2115">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		ColorStateList superGetBackgroundTintList() {
<span class="nc" id="L2122">			return CalendarView.super.getBackgroundTintList();</span>
		}

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		void superSetBackgroundTintMode(PorterDuff.Mode tintMode) {
<span class="nc" id="L2130">			CalendarView.super.setBackgroundTintMode(tintMode);</span>
<span class="nc" id="L2131">		}</span>

		/**
		 */
		@Override
		@TargetApi(Build.VERSION_CODES.LOLLIPOP)
		PorterDuff.Mode superGetBackgroundTintMode() {
<span class="nc" id="L2138">			return CalendarView.super.getBackgroundTintMode();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>